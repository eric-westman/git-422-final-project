00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/6/2021 11:42:09 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 00002C2C    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 00002C3A    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 00002C2C             51                      LEA     adrValStart,A4
00001020  4BF9 00002C30             52                      LEA     adrStrStart,A5
00001026  4EB9 000019B2             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 00002C3A             54                      LEA     adrValEnd,A4
00001032  4BF9 00002C3E             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019B2             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 00001196             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 00002C2C             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001530             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 00002C4C             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 00002C48             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 00002C5A             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 00002C4A        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 00002C4B        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002CB2        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002CB3        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002CB4        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002CB5        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002CB6        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002CB8    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 00002CBC        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 00002CBE    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002CC2        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA                            96                      ** Jump table
000010CA                            97                      **
000010CA  3A39 00002C48             98                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010D0  1C3C 000C                 99                      MOVE.B  #12,D6
000010D4  EC6D                     100                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010D6  CAFC 0008                101                      MULU    #8,D5                   * offset is multiple of 8
000010DA  4EB0 5000                102                      JSR     0(A0,D5)                * Jump indirect with index
000010DE                           103  
000010DE                           104                      ** Invalid instruction
000010DE                           105                      **
000010DE  0C39 0001 00002C4B       106                      CMP.B   #1,opErr
000010E6  6700 0006                107                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
000010EA  6000 0008                108                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
000010EE  2479 00002C5A            109  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
000010F4                           110  
000010F4                           111                      ** Display result
000010F4                           112                      **
000010F4  4EB9 00001592            113  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
000010FA                           114  
000010FA                           115                      ** Max lines display stop, wait for enter
000010FA                           116                      **
000010FA  5207                     117  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
000010FC                           118  
000010FC  2C07                     119                      MOVE.L  D7,D6                   * Line counter to D6 for division
000010FE  8CFC 001A                120                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001102  4846                     121                      SWAP    D6                      * Swap for remainder (modulo)
00001104  BC3C 0000                122                      CMP.B   #0,D6                   * Check remainder for zero
00001108  6700 0006                123                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000110C  6000 0024                124                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001110                           125  
00001110                           126                      ** Logic to check ENTER key to show next page
00001110                           127                      **
00001110  43F9 00002FC7            128  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001116  103C 000E                129                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000111A  4E4F                     130                      TRAP    #15                     * Display to screen
0000111C  103C 0005                131                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001120  4E4F                     132                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001122                           133  
00001122                           134                      ** Clear screen
00001122  103C 000B                135                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001126  323C FF00                136                      MOVE.W  #$FF00,D1               * Clear the screen
0000112A  4E4F                     137                      TRAP    #15
0000112C                           138  
0000112C                           139                      ** Display header
0000112C  4EB9 00001530            140                      JSR     SR_DSP_HEADER
00001132                           141  
00001132                           142                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001132                           143                      **
00001132  B5F9 00002C3A            144  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
00001138  6C00 0006                145                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000113C  6000 003A                146                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001140                           147  
00001140                           148                      ** Logic to check for for Y or N to check another region of memory
00001140                           149                      **
00001140  43F9 00002FEA            150  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001146  103C 000E                151                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000114A  4E4F                     152                      TRAP    #15                     * Display to screen
0000114C  43F9 0000301D            153                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001152  103C 000E                154                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001156  4E4F                     155                      TRAP    #15                     * Display to screen
00001158                           156  
00001158  43F9 00002D4B            157                      LEA     msgInTemp,A1            * Load placeholder for input string
0000115E  103C 0002                158                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001162  4E4F                     159                      TRAP    #15                     * Read string to (A1), length in D1.W
00001164  0C11 0059                160                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
00001168  6700 FE9C                161                      BEQ     Fn_MAIN_Start           * Restart program
0000116C  0C11 0079                162                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001170  6700 FE94                163                      BEQ     Fn_MAIN_Start           * Restart program
00001174  6000 0006                164                      BRA     Fn_Main_Done            * Exit program
00001178                           165  
00001178  6000 FEE2                166  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000117C                           167  
0000117C                           168  Fn_MAIN_Done        ** That's all folks
0000117C  103C 000B                169                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001180  323C FF00                170                      MOVE.W  #$FF00,D1               * Clear the screen
00001184  4E4F                     171                      TRAP    #15
00001186                           172  
00001186                           173                      ** Thank you message
00001186  43F9 0000304F            174                      LEA     msgDone,A1              * Loads MESSAGE into A1
0000118C  103C 000E                175                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001190  4E4F                     176                      TRAP    #15                     * Display to screen
00001192                           177  
00001192                           178  
00001192  4E72 2700                179                      STOP   #$2700                   * Stop execution
00001196                           180  
00001196                           181  ** -----------------------------------------------------------
00001196                           182  ** JUMP TABLE: First 4 bits of instruction
00001196                           183  **
00001196                           184  ** Jump instruction: pointing to label (xxx).L
00001196                           185  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
00001196                           186  **                          label address (Long)
00001196                           187  **
00001196                           188  ** RTS instruction:
00001196                           189  **  |4    E    |7    5     |               - Offset 2 bytes
00001196                           190  **
00001196                           191  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
00001196                           192  **
00001196                           193  ** Note: should find a value since 4 bits is 0 to F
00001196                           194  ** Note: There aren't any instructions that start with F
00001196                           195  **
00001196                           196  ** -----------------------------------------------------------
00001196  4EB9 000019F6            197  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
0000119C  4E75                     198                      RTS
0000119E  4EB9 000019F8            199                      JSR     SR_ID3
000011A4  4E75                     200                      RTS
000011A6  4EB9 000019F8            201                      JSR     SR_ID3
000011AC  4E75                     202                      RTS
000011AE  4EB9 000019F8            203                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011B4  4E75                     204                      RTS
000011B6  4EB9 00001C3A            205                      JSR     SR_ID4
000011BC  4E75                     206                      RTS
000011BE  4EB9 000020C0            207                      JSR     SR_ID5
000011C4  4E75                     208                      RTS
000011C6  4EB9 0000222A            209                      JSR     SR_ID6
000011CC  4E75                     210                      RTS
000011CE  4EB9 0000231A            211                      JSR     SR_ID7
000011D4  4E75                     212                      RTS
000011D6  4EB9 000023A2            213                      JSR     SR_ID8
000011DC  4E75                     214                      RTS
000011DE  4EB9 000025B0            215                      JSR     SR_ID9
000011E4  4E75                     216                      RTS
000011E6  4EB9 000027BE            217                      JSR     SR_IDA
000011EC  4E75                     218                      RTS
000011EE  4EB9 000027C0            219                      JSR     SR_IDB
000011F4  4E75                     220                      RTS
000011F6  4EB9 000027C2            221                      JSR     SR_IDC
000011FC  4E75                     222                      RTS
000011FE  4EB9 000029D0            223                      JSR     SR_IDD
00001204  4E75                     224                      RTS
00001206  4EB9 00002C2A            225                      JSR     SR_IDE
0000120C  4E75                     226                      RTS
0000120E  4EB9 000019F6            227                      JSR     SR_IDX                   * No instructions @ ID=15
00001214  4E75                     228                      RTS
00001216                           229  
00001216                           230  ** -----------------------------------------------------------
00001216                           231  ** UI: User mem input
00001216                           232  ** -----------------------------------------------------------
00001216                           233  SR_UI_INPUT
00001216  13F8 00FF 00002C39       234                      MOVE.B  $FF,adrStsStart         * Reset starting address status
0000121E  13F8 00FF 00002C47       235                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001226                           236  
00001226                           237  Fn_UI_Loop          ** Clear screen
00001226  103C 000B                238                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000122A  323C FF00                239                      MOVE.W  #$FF00,D1               * Clear the screen
0000122E  4E4F                     240                      TRAP    #15
00001230                           241  
00001230                           242                      ** Header
00001230                           243                      ** ***************************************
00001230                           244  
00001230  43F9 00003079            245                      LEA     msgLine,A1              * '********************'
00001236  103C 000E                246                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000123A  4E4F                     247                      TRAP    #15                     * Display to screen
0000123C                           248  
0000123C  43F9 00002DA2            249                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001242  103C 000E                250                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001246  4E4F                     251                      TRAP    #15                     * Display to screen
00001248                           252  
00001248  0C39 0000 00002C39       253                      CMP.B   #0,adrStsStart          * Starting address is set
00001250  6700 0006                254                      BEQ     Fn_UI_DspStart          * Display starting address
00001254  6000 0026                255                      BRA     Fn_UI_HdrNext           * Display the rest of the header
00001258                           256  
00001258  43F9 00002F48            257  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
0000125E  103C 000E                258                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001262  4E4F                     259                      TRAP    #15                     * Display to screen
00001264                           260  
00001264  43F9 00002C30            261                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000126A  103C 000E                262                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000126E  4E4F                     263                      TRAP    #15                     * Display to screen
00001270                           264  
00001270  43F9 000030AE            265                      LEA     msgNewLine,A1           * CR,LF
00001276  103C 000E                266                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000127A  4E4F                     267                      TRAP    #15                     * Display to screen
0000127C                           268  
0000127C  43F9 00003079            269  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
00001282  103C 000E                270                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001286  4E4F                     271                      TRAP    #15                     * Display to screen
00001288                           272  
00001288  43F9 00002DCC            273                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
0000128E  103C 000E                274                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001292  4E4F                     275                      TRAP    #15                     * Display to screen
00001294                           276  
00001294  43F9 00002DFB            277                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
0000129A  103C 000E                278                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129E  4E4F                     279                      TRAP    #15                     * Display to screen
000012A0                           280  
000012A0  43F9 00002E2D            281                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012A6  103C 000E                282                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012AA  4E4F                     283                      TRAP    #15                     * Display to screen
000012AC                           284  
000012AC  43F9 00002E62            285                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012B2  103C 000E                286                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B6  4E4F                     287                      TRAP    #15                     * Display to screen
000012B8                           288  
000012B8  43F9 00002E81            289                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012BE  103C 000E                290                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C2  4E4F                     291                      TRAP    #15                     * Display to screen
000012C4                           292  
000012C4  43F9 00002EC2            293                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012CA  103C 000E                294                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CE  4E4F                     295                      TRAP    #15                     * Display to screen
000012D0                           296  
000012D0  43F9 000030AE            297                      LEA     msgNewLine,A1           * CR,LF
000012D6  103C 000E                298                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012DA  4E4F                     299                      TRAP    #15                     * Display to screen
000012DC                           300  
000012DC                           301                      ** Input check
000012DC                           302                      ** ***************************************
000012DC                           303  
000012DC  0C39 0000 00002C39       304                      CMP.B #0,adrStsStart            * Check status of address 0 = success
000012E4  6600 0012                305                      BNE   Fn_UI_Start               * Input starting address
000012E8                           306  
000012E8  0C39 0000 00002C47       307                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
000012F0  6600 005E                308                      BNE   Fn_UI_End                 * Input ending address
000012F4                           309  
000012F4                           310                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
000012F4  6000 01C6                311                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
000012F8                           312  
000012F8                           313  Fn_UI_Start         ** Input Start Address
000012F8                           314                      ** ***************************************
000012F8                           315  
000012F8                           316                      ** Check errors
000012F8  0C39 0001 00002C39       317                      CMP.B   #1,adrStsStart
00001300  6700 0012                318                      BEQ     Fn_UI_StartE1           * Error: length
00001304  0C39 0002 00002C39       319                      CMP.B   #2,adrStsStart
0000130C  6700 0016                320                      BEQ     Fn_UI_StartE2           * Error: hex value
00001310  6000 0022                321                      BRA     Fn_UI_Start_In          * No error: ask for input
00001314                           322  
00001314  43F9 00002EF9            323  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000131A  103C 000E                324                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000131E  4E4F                     325                      TRAP    #15
00001320  6000 0012                326                      BRA     Fn_UI_Start_In          * User input
00001324                           327  
00001324  43F9 00002F1B            328  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000132A  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000132E  4E4F                     330                      TRAP    #15
00001330  6000 0002                331                      BRA     Fn_UI_Start_In          * User input
00001334                           332  
00001334  43F9 00002ED7            333  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000133A  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000133E  4E4F                     335                      TRAP    #15                     * Display to screen
00001340                           336  
00001340  43F9 00002D4B            337                      LEA     msgInTemp,A1            * Load placeholder for input string
00001346  103C 0002                338                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000134A  4E4F                     339                      TRAP    #15                     * Read string to (A1), length in D1.W
0000134C                           340  
0000134C  6000 005A                341                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001350                           342  
00001350                           343  Fn_UI_End           ** Input End Address
00001350                           344                      ** ***************************************
00001350                           345  
00001350                           346                      ** Check errors
00001350  0C39 0001 00002C47       347                      CMP.B   #1,adrStsEnd
00001358  6700 0012                348                      BEQ     Fn_UI_EndE1             * Error: length
0000135C  0C39 0002 00002C47       349                      CMP.B   #2,adrStsEnd
00001364  6700 0016                350                      BEQ     Fn_UI_EndE2             * Error: hex value
00001368  6000 0022                351                      BRA     Fn_UI_End_In            * No error: ask for input
0000136C                           352  
0000136C  43F9 00002F7C            353  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001372  103C 000E                354                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001376  4E4F                     355                      TRAP    #15
00001378  6000 0012                356                      BRA     Fn_UI_End_In            * User input
0000137C                           357  
0000137C  43F9 00002F9C            358  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
00001382  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001386  4E4F                     360                      TRAP    #15
00001388  6000 0002                361                      BRA     Fn_UI_End_In            * User input
0000138C                           362  
0000138C  43F9 00002F5B            363  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
00001392  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001396  4E4F                     365                      TRAP    #15                     * Display to screen
00001398                           366  
00001398  43F9 00002D4B            367                      LEA     msgInTemp,A1            * Load placeholder for input string
0000139E  103C 0002                368                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013A2  4E4F                     369                      TRAP    #15                     * Read string to (A1), length in D1.W
000013A4                           370  
000013A4  6000 0002                371                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013A8                           372  
000013A8                           373  Fn_UI_ChkLen        ** Check length
000013A8                           374                      **   length should be 8 ascii characters
000013A8                           375                      **   value stored in D1.W from input
000013A8                           376                      ** ***************************************
000013A8                           377  
000013A8  B27C 0008                378                      CMP.W   #8,D1                   * Address should be 8 chars long
000013AC  6600 0006                379                      BNE     Fn_UI_SetELen           * Invalid address length
000013B0  6000 002A                380                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013B4                           381  
000013B4                           382  Fn_UI_SetELen       ** Error: length
000013B4  0C39 0000 00002C39       383                      CMP.B #0,adrStsStart
000013BC  6600 0006                384                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013C0  6000 000E                385                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013C4                           386  Fn_UI_SetELenI1     ** Set error on input 1
000013C4  13FC 0001 00002C39       387                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013CC  6000 FE58                388                      BRA     Fn_UI_Loop
000013D0                           389  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013D0  13FC 0001 00002C47       390                      MOVE.B  #1,adrStsEnd
000013D8  6000 FE4C                391                      BRA     Fn_UI_Loop
000013DC                           392  
000013DC                           393  Fn_UI_ChkHex        ** Check hex values
000013DC                           394                      **   30 - 39 (0-9)
000013DC                           395                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013DC                           396                      ** ***************************************
000013DC                           397  
000013DC  163C 0000                398                      MOVE.B  #0,D3                   * Loop counter
000013E0  4286                     399                      CLR.L   D6                      * Temporary address storage
000013E2                           400  
000013E2                           401  Fn_UI_ChkHexLoop    ** Check hex values one at a time
000013E2  1819                     402                      MOVE.B  (A1)+,D4                * Unload byte and increment input
000013E4                           403  
000013E4  B83C 0030                404                      CMP.B   #$30,D4
000013E8  6D00 00AA                405                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
000013EC                           406  
000013EC  B83C 0039                407                      CMP.B   #$39,D4
000013F0  6F00 0026                408                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
000013F4                           409  
000013F4  B83C 0041                410                      CMP.B   #$41,D4
000013F8  6D00 009A                411                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
000013FC                           412  
000013FC  B83C 0046                413                      CMP.B   #$46,D4
00001400  6F00 0016                414                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001404                           415  
00001404  B83C 0061                416                      CMP.B   #$61,D4
00001408  6D00 008A                417                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140C                           418  
0000140C  B83C 0066                419                      CMP.B   #$66,D4
00001410  6F00 0006                420                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001414                           421  
00001414  6000 007E                422                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
00001418                           423  
00001418                           424  Fn_UI_ChkHexDone    ** Check if at end of loop
00001418                           425  
00001418  5203                     426                      ADDI.B  #1,D3                   * Increment loop counter
0000141A                           427  
0000141A                           428                      ** Insert ascii value into temp address
0000141A  1A04                     429                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000141C  4EB9 00001974            430                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001422  DC05                     431                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001424  B63C 0008                432                      CMP.B   #8,D3                   * To shift or not to shift
00001428  6D00 0006                433                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000142C  6000 0004                434                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001430  E986                     435  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001432                           436  
00001432                           437  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001432  B63C 0008                438                      CMP.B   #8,D3                   * Loop 8 times
00001436  66AA                     439                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
00001438  6000 0002                440                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000143C                           441  
0000143C                           442  Fn_UI_SetVHex       ** Valid: hex values
0000143C  0C39 0000 00002C39       443                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001444  6600 0006                444                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
00001448  6000 0026                445                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000144C                           446  
0000144C                           447  Fn_UI_SetVHexI1     ** Set valid on input 1
0000144C  13FC 0000 00002C39       448                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001454  23C6 00002C2C            449                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000145A  49F9 00002C2C            450                      LEA     adrValStart,A4
00001460  4BF9 00002C30            451                      LEA     adrStrStart,A5
00001466  4EB9 000019B2            452                      JSR     SR_HEX_STR              * Copy address value to string for display
0000146C  6000 FDB8                453                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001470                           454  
00001470                           455  Fn_UI_SetVHexI2     ** Set valid on input 2
00001470  13FC 0000 00002C47       456                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
00001478  23C6 00002C3A            457                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
0000147E  49F9 00002C3A            458                      LEA     adrValEnd,A4
00001484  4BF9 00002C3E            459                      LEA     adrStrEnd,A5
0000148A  4EB9 000019B2            460                      JSR     SR_HEX_STR              * Copy address value to string for display
00001490  6000 FD94                461                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001494                           462  
00001494                           463  Fn_UI_SetEHex       ** Error: hex values
00001494  0C39 0000 00002C39       464                      CMP.B   #0,adrStsStart
0000149C  6600 0006                465                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014A0  6000 000E                466                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014A4                           467  
000014A4                           468  Fn_UI_SetEHexI1     ** Set error on input 1
000014A4  13FC 0002 00002C39       469                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014AC  6000 FD78                470                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014B0                           471  
000014B0                           472  Fn_UI_SetEHexI2     ** Set error on input 2
000014B0  13FC 0002 00002C47       473                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014B8  6000 FD6C                474                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014BC                           475  
000014BC                           476  Fn_UI_ChkVal        ** Check address range, order
000014BC                           477                      **   Address automagic - will fix addresses if invalid input
000014BC                           478                      ** Note: addresses are unsigned; should not be less than zero
000014BC                           479                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014BC                           480                      ** Note: subtracting one from Start address if not even
000014BC                           481                      **       doesn't really matter if end address is even or odd
000014BC                           482                      ** ***************************************
000014BC                           483  
000014BC  2A39 00002C2C            484                      MOVE.L  adrValStart,D5
000014C2  2C39 00002C3A            485                      MOVE.L  adrValEnd,D6
000014C8                           486  
000014C8  BABC 00FFFFEC            487  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014CE  6200 0006                488                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014D2  6000 0008                489                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014D6                           490  
000014D6  2A3C 00FFFFEC            491  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014DC                           492  
000014DC  BCBC 00FFFFED            493  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
000014E2  6200 0006                494                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
000014E6  6000 0008                495                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
000014EA                           496  
000014EA  2C3C 00FFFFED            497  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
000014F0                           498  
000014F0  BA86                     499  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
000014F2  6200 0006                500                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
000014F6  6000 0008                501                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
000014FA                           502  
000014FA  2805                     503  Fn_UI_ChkValSwp     MOVE.L  D5,D4
000014FC  2A06                     504                      MOVE.L  D6,D5
000014FE  2C04                     505                      MOVE.L  D4,D6
00001500                           506  
00001500                           507  FN_UI_ChkValSWrd    ** Check start for word boundry
00001500  1605                     508                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001502  183C 0002                509                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001506  86C4                     510                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
00001508  4843                     511                      SWAP    D3                       * Swap for remainder (the modulo part)
0000150A  B63C 0000                512                      CMP.B   #0,D3                    * If zero, then even
0000150E  6600 0006                513                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001512  6000 0004                514                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001516                           515  
00001516  5385                     516  Fn_UI_ChkValSOne    SUBI.L  #1,D5
00001518                           517  
00001518                           518  Fn_UI_Done          ** All done with input, time to go
00001518                           519                      ** ***************************************
00001518                           520  
00001518  23C5 00002C2C            521                      MOVE.L  D5,adrValStart          * Move final address to Start
0000151E  23C6 00002C3A            522                      MOVE.L  D6,adrValEnd            * Move final address to End
00001524                           523  
00001524                           524                      ** Clear screen
00001524  103C 000B                525                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001528  323C FF00                526                      MOVE.W  #$FF00,D1               * Clear the screen
0000152C  4E4F                     527                      TRAP    #15
0000152E                           528  
0000152E  4E75                     529                      RTS
00001530                           530  
00001530                           531  ** -----------------------------------------------------------
00001530                           532  ** UI: Display Header
00001530                           533  ** -----------------------------------------------------------
00001530                           534  SR_DSP_HEADER
00001530                           535  
00001530                           536                      ** Header line 03
00001530  43F9 00003079            537                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001536  103C 000E                538                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000153A  4E4F                     539                      TRAP    #15                     * Display to screen
0000153C                           540  
0000153C                           541                      ** Header line 01
0000153C  43F9 00002DA2            542                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001542  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001546  4E4F                     544                      TRAP    #15                     * Display to screen
00001548                           545  
00001548                           546                      ** Header line 02
00001548  43F9 00002DB9            547                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
0000154E  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001552  4E4F                     549                      TRAP    #15                     * Display to screen
00001554                           550  
00001554  43F9 00002C30            551                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000155A  103C 000E                552                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155E  4E4F                     553                      TRAP    #15                     * Display to screen
00001560                           554  
00001560  43F9 00002DC7            555                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001566  103C 000E                556                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000156A  4E4F                     557                      TRAP    #15
0000156C                           558  
0000156C  43F9 00002C3E            559                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001572  103C 000E                560                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001576  4E4F                     561                      TRAP    #15                     * Display to screen
00001578                           562  
00001578  43F9 000030AE            563                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
0000157E  103C 000E                564                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001582  4E4F                     565                      TRAP    #15                     * Display to screen
00001584                           566  
00001584                           567                      ** Header line 03
00001584  43F9 00003079            568                      LEA     msgLine,A1              * Loads MESSAGE into A1
0000158A  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158E  4E4F                     570                      TRAP    #15                     * Display to screen
00001590                           571  
00001590  4E75                     572                      RTS
00001592                           573  
00001592                           574  ** -----------------------------------------------------------
00001592                           575  ** UI: Display item
00001592                           576  ** -----------------------------------------------------------
00001592                           577  SR_DSP_DISPLAY
00001592                           578                      ** Output buffer
00001592                           579                      **   Need buffer for spacing issues
00001592                           580                      **
00001592  47F9 00002C5E            581                      LEA     opOutBuf,A3             * Reset pointer to output buffer
00001598  16BC 0000                582                      MOVE.B  #$00,(A3)               * Insert NULL
0000159C                           583  
0000159C                           584                      ** Push opValAdr to opStrAdr
0000159C  49F9 00002C4C            585                      LEA     opValAdr,A4             * input hex
000015A2  4BF9 00002C50            586                      LEA     opStrAdr,A5             * output string
000015A8  4EB9 000019B2            587                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015AE  49F9 00002C50            588                      LEA     opStrAdr,A4
000015B4  4EB9 000019E4            589                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015BA                           590  
000015BA                           591                      ** Instruction or DATA redirector
000015BA                           592                      **
000015BA  0C39 0001 00002C4B       593                      CMP.B   #1, opErr               * Check instruction type
000015C2  6700 0006                594                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015C6  6000 001E                595                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015CA                           596  
000015CA                           597  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015CA                           598                      **
000015CA                           599  
000015CA                           600                      ** Space
000015CA  49F9 000030B5            601                      LEA     opSpace,A4
000015D0  4EB9 000019E4            602                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015D6                           603  
000015D6                           604                      ** Instruction name
000015D6  49F9 00002CD1            605                      LEA     opNam_DATA,A4
000015DC  4EB9 000019E4            606                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015E2                           607  
000015E2  6000 037E                608                      BRA     Fn_Dsp_Done
000015E6                           609  
000015E6                           610  Fn_Dsp_Instr        ** Process instruction
000015E6                           611                      **
000015E6                           612  
000015E6                           613                      ** Space
000015E6  49F9 000030B5            614                      LEA     opSpace,A4
000015EC  4EB9 000019E4            615                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F2                           616  
000015F2                           617                      ** Instruction name
000015F2  2879 00002CAE            618                      MOVE.L  opPtrNam,A4
000015F8  4EB9 000019E4            619                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015FE                           620  
000015FE                           621                      ** Instruciton size
000015FE                           622                      **
000015FE  0C39 0000 00002CB2       623                      CMP.B   #0,opValSiz
00001606  6700 001E                624                      BEQ     Fn_DSP_SizB             * Size is Byte
0000160A  0C39 0001 00002CB2       625                      CMP.B   #1,opValSiz
00001612  6700 0022                626                      BEQ     Fn_DSP_SizW             * Size is Word
00001616  0C39 0002 00002CB2       627                      CMP.B   #2,opValSiz
0000161E  6700 0026                628                      BEQ     Fn_DSP_SizL             * Size is Long
00001622  6000 003E                629                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001626                           630  
00001626  49F9 00002D42            631  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000162C  4EB9 000019E4            632                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001632  6000 0022                633                      BRA     Fn_DSP_OPR1
00001636                           634  
00001636  49F9 00002D45            635  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000163C  4EB9 000019E4            636                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001642  6000 0012                637                      BRA     Fn_DSP_OPR1
00001646                           638  
00001646  49F9 00002D48            639  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000164C  4EB9 000019E4            640                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001652  6000 0002                641                      BRA     Fn_DSP_OPR1
00001656                           642  
00001656                           643  Fn_DSP_OPR1         ** Display First Operand
00001656  49F9 000030B8            644                      LEA     opTab,A4                * Tab (or calculated spaces)
0000165C  4EB9 000019E4            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001662                           646  
00001662                           647  Fn_DSP_DTA1         ** Data 1 (source)
00001662                           648                      ** **************************************************
00001662                           649                      **
00001662                           650  
00001662                           651                      ** Check if source mode set (may not have a source)
00001662  0C39 00FF 00002CB8       652                      CMP.B   #$FF,opDta1
0000166A  6700 017C                653                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
0000166E                           654  
0000166E                           655                      ** Check source mode
0000166E                           656                      **
0000166E  0C39 0000 00002CB6       657                      CMP.B   #0,opSrcMod
00001676  6700 0042                658                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000167A  0C39 0001 00002CB6       659                      CMP.B   #1,opSrcMod
00001682  6700 004A                660                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
00001686  0C39 0002 00002CB6       661                      CMP.B   #2,opSrcMod
0000168E  6700 0052                662                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
00001692  0C39 0003 00002CB6       663                      CMP.B   #3,opSrcMod
0000169A  6700 0062                664                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
0000169E  0C39 0004 00002CB6       665                      CMP.B   #4,opSrcMod
000016A6  6700 0076                666                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016AA  0C39 0007 00002CB6       667                      CMP.B   #7,opSrcMod
000016B2  6700 008A                668                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016B6                           669  
000016B6  6000 0114                670                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016BA                           671  
000016BA                           672  Fn_DSP_DTA1_00      ** Handling data mode 0
000016BA  16FC 0044                673                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016BE  1639 00002CB5            674                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016C4  0603 0030                675                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016C8  16C3                     676                      MOVE.B  D3,(A3)+                * Insert Register value
000016CA  6000 0110                677                      BRA     Fn_DSP_OPR2             * Display data 2
000016CE                           678  
000016CE                           679  Fn_DSP_DTA1_01      ** Handling data mode 1
000016CE  16FC 0041                680                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016D2  1639 00002CB5            681                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016D8  0603 0030                682                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016DC  16C3                     683                      MOVE.B  D3,(A3)+                * Insert Register value
000016DE  6000 00FC                684                      BRA     Fn_DSP_OPR2             * Display data 2
000016E2                           685  
000016E2                           686  Fn_DSP_DTA1_02      ** Handling data mode 2
000016E2  16FC 0028                687                      MOVE.B  #$28,(A3)+              * Insert '(' character
000016E6  16FC 0041                688                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016EA  1639 00002CB5            689                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016F0  0603 0030                690                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016F4  16C3                     691                      MOVE.B  D3,(A3)+                * Insert Register value
000016F6  16FC 0029                692                      MOVE.B  #$29,(A3)+              * Insert ')' character
000016FA  6000 00E0                693                      BRA     Fn_DSP_OPR2             * Display data 2
000016FE                           694  
000016FE                           695  Fn_DSP_DTA1_03      ** Handling data mode 3
000016FE  16FC 0028                696                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001702  16FC 0041                697                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001706  1639 00002CB5            698                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000170C  0603 0030                699                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001710  16C3                     700                      MOVE.B  D3,(A3)+                * Insert Register value
00001712  16FC 0029                701                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001716  16FC 002B                702                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000171A  6000 00C0                703                      BRA     Fn_DSP_OPR2             * Display data 2
0000171E                           704  
0000171E                           705  Fn_DSP_DTA1_04      ** Handling data mode 4
0000171E  16FC 002D                706                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001722  16FC 0028                707                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001726  16FC 0041                708                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000172A  1639 00002CB5            709                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001730  0603 0030                710                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001734  16C3                     711                      MOVE.B  D3,(A3)+                * Insert Register value
00001736  16FC 0029                712                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000173A  6000 00A0                713                      BRA     Fn_DSP_OPR2             * Display data 2
0000173E                           714  
0000173E                           715  Fn_DSP_DTA1_07      ** Handling data mode 7
0000173E  0C39 0000 00002CBC       716                      CMP.B   #0,opDta1T
00001746  6700 001E                717                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000174A  0C39 0001 00002CBC       718                      CMP.B   #1,opDta1T
00001752  6700 0034                719                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001756  0C39 0002 00002CBC       720                      CMP.B   #2,opDta1T
0000175E  6700 004A                721                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001762                           722  
00001762  6000 0068                723                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001766                           724  
00001766                           725  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001766  49F9 00002CB8            726                      LEA     opDta1,A4               * input hex
0000176C  4BF9 00002CC3            727                      LEA     opStrDtaWrd,A5          * output string
00001772  4EB9 000019B2            728                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001778  49F9 00002CC3            729                      LEA     opStrDtaWrd,A4
0000177E  4EB9 000019E4            730                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001784  6000 0056                731                      BRA     Fn_DSP_OPR2             * Display data 2
00001788                           732  
00001788                           733  Fn_DSP_DTA1_WRD     ** Display data Word
00001788  49F9 00002CB8            734                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002CC3            735                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019B2            736                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002CC3            737                      LEA     opStrDtaWrd,A4
000017A0  4EB9 000019E4            738                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0034                739                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           740  
000017AA                           741  Fn_DSP_DTA1_LNG     ** Display data Long
000017AA  49F9 00002CB8            742                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002CC8            743                      LEA     opStrDtaLng,A5          * output string
000017B6  4EB9 000019B2            744                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002CC8            745                      LEA     opStrDtaLng,A4
000017C2  4EB9 000019E4            746                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0012                747                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           748  
000017CC                           749  Fn_DSP_DTA1_ERR     ** Something is messed up
000017CC  49F9 00002D9C            750                      LEA     msgErr,A4
000017D2  4EB9 000019E4            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017D8  6000 0002                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017DC                           753  
000017DC                           754  Fn_DSP_OPR2         ** Display Second Operand
000017DC  49F9 000030B1            755                      LEA     opComma,A4              * Comma
000017E2  4EB9 000019E4            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017E8                           757  
000017E8                           758  Fn_DSP_DTA2         ** Data 2 (destination)
000017E8                           759                      ** **************************************************
000017E8                           760                      **
000017E8                           761  
000017E8                           762                      ** Check if destination mode set (may not have a destination)
000017E8  0C39 00FF 00002CB4       763                      CMP.B   #$FF,opDstMod
000017F0  6700 0170                764                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
000017F4                           765  
000017F4  0C39 0000 00002CB4       766                      CMP.B   #0,opDstMod
000017FC  6700 0042                767                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001800  0C39 0001 00002CB4       768                      CMP.B   #1,opDstMod
00001808  6700 004A                769                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000180C  0C39 0002 00002CB4       770                      CMP.B   #2,opDstMod
00001814  6700 0052                771                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
00001818  0C39 0003 00002CB4       772                      CMP.B   #3,opDstMod
00001820  6700 0062                773                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001824  0C39 0004 00002CB4       774                      CMP.B   #4,opDstMod
0000182C  6700 0076                775                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001830  0C39 0007 00002CB4       776                      CMP.B   #7,opDstMod
00001838  6700 008A                777                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000183C                           778  
0000183C  6000 0114                779                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001840                           780  
00001840                           781  Fn_DSP_DTA2_00      ** Handling mode 0
00001840  16FC 0044                782                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001844  1639 00002CB3            783                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000184A  0603 0030                784                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000184E  16C3                     785                      MOVE.B  D3,(A3)+                * Insert Register value
00001850  6000 0110                786                      BRA     Fn_DSP_DONE             * Done with display
00001854                           787  
00001854                           788  Fn_DSP_DTA2_01      ** Handling mode 1
00001854  16FC 0041                789                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001858  1639 00002CB3            790                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000185E  0603 0030                791                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001862  16C3                     792                      MOVE.B  D3,(A3)+                * Insert Register value
00001864  6000 00FC                793                      BRA     Fn_DSP_DONE             * Done with display
00001868                           794  
00001868                           795  Fn_DSP_DTA2_02      ** Handling mode 2
00001868  16FC 0028                796                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000186C  16FC 0041                797                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001870  1639 00002CB3            798                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001876  0603 0030                799                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000187A  16C3                     800                      MOVE.B  D3,(A3)+                * Insert Register value
0000187C  16FC 0029                801                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001880  6000 00E0                802                      BRA     Fn_DSP_DONE             * Done with display
00001884                           803  
00001884                           804  Fn_DSP_DTA2_03      ** Handling mode 3
00001884  16FC 0028                805                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001888  16FC 0041                806                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000188C  1639 00002CB3            807                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001892  0603 0030                808                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001896  16C3                     809                      MOVE.B  D3,(A3)+                * Insert Register value
00001898  16FC 0029                810                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000189C  16FC 002B                811                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018A0  6000 00C0                812                      BRA     Fn_DSP_DONE             * Done with display
000018A4                           813  
000018A4                           814  Fn_DSP_DTA2_04      ** Handling mode 4
000018A4  16FC 002D                815                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018A8  16FC 0028                816                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AC  16FC 0041                817                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018B0  1639 00002CB5            818                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018B6  0603 0030                819                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018BA  16C3                     820                      MOVE.B  D3,(A3)+                * Insert Register value
000018BC  16FC 0029                821                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018C0  6000 00A0                822                      BRA     Fn_DSP_DONE             * Done with display
000018C4                           823  
000018C4                           824  Fn_DSP_DTA2_07      ** Handling mode 8
000018C4  0C39 0000 00002CC2       825                      CMP.B   #0,opDta2T
000018CC  6700 001E                826                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018D0  0C39 0001 00002CC2       827                      CMP.B   #1,opDta2T
000018D8  6700 0034                828                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018DC  0C39 0002 00002CC2       829                      CMP.B   #2,opDta2T
000018E4  6700 004A                830                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
000018E8                           831  
000018E8  6000 0068                832                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
000018EC                           833  
000018EC                           834  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
000018EC  49F9 00002CBE            835                      LEA     opDta2,A4               * input hex
000018F2  4BF9 00002CC3            836                      LEA     opStrDtaWrd,A5          * output string
000018F8  4EB9 000019B2            837                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000018FE  49F9 00002CC3            838                      LEA     opStrDtaWrd,A4
00001904  4EB9 000019E4            839                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000190A  6000 0056                840                      BRA     Fn_DSP_DONE             * Display data 2
0000190E                           841  
0000190E                           842  Fn_DSP_DTA2_WRD     ** Display data Word
0000190E  49F9 00002CBE            843                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002CC3            844                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019B2            845                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002CC3            846                      LEA     opStrDtaWrd,A4
00001926  4EB9 000019E4            847                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0034                848                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           849  
00001930                           850  Fn_DSP_DTA2_LNG     ** Display data Long
00001930  49F9 00002CBE            851                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002CC8            852                      LEA     opStrDtaLng,A5          * output string
0000193C  4EB9 000019B2            853                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002CC8            854                      LEA     opStrDtaLng,A4
00001948  4EB9 000019E4            855                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0012                856                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           857  
00001952                           858  Fn_DSP_DTA2_ERR     ** Something is messed up
00001952  49F9 00002D9C            859                      LEA     msgErr,A4
00001958  4EB9 000019E4            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000195E  6000 0002                861                      BRA     Fn_DSP_DONE             * Display data 2
00001962                           862  
00001962                           863  Fn_Dsp_Done         ** Done with instruction display
00001962  16BC 0000                864                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001966  43F9 00002C5E            865                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000196C  103C 000D                866                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001970  4E4F                     867                      TRAP    #15
00001972                           868  
00001972                           869                      ** We're all done here - time to go
00001972                           870                      **
00001972  4E75                     871                      RTS                             * Return back to caller
00001974                           872  
00001974                           873  ** -----------------------------------------------------------
00001974                           874  ** Convert single ASCII value to hexadecimal
00001974                           875  **    ASCII values should be in range 0-9, A-F
00001974                           876  **
00001974                           877  ** Parameters
00001974                           878  **   D5 - Hex value to assess. Converted value returned in D5
00001974                           879  **
00001974                           880  ** Example:
00001974                           881  **   $30 -> $0
00001974                           882  **   $41 -> $A
00001974                           883  **   $61 -> $A
00001974                           884  ** -----------------------------------------------------------
00001974                           885  SR_ASCII_HEX
00001974  BA3C 0039                886                      CMP.B   #$39,D5
00001978  6F00 000E                887                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000197C  BA3C 0046                888                      CMP.B   #$46,D5
00001980  6F00 000C                889                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
00001984  6000 000E                890                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
00001988                           891  
00001988  0405 0030                892  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
0000198C  4E75                     893                      RTS
0000198E  0405 0037                894  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
00001992  4E75                     895                      RTS
00001994  0405 0057                896  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
00001998  4E75                     897                      RTS
0000199A                           898  
0000199A                           899  ** -----------------------------------------------------------
0000199A                           900  ** Convert single hexadecimal value to ASCII
0000199A                           901  **    hexadecimal values should be in range 0-9, A-F
0000199A                           902  **
0000199A                           903  ** Parameters
0000199A                           904  **   D5 - Hex value to assess. Converted value returned in D5
0000199A                           905  **
0000199A                           906  ** Example:
0000199A                           907  **   $0 -> $30
0000199A                           908  **   $A -> $41
0000199A                           909  **   $a -> $41
0000199A                           910  **
0000199A                           911  ** Note: this function is case insensitive an $a = $A = $41 etc.
0000199A                           912  ** -----------------------------------------------------------
0000199A                           913  SR_HEX_ASCII
0000199A  BA3C 0009                914                      CMP.B   #$9,D5
0000199E  6F00 0006                915                      BLE     Fn_HEX_Num              * Hex $0-$9
000019A2  6000 0008                916                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019A6                           917  
000019A6  0605 0030                918  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019AA  4E75                     919                      RTS
000019AC  0605 0037                920  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019B0  4E75                     921                      RTS
000019B2                           922  
000019B2                           923  ** -----------------------------------------------------------
000019B2                           924  ** Copy hexadecimal value to string
000019B2                           925  **
000019B2                           926  ** Parameters
000019B2                           927  **   A4 - Pointer to value copying from
000019B2                           928  **   A5 - Pointer to defined constant
000019B2                           929  **
000019B2                           930  ** Data registers
000019B2                           931  **   D4 - Current byte      (hex value A4)
000019B2                           932  **   D5 - Temp byte         (hex value or string)
000019B2                           933  **   D6 - Number to shift
000019B2                           934  **
000019B2                           935  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019B2                           936  **
000019B2                           937  ** -----------------------------------------------------------
000019B2                           938  SR_HEX_STR
000019B2                           939  
000019B2  181C                     940  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019B4                           941  
000019B4  1A15                     942                      MOVE.B  (A5),D5
000019B6  BA3C 0000                943                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019BA  6700 0022                944                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019BE                           945  
000019BE                           946                      ** First Hex value (high order value)
000019BE  1A04                     947                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019C0  1C3C 0004                948                      MOVE.B  #4,D6
000019C4  EC2D                     949                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019C6  4EB8 199A                950                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019CA  1AC5                     951                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019CC                           952  
000019CC                           953                      ** Second Hex value (low order value)
000019CC  1A04                     954                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019CE  1C3C 0004                955                      MOVE.B  #4,D6
000019D2  ED2D                     956                      LSL.B   D6,D5
000019D4  EC2D                     957                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019D6  4EB8 199A                958                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019DA  1AC5                     959                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019DC                           960  
000019DC  60D4                     961                      BRA     Fn_Hex_Str_Loop
000019DE                           962  Fn_Hex_Str_Done
000019DE  1AFC 0000                963                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
000019E2                           964  
000019E2  4E75                     965                      RTS
000019E4                           966  
000019E4                           967  ** -----------------------------------------------------------
000019E4                           968  ** Copy string to output buffer @ A3
000019E4                           969  **
000019E4                           970  ** Parameters
000019E4                           971  **   A4 - Pointer to string copying from
000019E4                           972  **
000019E4                           973  ** Data registers
000019E4                           974  **   D5 - Temp byte         (hex value or string)
000019E4                           975  ** -----------------------------------------------------------
000019E4                           976  SR_CPY_STR_BUF
000019E4                           977  
000019E4  1A14                     978  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
000019E6  BA3C 0000                979                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019EA  6700 0006                980                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
000019EE                           981  
000019EE  16DC                     982                      MOVE.B  (A4)+,(A3)+
000019F0  60F2                     983                      BRA     Fn_CPY_STR_Loop
000019F2                           984  
000019F2  4E75                     985  Fn_CPY_STR_Done     RTS
000019F4                           986  
000019F4                           987  ** -----------------------------------------------------------
000019F4                           988  ** Length of string output buffer
000019F4                           989  ** -----------------------------------------------------------
000019F4                           990  SR_CNT_STR_BUF
000019F4                           991  
000019F4  4E75                     992                      RTS
000019F6                           993  
000019F6                           994  ** -----------------------------------------------------------
000019F6                           995  ** Includes: Subroutines etc.
000019F6                           996  ** -----------------------------------------------------------
000019F6                           997                      INCLUDE 'SR_IDX.X68'
000019F6                           998  
000019F6                           999  
000019F6                          1000  SR_IDX
000019F6                          1001  
000019F6  4E75                    1002                RTS
000019F6  4E75                    1003  -------------------- end include --------------------
000019F8                          1004                      INCLUDE 'SR_ID3.X68'
000019F8                          1005  
000019F8                          1006  
000019F8                          1007  SR_ID3
000019F8                          1008  
000019F8                          1009                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
000019F8                          1010  
000019F8                          1011  
000019F8                          1012                      ** ***************************************
000019F8                          1013                      ** Read first 4 bits
000019F8                          1014                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
000019F8                          1015                      ** Note: most instructions will be in this format 3,3,3,3
000019F8                          1016                      **    I think there is only one instrction that is 4,8
000019F8                          1017                      **
000019F8                          1018                      ** ***************************************
000019F8  3639 00002C48           1019                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000019FE  183C 000C               1020                      MOVE.B  #12,D4
00001A02  E86B                    1021                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A04  13C3 00002C4A           1022                      MOVE.B  D3, opID
00001A0A                          1023  
00001A0A                          1024                      ** Read next 3 bits
00001A0A                          1025                      **
00001A0A  3639 00002C48           1026                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A10  183C 0004               1027                      MOVE.B  #4, D4
00001A14  E96B                    1028                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A16  183C 000D               1029                      MOVE.B  #13,D4
00001A1A  E86B                    1030                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A1C  13C3 00002CB3           1031                      MOVE.B  D3, opDstReg
00001A22                          1032  
00001A22                          1033                      ** Read next 3 bits
00001A22                          1034                      **
00001A22  3639 00002C48           1035                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A28  183C 0007               1036                      MOVE.B  #7, D4
00001A2C  E96B                    1037                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A2E  183C 000D               1038                      MOVE.B  #13,D4
00001A32  E86B                    1039                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A34  13C3 00002CB4           1040                      MOVE.B  D3, opDstMod
00001A3A                          1041  
00001A3A                          1042                      ** Read next 3 bits
00001A3A                          1043                      **
00001A3A  3639 00002C48           1044                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A40  183C 000A               1045                      MOVE.B  #10, D4
00001A44  E96B                    1046                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A46  183C 000D               1047                      MOVE.B  #13,D4
00001A4A  E86B                    1048                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A4C  13C3 00002CB6           1049                      MOVE.B  D3, opSrcMod
00001A52                          1050  
00001A52                          1051                      ** Read next 3 bits
00001A52                          1052                      **
00001A52  3639 00002C48           1053                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A58  183C 000D               1054                      MOVE.B  #13, D4
00001A5C  E96B                    1055                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A5E  183C 000D               1056                      MOVE.B  #13,D4
00001A62  E86B                    1057                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A64  13C3 00002CB5           1058                      MOVE.B  D3, opSrcReg
00001A6A                          1059  
00001A6A                          1060                      ** ***************************************
00001A6A                          1061                      ** Verify this is MOVE or MOVEA
00001A6A                          1062                      **
00001A6A                          1063                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A6A                          1064                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A6A                          1065                      **
00001A6A                          1066                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A6A                          1067                      **
00001A6A                          1068                      ** ***************************************
00001A6A  0C39 0001 00002CB4      1069                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A72  6700 0016               1070                      BEQ     Fn_MOVE_Ins02               * Set as instruction 0 MOVEA
00001A76  6000 0002               1071                      BRA     Fn_MOVE_Ins01               * Set as instruction 1 MOVE
00001A7A                          1072  
00001A7A  47F9 00002CD6           1073  Fn_MOVE_Ins01       LEA     opNam_MOVE,A3
00001A80  23CB 00002CAE           1074                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001A86  6000 001A               1075                      BRA     Fn_MOVE_Verify
00001A8A                          1076  
00001A8A  0C39 0001 00002C4A      1077  Fn_MOVE_Ins02       CMP.B   #1, opID
00001A92  6700 01A4               1078                      BEQ     Fn_MOVE_Error               * MOVEA cannot have opID = 1 (byte)
00001A96  47F9 00002CDB           1079                      LEA     opNam_MOVEA,A3
00001A9C  23CB 00002CAE           1080                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA2                          1081  
00001AA2                          1082                      ** ***************************************
00001AA2                          1083                      ** Verify other instruction parameters are correct
00001AA2                          1084                      **
00001AA2                          1085                      **    DstMod = 0 to 7
00001AA2                          1086                      **    DstReg = 0 to 7
00001AA2                          1087                      **    SrcMod = 0 to 7
00001AA2                          1088                      **    SrcReg = 0 to 7
00001AA2                          1089                      **
00001AA2                          1090                      ** ***************************************
00001AA2  0C39 0000 00002CB4      1091  Fn_MOVE_Verify      CMP.B   #0, opDstMod                * Destination mode is >= 0
00001AAA  6D00 018C               1092                      BLT     Fn_MOVE_Error
00001AAE  0C39 0007 00002CB4      1093                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AB6  6E00 0180               1094                      BGT     Fn_MOVE_Error
00001ABA  0C39 0000 00002CB3      1095                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AC2  6D00 0174               1096                      BLT     Fn_MOVE_Error
00001AC6  0C39 0007 00002CB3      1097                      CMP.B   #7, opDstReg                * Destination register <= 7
00001ACE  6E00 0168               1098                      BGT     Fn_MOVE_Error
00001AD2                          1099  
00001AD2  0C39 0000 00002CB6      1100                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001ADA  6D00 015C               1101                      BLT     Fn_MOVE_Error
00001ADE  0C39 0007 00002CB6      1102                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001AE6  6E00 0150               1103                      BGT     Fn_MOVE_Error
00001AEA  0C39 0000 00002CB5      1104                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001AF2  6D00 0144               1105                      BLT     Fn_MOVE_Error
00001AF6  0C39 0007 00002CB5      1106                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001AFE  6E00 0138               1107                      BGT     Fn_MOVE_Error
00001B02                          1108  
00001B02                          1109                      ** ***************************************
00001B02                          1110                      ** Set instruction size - the .B,.W,.L part
00001B02                          1111                      ** Note: size set by opID only for MOVE, MOVEA
00001B02                          1112                      **       other instructions use 3 bits for size
00001B02                          1113                      ** ***************************************
00001B02  0C39 0001 00002C4A      1114                      CMP.B   #1, opID                    * Instruction size is Byte
00001B0A  6700 001A               1115                      BEQ     Fn_MOVE_SizB
00001B0E  0C39 0003 00002C4A      1116                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B16  6700 001A               1117                      BEQ     Fn_MOVE_SizW
00001B1A  0C39 0002 00002C4A      1118                      CMP.B   #2, opID                    * Instruction size is Long
00001B22  6700 001A               1119                      BEQ     Fn_MOVE_SizL
00001B26  13FC 0000 00002CB2      1120  Fn_MOVE_SizB        MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B2E  6000 001A               1121                      BRA     Fn_MOVE_SrcMod
00001B32  13FC 0001 00002CB2      1122  Fn_MOVE_SizW        MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B3A  6000 000E               1123                      BRA     Fn_MOVE_SrcMod
00001B3E  13FC 0002 00002CB2      1124  Fn_MOVE_SizL        MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B46  6000 0002               1125                      BRA     Fn_MOVE_SrcMod
00001B4A                          1126  
00001B4A                          1127                      ** ***************************************
00001B4A                          1128                      ** Grab extra DATA if needed
00001B4A                          1129                      **
00001B4A                          1130                      **    If DstMod = 7
00001B4A                          1131                      **       DstReg = 0 (get Word)
00001B4A                          1132                      **       DstReg = 1 (get Long)
00001B4A                          1133                      **
00001B4A                          1134                      **    If SrcMod = 7
00001B4A                          1135                      **       SrcReg = 0 (get Word)
00001B4A                          1136                      **       SrcReg = 1 (get Long)
00001B4A                          1137                      **       SrcReg = 4
00001B4A                          1138                      **          MOVE.B, MOVE.W (get Word)
00001B4A                          1139                      **          MOVE.L         (get Long)
00001B4A                          1140                      **
00001B4A                          1141                      ** SOURCE
00001B4A                          1142                      **
00001B4A                          1143                      ** ***************************************
00001B4A  0C39 0007 00002CB6      1144  Fn_MOVE_SrcMod      CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B52  6700 0006               1145                      BEQ     Fn_MOVE_ChkSrcReg           * Check source register
00001B56  6000 0088               1146                      BRA     Fn_MOVE_ChkDstMod           * Source not 7, now check destination Mod
00001B5A  0C39 0000 00002CB5      1147  Fn_MOVE_ChkSrcReg   CMP.B   #0, opSrcReg                * Check is source register is 0
00001B62  6700 0058               1148                      BEQ     Fn_MOVE_DtaSrcWrd           * Load next word
00001B66  0C39 0001 00002CB5      1149                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B6E  6700 005E               1150                      BEQ     Fn_MOVE_DtaSrcLng           * Load next long
00001B72  0C39 0004 00002CB5      1151                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B7A  6700 0006               1152                      BEQ     Fn_MOVE_DtaSrcImd           * Load first word into word one
00001B7E  6000 00B8               1153                      BRA     FN_MOVE_Error               * Invalid register value
00001B82                          1154  
00001B82                          1155                      ** Note: Checking immediate value
00001B82                          1156                      **       opID as size is specific to MOVE, MOVEA
00001B82                          1157                      **       other instructions will use 3 bits to set size, not part of ID
00001B82                          1158                      **
00001B82  0C39 0001 00002C4A      1159  Fn_MOVE_DtaSrcImd   CMP.B   #1, opID                    * opID = 0 - size is byte
00001B8A  6700 001E               1160                      BEQ     Fn_MOVE_DtaSrcByt           * Load next byte
00001B8E  0C39 0003 00002C4A      1161                      CMP.B   #3, opID                    * opID = 3 - size is word
00001B96  6700 0024               1162                      BEQ     Fn_MOVE_DtaSrcWrd           * Load next word
00001B9A  0C39 0002 00002C4A      1163                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BA2  6700 002A               1164                      BEQ     Fn_MOVE_DtaSrcLng           * Load next long
00001BA6  6000 0090               1165                      BRA     Fn_MOVE_Error               * Invalid opID (this should never happen)
00001BAA                          1166  
00001BAA  33DA 00002CB8           1167  Fn_MOVE_DtaSrcByt   MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BB0  13FC 0000 00002CBC      1168                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BB8  6000 0026               1169                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BBC  33DA 00002CB8           1170  Fn_MOVE_DtaSrcWrd   MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BC2  13FC 0001 00002CBC      1171                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BCA  6000 0014               1172                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BCE  23DA 00002CB8           1173  Fn_MOVE_DtaSrcLng   MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BD4  13FC 0002 00002CBC      1174                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BDC  6000 0002               1175                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BE0                          1176  
00001BE0                          1177                      ** DESTINATION
00001BE0                          1178                      **
00001BE0  0C39 0007 00002CB4      1179  Fn_MOVE_ChkDstMod   CMP.B   #7, opDstMod                * Check if destination mode is 7
00001BE8  6700 0006               1180                      BEQ     Fn_MOVE_ChkDstReg           * Check destination register
00001BEC  6000 0042               1181                      BRA     Fn_MOVE_Done                * Destination not 7, done with data
00001BF0  0C39 0000 00002CB3      1182  Fn_MOVE_ChkDstReg   CMP.B   #0, opDstReg                * Check if destination register is 0
00001BF8  6700 0012               1183                      BEQ     Fn_MOVE_DtaDstWrd           * Load next word
00001BFC  0C39 0001 00002CB3      1184                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C04  6700 0018               1185                      BEQ     Fn_MOVE_DtaDstLng           * Load next long
00001C08  6000 002E               1186                      BRA     fn_MOVE_Error               * Invalid registration Mode
00001C0C                          1187  
00001C0C  33DA 00002CBE           1188  Fn_MOVE_DtaDstWrd   MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C12  13FC 0001 00002CC2      1189                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C1A  6000 0014               1190                      BRA     Fn_MOVE_Done
00001C1E  23DA 00002CBE           1191  Fn_MOVE_DtaDstLng   MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C24  13FC 0002 00002CC2      1192                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C2C  6000 0002               1193                      BRA     Fn_MOVE_Done
00001C30                          1194  
00001C30  13FC 0000 00002C4B      1195  Fn_MOVE_Done        MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C38                          1196  
00001C38                          1197  Fn_MOVE_Error                                           * Exit out if error - main subroutine will handle DATA
00001C38                          1198                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C38  4E75                    1199                      RTS                                 * Return to main
00001C38  4E75                    1200  -------------------- end include --------------------
00001C3A                          1201                      INCLUDE 'SR_ID4.X68'
00001C3A                          1202  
00001C3A                          1203  SR_ID4              * This is to grab the first four that are already set, ID4
00001C3A  3639 00002C48           1204                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C40  183C 000C               1205                      MOVE.B  #12,D4
00001C44  E86B                    1206                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C46  13C3 00002C4A           1207                      MOVE.B  D3, opID        
00001C4C                          1208                      
00001C4C                          1209                      * Read next 3 bits into D3
00001C4C  3639 00002C48           1210                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C52  183C 0004               1211                      MOVE.B  #4, D4
00001C56  E96B                    1212                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C58  183C 000D               1213                      MOVE.B  #13,D4
00001C5C  E86B                    1214                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C5E  13C3 00002CB3           1215                      MOVE.B  D3, opDstReg
00001C64                          1216                      
00001C64                          1217                      * Read next 3 bits into D3
00001C64  3639 00002C48           1218                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C6A  183C 0007               1219                      MOVE.B  #7, D4
00001C6E  E96B                    1220                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C70  183C 000D               1221                      MOVE.B  #13,D4
00001C74  E86B                    1222                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C76  13C3 00002CB4           1223                      MOVE.B  D3, opDstMod
00001C7C                          1224  
00001C7C                          1225                      ** Read next 3 bits
00001C7C                          1226                      **
00001C7C  3639 00002C48           1227                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C82  183C 000A               1228                      MOVE.B  #10, D4
00001C86  E96B                    1229                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001C88  183C 000D               1230                      MOVE.B  #13,D4
00001C8C  E86B                    1231                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C8E  13C3 00002CB6           1232                      MOVE.B  D3, opSrcMod
00001C94                          1233  
00001C94                          1234                      ** Read next 3 bits
00001C94                          1235                      **
00001C94  3639 00002C48           1236                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C9A  183C 000D               1237                      MOVE.B  #13, D4
00001C9E  E96B                    1238                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CA0  183C 000D               1239                      MOVE.B  #13,D4
00001CA4  E86B                    1240                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CA6  13C3 00002CB5           1241                      MOVE.B  D3, opSrcReg
00001CAC                          1242                      
00001CAC                          1243                      ** ***************************************
00001CAC                          1244                      ** Verify instruction
00001CAC                          1245                      **
00001CAC                          1246                      ** JSR: If DstReg=7, DstMod=2 
00001CAC                          1247                      ** LEA: If DstReg=0-7, DstMod=7
00001CAC                          1248                      ** MOVEM:
00001CAC                          1249                      **    RegToMem: DestReg=4, DestMod=2,3
00001CAC                          1250                      **    MemToReg: DestReg=6, DestMod=2,3
00001CAC                          1251                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CAC                          1252                      ** NOT: If DstReg=3, DstMod=0-2
00001CAC                          1253                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CAC                          1254                      **
00001CAC                          1255                      ** ***************************************
00001CAC  0C39 0000 00002CB4      1256                      CMP.B   #0, opDstMod
00001CB4  6700 02EA               1257                      BEQ     Fn_ID4_NOT
00001CB8  0C39 0001 00002CB4      1258                      CMP.B   #1, opDstMod
00001CC0  6700 002A               1259                      BEQ     Fn_ID4_CheckD1
00001CC4  0C39 0002 00002CB4      1260                      CMP.B   #2, opDstMod
00001CCC  6700 0042               1261                      BEQ     Fn_ID4_CheckD2
00001CD0  0C39 0003 00002CB4      1262                      CMP.B   #3, opDstMod
00001CD8  6700 0066               1263                      BEQ     Fn_ID4_CheckD3
00001CDC  0C39 0007 00002CB4      1264                      CMP.B   #7, opDstMod
00001CE4  6700 011E               1265                      BEQ     Fn_ID4_LEA
00001CE8  6000 03D2               1266                      BRA     Fn_ID4_Error
00001CEC                          1267                      
00001CEC                          1268  Fn_ID4_CheckD1
00001CEC  0C39 0003 00002CB3      1269                      CMP.B   #3, opDstReg
00001CF4  6700 02AA               1270                      BEQ     Fn_ID4_NOT
00001CF8  0C39 0001 00002CB5      1271                      CMP.B   #1, opSrcReg
00001D00  6700 025E               1272                      BEQ     Fn_ID4_NOP
00001D04  0C39 0005 00002CB5      1273                      CMP.B   #5, opSrcReg
00001D0C  6700 02E8               1274                      BEQ     Fn_ID4_RTS
00001D10                          1275                      
00001D10                          1276  Fn_ID4_CheckD2
00001D10  0C39 0003 00002CB3      1277                      CMP.B   #3, opDstReg
00001D18  6700 0286               1278                      BEQ     Fn_ID4_NOT
00001D1C  0C39 0004 00002CB3      1279                      CMP.B   #4, opDstReg
00001D24  6700 014E               1280                      BEQ     Fn_ID4_MOVEMRTOM
00001D28  0C39 0006 00002CB3      1281                      CMP.B   #6, opDstReg
00001D30  6700 01B2               1282                      BEQ     Fn_ID4_MOVEMMTOR
00001D34  0C39 0007 00002CB3      1283                      CMP.B   #7, opDstReg
00001D3C  6700 001A               1284                      BEQ     Fn_ID4_JSR
00001D40                          1285  Fn_ID4_CheckD3
00001D40  0C39 0004 00002CB3      1286                      CMP.B   #4, opDstReg
00001D48  6700 012A               1287                      BEQ     Fn_ID4_MOVEMRTOM
00001D4C  0C39 0006 00002CB3      1288                      CMP.B   #6, opDstReg
00001D54  6700 018E               1289                      BEQ     Fn_ID4_MOVEMMTOR
00001D58                          1290  
00001D58  47F9 00002CF7           1291  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D5E  23CB 00002CAE           1292                      MOVE.L  A3, opPtrNam
00001D64                          1293                      
00001D64  0C39 0007 00002CB3      1294  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D6C  6600 034E               1295                      BNE     Fn_ID4_Error
00001D70  0C39 0002 00002CB4      1296                      CMP.B   #2, opDstMod
00001D78  6600 0342               1297                      BNE     Fn_ID4_Error
00001D7C                          1298                      
00001D7C                          1299                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D7C  0C39 0000 00002CB3      1300                      CMP.B   #0, opDstReg
00001D84  6700 0336               1301                      BEQ     Fn_ID4_Error
00001D88  0C39 0001 00002CB3      1302                      CMP.B   #1, opDstReg
00001D90  6700 032A               1303                      BEQ     Fn_ID4_Error
00001D94  0C39 0003 00002CB3      1304                      CMP.B   #3, opDstReg
00001D9C  6700 031E               1305                      BEQ     Fn_ID4_Error
00001DA0  0C39 0004 00002CB3      1306                      CMP.B   #4, opDstReg
00001DA8  6700 0312               1307                      BEQ     Fn_ID4_Error
00001DAC                          1308                      
00001DAC                          1309                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DAC  0C39 0000 00002CB6      1310                      CMP.B   #0, opSrcMod
00001DB4  6700 0306               1311                      BEQ     Fn_ID4_Error
00001DB8  0C39 0001 00002CB6      1312                      CMP.B   #1, opSrcMod
00001DC0  6700 02FA               1313                      BEQ     Fn_ID4_Error
00001DC4  0C39 0003 00002CB6      1314                      CMP.B   #3, opSrcMod
00001DCC  6700 02EE               1315                      BEQ     Fn_ID4_Error
00001DD0  0C39 0004 00002CB6      1316                      CMP.B   #4, opSrcMod
00001DD8  6700 02E2               1317                      BEQ     Fn_ID4_Error
00001DDC                          1318                      
00001DDC                          1319                      * Make sure src reg is between 0-7
00001DDC  0C39 0000 00002CB5      1320                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001DE4  6D00 02D6               1321                      BLT     Fn_ID4_Error
00001DE8  0C39 0007 00002CB5      1322                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001DF0  6E00 02CA               1323                      BGT     Fn_ID4_Error
00001DF4                          1324                      
00001DF4  0C39 0007 00002CB6      1325  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001DFC  6700 0238               1326                      BEQ     Fn_ID4_Data
00001E00  6000 02BC               1327                      BRA     Fn_ID4_Done
00001E04                          1328  
00001E04  47F9 00002CE1           1329  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E0A  23CB 00002CAE           1330                      MOVE.L  A3, opPtrNam
00001E10                          1331                      
00001E10  0C39 0007 00002CB4      1332  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E18  6600 02A2               1333                      BNE     Fn_ID4_Error
00001E1C                          1334                      
00001E1C                          1335                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E1C  0C39 0000 00002CB6      1336                      CMP.B   #0, opSrcMod
00001E24  6700 0296               1337                      BEQ     Fn_ID4_Error
00001E28  0C39 0001 00002CB6      1338                      CMP.B   #1, opSrcMod
00001E30  6700 028A               1339                      BEQ     Fn_ID4_Error
00001E34  0C39 0003 00002CB6      1340                      CMP.B   #3, opSrcMod
00001E3C  6700 027E               1341                      BEQ     Fn_ID4_Error
00001E40  0C39 0004 00002CB6      1342                      CMP.B   #4, opSrcMod
00001E48  6700 0272               1343                      BEQ     Fn_ID4_Error
00001E4C                          1344                      
00001E4C                          1345                      * Make sure src reg is between 0-7
00001E4C  0C39 0000 00002CB5      1346                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E54  6D00 0266               1347                      BLT     Fn_ID4_Error
00001E58  0C39 0007 00002CB5      1348                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E60  6E00 025A               1349                      BGT     Fn_ID4_Error
00001E64                          1350                      
00001E64  0C39 0007 00002CB6      1351  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E6C  6700 01C8               1352                      BEQ     Fn_ID4_Data
00001E70  6000 024C               1353                      BRA     Fn_ID4_Done
00001E74                          1354  
00001E74  47F9 00002CE9           1355  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E7A  23CB 00002CAE           1356                      MOVE.L  A3, opPtrNam
00001E80                          1357                      
00001E80  0C39 0004 00002CB3      1358  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001E88  6600 0232               1359                      BNE     Fn_ID4_Error
00001E8C                          1360                      
00001E8C                          1361                      * Make sure dest mode is only 2 or 3
00001E8C  0C39 0003 00002CB5      1362                      CMP.B   #3, opSrcReg                * Destination register > 2
00001E94  6D00 0226               1363                      BLT     Fn_ID4_Error
00001E98  0C39 0003 00002CB5      1364                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EA0  6E00 021A               1365                      BGT     Fn_ID4_Error
00001EA4                          1366                      
00001EA4                          1367                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EA4  0C39 0000 00002CB6      1368                      CMP.B   #0, opSrcMod
00001EAC  6700 020E               1369                      BEQ     Fn_ID4_Error
00001EB0  0C39 0001 00002CB6      1370                      CMP.B   #1, opSrcMod
00001EB8  6700 0202               1371                      BEQ     Fn_ID4_Error
00001EBC  0C39 0003 00002CB6      1372                      CMP.B   #3, opSrcMod
00001EC4  6700 01F6               1373                      BEQ     Fn_ID4_Error
00001EC8                          1374                      
00001EC8                          1375                      * Make sure src reg is between 0-7
00001EC8  0C39 0000 00002CB5      1376                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001ED0  6D00 01EA               1377                      BLT     Fn_ID4_Error
00001ED4  0C39 0007 00002CB5      1378                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EDC  6E00 01DE               1379                      BGT     Fn_ID4_Error
00001EE0  6000 006E               1380                      BRA Fn_ID4_MOVEM_Src
00001EE4                          1381  
00001EE4  47F9 00002CE9           1382  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001EEA  23CB 00002CAE           1383                      MOVE.L  A3, opPtrNam
00001EF0                          1384                      
00001EF0  0C39 0006 00002CB3      1385  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001EF8  6600 01C2               1386                      BNE     Fn_ID4_Error
00001EFC                          1387                      
00001EFC                          1388                      * Make sure dest mode is only 2 or 3
00001EFC  0C39 0003 00002CB5      1389                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F04  6D00 01B6               1390                      BLT     Fn_ID4_Error
00001F08  0C39 0003 00002CB5      1391                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F10  6E00 01AA               1392                      BGT     Fn_ID4_Error
00001F14                          1393                      
00001F14                          1394                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F14  0C39 0000 00002CB6      1395                      CMP.B   #0, opSrcMod
00001F1C  6700 019E               1396                      BEQ     Fn_ID4_Error
00001F20  0C39 0001 00002CB6      1397                      CMP.B   #1, opSrcMod
00001F28  6700 0192               1398                      BEQ     Fn_ID4_Error
00001F2C  0C39 0003 00002CB6      1399                      CMP.B   #3, opSrcMod
00001F34  6700 0186               1400                      BEQ     Fn_ID4_Error
00001F38                          1401                      
00001F38                          1402                      * Make sure src reg is between 0-7
00001F38  0C39 0000 00002CB5      1403                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F40  6D00 017A               1404                      BLT     Fn_ID4_Error
00001F44  0C39 0007 00002CB5      1405                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F4C  6E00 016E               1406                      BGT     Fn_ID4_Error
00001F50                          1407                      
00001F50  0C39 0007 00002CB6      1408  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F58  6700 00DC               1409                      BEQ     Fn_ID4_Data
00001F5C  6000 0160               1410                      BRA     Fn_ID4_Done
00001F60                          1411  
00001F60  47F9 00002CEF           1412  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F66  23CB 00002CAE           1413                      MOVE.L  A3, opPtrNam
00001F6C                          1414  
00001F6C  0C39 0007 00002CB3      1415  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F74  6600 0146               1416                      BNE     Fn_ID4_Error
00001F78  0C39 0001 00002CB4      1417                      CMP.B   #1, opDstMod
00001F80  6600 013A               1418                      BNE     Fn_ID4_Error
00001F84  0C39 0006 00002CB6      1419                      CMP.B   #6, opSrcMod
00001F8C  6600 012E               1420                      BNE     Fn_ID4_Error
00001F90  0C39 0001 00002CB5      1421                      CMP.B   #1, opSrcReg
00001F98  6600 0122               1422                      BNE     Fn_ID4_Error
00001F9C  6000 0120               1423                      BRA     Fn_ID4_Done
00001FA0                          1424  
00001FA0                          1425  
00001FA0  47F9 00002CE5           1426  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FA6  23CB 00002CAE           1427                      MOVE.L  A3, opPtrNam
00001FAC                          1428                      
00001FAC  0C39 0003 00002CB3      1429  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FB4  6600 0106               1430                      BNE     Fn_ID4_Error
00001FB8                          1431                      
00001FB8                          1432                      * Make sure src mode is not 1
00001FB8  0C39 0001 00002CB6      1433                      CMP.B   #1, opSrcMod
00001FC0  6700 00FA               1434                      BEQ     Fn_ID4_Error
00001FC4                          1435                      
00001FC4                          1436                      * Make sure src reg is between 0-7
00001FC4  0C39 0000 00002CB5      1437                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FCC  6D00 00EE               1438                      BLT     Fn_ID4_Error
00001FD0  0C39 0007 00002CB5      1439                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FD8  6E00 00E2               1440                      BGT     Fn_ID4_Error
00001FDC                          1441                      
00001FDC  33F9 00002CB4 00002C4A  1442  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00001FE6  0C39 0007 00002CB6      1443                      CMP.B   #7, opSrcMod
00001FEE  6700 0046               1444                      BEQ     Fn_ID4_Data
00001FF2  6000 00CA               1445                      BRA     Fn_ID4_Done
00001FF6                          1446  
00001FF6  47F9 00002CF3           1447  Fn_ID4_RTS          LEA    opNam_RTS,A3
00001FFC  23CB 00002CAE           1448                      MOVE.L A3, opPtrNam
00002002                          1449                      
00002002  0C39 0007 00002CB3      1450  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000200A  6600 00B0               1451                      BNE     Fn_ID4_Error
0000200E  0C39 0001 00002CB4      1452                      CMP.B   #1, opDstMod
00002016  6600 00A4               1453                      BNE     Fn_ID4_Error
0000201A  0C39 0006 00002CB6      1454                      CMP.B   #6, opSrcMod
00002022  6600 0098               1455                      BNE     Fn_ID4_Error
00002026  0C39 0005 00002CB5      1456                      CMP.B   #5, opSrcReg
0000202E  6600 008C               1457                      BNE     Fn_ID4_Error
00002032  6000 008A               1458                      BRA     Fn_ID4_Done
00002036                          1459  
00002036  0C39 0000 00002CB5      1460  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
0000203E  6700 0058               1461                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002042  0C39 0001 00002CB5      1462                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000204A  6700 005E               1463                      BEQ     Fn_ID4_DtaLng               * Load next long
0000204E  0C39 0004 00002CB5      1464                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002056  6700 0006               1465                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000205A  6000 0060               1466                      BRA     FN_ID4_Error                * Invalid register value
0000205E                          1467                      
0000205E  0C39 0001 00002C4A      1468  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002066  6700 001E               1469                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000206A  0C39 0003 00002C4A      1470                      CMP.B   #3, opID                    * opID = 3 - size is word
00002072  6700 0024               1471                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002076  0C39 0002 00002C4A      1472                      CMP.B   #2, opID                    * opID = 0 - size is long
0000207E  6700 002A               1473                      BEQ     Fn_ID4_DtaLng               * Load next
00002082  6000 0038               1474                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
00002086                          1475  
00002086  33DA 00002CBE           1476  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000208C  13FC 0000 00002CC2      1477                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002094  6000 0028               1478                      BRA     Fn_ID4_Done
00002098  33DA 00002CBE           1479  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
0000209E  13FC 0001 00002CC2      1480                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020A6  6000 0016               1481                      BRA     Fn_ID4_Done
000020AA  23DA 00002CBE           1482  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020B0  13FC 0002 00002CC2      1483                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020B8  6000 0004               1484                      BRA     Fn_ID4_Done
000020BC                          1485  
000020BC                          1486  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
000020BC                          1487                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000020BC  4E75                    1488                      RTS                                  * Return to main
000020BE                          1489  
000020BE  4E75                    1490  Fn_ID4_Done         RTS
000020C0                          1491  
000020C0                          1492  
000020C0                          1493  
000020C0                          1494  -------------------- end include --------------------
000020C0                          1495                      INCLUDE 'SR_ID5.X68'
000020C0                          1496  
000020C0                          1497  
000020C0                          1498  SR_ID5              * This is to grab the first four that are already set, ID5
000020C0  3639 00002C48           1499                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020C6  183C 000C               1500                      MOVE.B  #12,D4
000020CA  E86B                    1501                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000020CC  13C3 00002C4A           1502                      MOVE.B  D3, opID        
000020D2                          1503                      
000020D2                          1504                      * Read next 3 bits into D3
000020D2  3639 00002C48           1505                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020D8  183C 0004               1506                      MOVE.B  #4, D4
000020DC  E96B                    1507                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000020DE  183C 000D               1508                      MOVE.B  #13,D4
000020E2  E86B                    1509                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000020E4  13C3 00002CB6           1510                      MOVE.B  D3, opSrcMod
000020EA                          1511                      
000020EA                          1512                      * Read next 3 bits into D3
000020EA  3639 00002C48           1513                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020F0  183C 0007               1514                      MOVE.B  #7, D4
000020F4  E96B                    1515                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000020F6  183C 000D               1516                      MOVE.B  #13,D4
000020FA  E86B                    1517                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000020FC  13C3 00002C4A           1518                      MOVE.B  D3, opID
00002102                          1519  
00002102                          1520                      ** Read next 3 bits
00002102                          1521                      **
00002102  3639 00002C48           1522                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002108  183C 000A               1523                      MOVE.B  #10, D4
0000210C  E96B                    1524                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000210E  183C 000D               1525                      MOVE.B  #13,D4
00002112  E86B                    1526                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002114  13C3 00002CB4           1527                      MOVE.B  D3, opDstMod
0000211A                          1528  
0000211A                          1529                      ** Read next 3 bits
0000211A                          1530                      **
0000211A  3639 00002C48           1531                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002120  183C 000D               1532                      MOVE.B  #13, D4
00002124  E96B                    1533                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002126  183C 000D               1534                      MOVE.B  #13,D4
0000212A  E86B                    1535                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000212C  13C3 00002CB3           1536                      MOVE.B  D3, opDstReg
00002132                          1537              
00002132                          1538              ** Set name
00002132  47F9 00002CFB           1539              LEA     opNam_ADDQ,A3
00002138                          1540              
00002138                          1541  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
00002138  0C39 0000 00002CB6      1542                      CMP.B   #0, opSrcMod                * Destination register >= 0
00002140  6D00 00E4               1543                      BLT     Fn_ID5_Error
00002144  0C39 0007 00002CB3      1544                      CMP.B   #7, opDstReg                * Destination register <= 7
0000214C  6E00 00D8               1545                      BGT     Fn_ID5_Error
00002150                          1546              
00002150                          1547              * Make sure opId  is between 0-2
00002150  0C39 0000 00002C4A      1548                      CMP.B   #0, opID                    * Destination register >= 0
00002158  6D00 00CC               1549                      BLT     Fn_ID5_Error
0000215C  0C39 0002 00002C4A      1550                      CMP.B   #2, opID                    * Destination register <= 2
00002164  6E00 00C0               1551                      BGT     Fn_ID5_Error
00002168                          1552              
00002168                          1553              * Move data to  appropriate places for printing
00002168  13FC 0007 00002CB6      1554              MOVE.B  #7,opSrcMod
00002170  13FC 0004 00002CB5      1555              MOVE.B  #4,opSrcReg
00002178                          1556  
00002178                          1557                      ** Note: Checking immediate value
00002178                          1558                      **       opID as size is specific to MOVE, MOVEA
00002178                          1559                      **       other instructions will use 3 bits to set size, not part of ID
00002178                          1560                      **
00002178  0C39 0001 00002C4A      1561  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002180  6700 001E               1562                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
00002184  0C39 0003 00002C4A      1563                      CMP.B   #3, opID                    * opID = 3 - size is word
0000218C  6700 0024               1564                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
00002190  0C39 0002 00002C4A      1565                      CMP.B   #2, opID                    * opID = 0 - size is long
00002198  6700 002A               1566                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
0000219C  6000 0088               1567                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
000021A0                          1568  
000021A0  33DA 00002CB8           1569  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000021A6  13FC 0000 00002CBC      1570                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000021AE  6000 0026               1571                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021B2  33DA 00002CB8           1572  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000021B8  13FC 0001 00002CBC      1573                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000021C0  6000 0014               1574                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021C4  23DA 00002CB8           1575  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000021CA  13FC 0002 00002CBC      1576                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
000021D2  6000 0002               1577                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021D6                          1578              
000021D6  0C39 0007 00002CB4      1579  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
000021DE  6700 0006               1580                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
000021E2  6000 0044               1581                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
000021E6  0C39 0000 00002CB3      1582  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
000021EE  6700 0012               1583                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
000021F2  0C39 0001 00002CB3      1584                      CMP.B   #1, opDstReg                * Check if destination register is 1
000021FA  6700 0018               1585                      BEQ     Fn_ID5_DtaDstLng            * Load next long
000021FE  6000 0026               1586                      BRA     Fn_ID5_Error                * Invalid registration Mode
00002202                          1587  
00002202  33DA 00002CBE           1588  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002208  13FC 0001 00002CC2      1589                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00002210  6000 0016               1590                      BRA     Fn_ID5_Done
00002214  23DA 00002CBE           1591  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
0000221A  13FC 0002 00002CC2      1592                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00002222  6000 0004               1593                      BRA     Fn_ID5_Done
00002226                          1594  
00002226                          1595  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
00002226                          1596                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002226  4E75                    1597                      RTS   
00002228                          1598              
00002228  4E75                    1599  Fn_ID5_Done        RTS
00002228  4E75                    1600  -------------------- end include --------------------
0000222A                          1601                      INCLUDE 'SR_ID6.X68'
0000222A                          1602  
0000222A                          1603  
0000222A                          1604  SR_ID6              * This is to grab the first four that are already set, ID6
0000222A  3639 00002C48           1605                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002230  183C 000C               1606                      MOVE.B  #12,D4
00002234  E86B                    1607                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002236  13C3 00002C4A           1608                      MOVE.B  D3, opID        
0000223C                          1609                      
0000223C                          1610                      * Read next 4 bits into D3
0000223C  3639 00002C48           1611                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002242  183C 0004               1612                      MOVE.B  #4, D4
00002246  E96B                    1613                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002248  183C 000C               1614                      MOVE.B  #12,D4
0000224C  E86B                    1615                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
0000224E  13C3 00002C4A           1616                      MOVE.B  D3, opID
00002254                          1617                      
00002254                          1618                      * Read next 8 bits into D3
00002254  3639 00002C48           1619                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000225A  183C 0007               1620                      MOVE.B  #7, D4
0000225E  E96B                    1621                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
00002260  183C 0008               1622                      MOVE.B  #8,D4
00002264  E86B                    1623                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002266  13C3 00002CB4           1624                      MOVE.B  D3, opDstMod
0000226C                          1625              
0000226C                          1626              ** Condition is stored in opID - displacement is in DstMod
0000226C                          1627              ** All thats leftis to branch per condition and output name, check reg if needed more
0000226C                          1628              ** BRA - opID=0
0000226C                          1629              ** BEQ - opID=7
0000226C                          1630              ** BGT - opID=14
0000226C                          1631              ** BLE - opID=15
0000226C  0C39 0000 00002C4A      1632              CMP.B   #0,opID
00002274  6700 002A               1633              BEQ     Fn_ID6_BRA
00002278  0C39 0007 00002C4A      1634              CMP.B   #7,opID
00002280  6700 0028               1635              BEQ     Fn_ID6_BEQ
00002284  0C39 000E 00002C4A      1636              CMP.B   #14,opID
0000228C  6700 0026               1637              BEQ     Fn_ID6_BGT
00002290  0C39 000F 00002C4A      1638              CMP.B   #15,opID
00002298  6700 0024               1639              BEQ     Fn_ID6_BLE
0000229C  6000 0078               1640              BRA     Fn_ID6_ERROR
000022A0                          1641  
000022A0  47F9 00002D00           1642  Fn_ID6_BRA  LEA     opNam_BRA,A3
000022A6  6000 001C               1643              BRA     Fn_ID6_Displacement
000022AA                          1644              
000022AA  47F9 00002D04           1645  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
000022B0  6000 0012               1646              BRA     Fn_ID6_Displacement
000022B4                          1647              
000022B4  47F9 00002D08           1648  Fn_ID6_BGT  LEA     opNam_BGT,A3
000022BA  6000 0008               1649              BRA     Fn_ID6_Displacement
000022BE                          1650              
000022BE  47F9 00002D0C           1651  Fn_ID6_BLE  LEA     opNam_BLE,A3
000022C4                          1652              
000022C4  0C39 0000 00002CB4      1653  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
000022CC  6700 0024               1654              BEQ     Fn_ID6_Dsplcmnt16
000022D0  0C39 00FF 00002CB4      1655              CMP.B   #$FF,opDstMod
000022D8  6700 002A               1656              BEQ     Fn_ID6_Dsplcmnt32
000022DC                          1657              ** 8 bit is good
000022DC  33F9 00002CB4 00002CBE  1658              MOVE.W  opDstMod,opDta2
000022E6  13FC 0000 00002CC2      1659              MOVE.B  #0,opDta2T
000022EE  6000 0028               1660              BRA     Fn_ID6_Done
000022F2                          1661              
000022F2  33DA 00002CBE           1662  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
000022F8  13FC 0001 00002CC2      1663              MOVE.B  #1,opDta2T
00002300  6000 0016               1664              BRA     Fn_ID6_Done
00002304                          1665  
00002304  23DA 00002CBE           1666  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
0000230A  13FC 0002 00002CC2      1667              MOVE.B  #2,opDta2T
00002312  6000 0004               1668              BRA     Fn_ID6_Done 
00002316                          1669  
00002316                          1670  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
00002316                          1671                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002316  4E75                    1672                      RTS 
00002318                          1673  
00002318  4E75                    1674  Fn_ID6_Done        RTS
00002318  4E75                    1675  -------------------- end include --------------------
0000231A                          1676                      INCLUDE 'SR_ID7.X68'
0000231A                          1677  
0000231A                          1678  
0000231A                          1679  SR_ID7              * This is to grab the first four that are already set, ID7
0000231A  3639 00002C48           1680                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002320  183C 000C               1681                      MOVE.B  #12,D4
00002324  E86B                    1682                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002326  13C3 00002C4A           1683                      MOVE.B  D3, opID        
0000232C                          1684                      
0000232C                          1685                      * Read next 3 bits into D3
0000232C  3639 00002C48           1686                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002332  183C 0004               1687                      MOVE.B  #4, D4
00002336  E96B                    1688                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002338  183C 000D               1689                      MOVE.B  #13,D4
0000233C  E86B                    1690                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000233E  13C3 00002CB8           1691                      MOVE.B  D3, opDta1      
00002344                          1692              
00002344                          1693              * Read next 1 bits into D3
00002344  3639 00002C48           1694                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000234A  183C 0007               1695                      MOVE.B  #7, D4
0000234E  E96B                    1696                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002350  183C 000F               1697                      MOVE.B  #15,D4
00002354  E86B                    1698                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002356  13C3 00002CB4           1699                      MOVE.B  D3, opDstMod    
0000235C  0C39 0000 00002CB4      1700              CMP.B   #0,opDstMod
00002364  6600 0038               1701              BNE     Fn_ID7_Error
00002368                          1702              
00002368                          1703              * Read next 8 bits into D3
00002368  3639 00002C48           1704                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000236E  183C 0008               1705                      MOVE.B  #8, D4
00002372  E96B                    1706                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002374  183C 0008               1707                      MOVE.B  #8,D4
00002378  E86B                    1708                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
0000237A  13C3 00002CBE           1709                      MOVE.B  D3, opDta2
00002380                          1710  
00002380  47F9 00002D10           1711              LEA     opNam_MOVEQ,A3
00002386                          1712              * Set appropriate data
00002386  13FC 0001 00002CC2      1713              MOVE.B  #1, opDta2T
0000238E  13FC 0007 00002CB6      1714              MOVE.B  #7, opSrcMod
00002396  13FC 0000 00002CB5      1715              MOVE.B  #0, opSrcReg
0000239E                          1716  
0000239E                          1717  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
0000239E                          1718                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000239E  4E75                    1719                      RTS                                  * Return to main
000023A0                          1720              
000023A0  4E75                    1721  Fn_ID7_Done        RTS
000023A0  4E75                    1722  -------------------- end include --------------------
000023A2                          1723                      INCLUDE 'SR_ID8.X68'
000023A2                          1724  
000023A2                          1725  
000023A2                          1726  SR_ID8              * This is to grab the first four that are already set, ID4
000023A2  3639 00002C48           1727                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023A8  183C 000C               1728                      MOVE.B  #12,D4
000023AC  E86B                    1729                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000023AE  13C3 00002C4A           1730                      MOVE.B  D3, opID        
000023B4                          1731                      
000023B4                          1732                      * Read next 3 bits into D3
000023B4  3639 00002C48           1733                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023BA  183C 0004               1734                      MOVE.B  #4, D4
000023BE  E96B                    1735                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000023C0  183C 000D               1736                      MOVE.B  #13,D4
000023C4  E86B                    1737                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023C6  13C3 00002CB3           1738                      MOVE.B  D3, opDstReg
000023CC                          1739                      
000023CC                          1740                      * Read next 3 bits into D3
000023CC  3639 00002C48           1741                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023D2  183C 0007               1742                      MOVE.B  #7, D4
000023D6  E96B                    1743                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000023D8  183C 000D               1744                      MOVE.B  #13,D4
000023DC  E86B                    1745                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023DE  13C3 00002CB4           1746                      MOVE.B  D3, opDstMod
000023E4                          1747  
000023E4                          1748                      ** Read next 3 bits
000023E4                          1749                      **
000023E4  3639 00002C48           1750                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023EA  183C 000A               1751                      MOVE.B  #10, D4
000023EE  E96B                    1752                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000023F0  183C 000D               1753                      MOVE.B  #13,D4
000023F4  E86B                    1754                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023F6  13C3 00002CB6           1755                      MOVE.B  D3, opSrcMod
000023FC                          1756  
000023FC                          1757                      ** Read next 3 bits
000023FC                          1758                      **
000023FC  3639 00002C48           1759                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002402  183C 000D               1760                      MOVE.B  #13, D4
00002406  E96B                    1761                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002408  183C 000D               1762                      MOVE.B  #13,D4
0000240C  E86B                    1763                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000240E  13C3 00002CB5           1764                      MOVE.B  D3, opSrcReg
00002414                          1765              
00002414                          1766              ** Find out if its Dn, ea or ea, Dn
00002414                          1767              ** ea, Dn - 0,1,2
00002414                          1768              ** Dn, ea - 4,5,6
00002414  47F9 00002D16           1769              LEA     opNam_OR,A3
0000241A  0C39 0003 00002CB4      1770              CMP.B   #3,opDstMod
00002422  6D00 0012               1771              BLT     Fn_ID8_Case1
00002426  0C39 0007 00002CB4      1772              CMP.B   #7,opDstMod
0000242E  6D00 0048               1773              BLT     Fn_ID8_Case2
00002432  6000 0178               1774              BRA     Fn_ID8_Error
00002436                          1775  
00002436  13F9 00002CB4 00002C4A  1776  Fn_ID8_Case1MOVE.B  opDstMod,opID
00002440  13F9 00002CB6 00002CB4  1777              MOVE.B  opSrcMod,opDstMod
0000244A  1C39 00002CB3           1778              MOVE.B  opDstReg,D6
00002450  13F9 00002CB5 00002CB3  1779              MOVE.B  opSrcReg,opDstReg
0000245A  13C6 00002CB5           1780              MOVE.B  D6,opSrcReg
00002460  13FC 0000 00002CB6      1781              MOVE.B  #0,opSrcMod
00002468                          1782              ** Immediate data?
00002468  0C39 0007 00002CB4      1783              CMP.B   #7, opDstMod
00002470  6700 002E               1784                      BEQ     Fn_ID8_DataDst
00002474  6000 0138               1785                      BRA     Fn_ID8_Done
00002478                          1786  
00002478  13F9 00002CB4 00002C4A  1787  Fn_ID8_Case2MOVE.B  opDstMod,opID
00002482  5939 00002C4A           1788              SUB.B   #4,opID
00002488  13FC 0000 00002CB4      1789              MOVE.B  #0,opDstMod
00002490                          1790              ** Immediate data?
00002490  0C39 0007 00002CB6      1791              CMP.B   #7, opSrcMod
00002498  6700 008C               1792                      BEQ     Fn_ID8_DataSrc
0000249C  6000 0110               1793                      BRA     Fn_ID8_Done
000024A0                          1794              
000024A0  0C39 0000 00002CB3      1795  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000024A8  6700 0058               1796                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024AC  0C39 0001 00002CB3      1797                      CMP.B   #1, opDstReg                * Check if source register is 1
000024B4  6700 005E               1798                      BEQ     Fn_ID8_DtaDstLng            * Load next long
000024B8  0C39 0004 00002CB3      1799                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000024C0  6700 0006               1800                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
000024C4  6000 00E6               1801                      BRA     FN_ID8_Error                * Invalid register value
000024C8                          1802                      
000024C8  0C39 0001 00002C4A      1803  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000024D0  6700 001E               1804                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
000024D4  0C39 0003 00002C4A      1805                      CMP.B   #3, opID                    * opID = 3 - size is word
000024DC  6700 0024               1806                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024E0  0C39 0002 00002C4A      1807                      CMP.B   #2, opID                    * opID = 0 - size is long
000024E8  6700 002A               1808                      BEQ     Fn_ID8_DtaDstLng            * Load next
000024EC  6000 00BE               1809                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000024F0                          1810  
000024F0  33DA 00002CB8           1811  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000024F6  13FC 0000 00002CBC      1812                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000024FE  6000 00AE               1813                      BRA     Fn_ID8_Done
00002502  33DA 00002CB8           1814  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002508  13FC 0001 00002CBC      1815                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002510  6000 009C               1816                      BRA     Fn_ID8_Done
00002514  23DA 00002CB8           1817  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
0000251A  13FC 0002 00002CBC      1818                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002522  6000 008A               1819                      BRA     Fn_ID8_Done
00002526                          1820              
00002526  0C39 0000 00002CB5      1821  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
0000252E  6700 0058               1822                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002532  0C39 0001 00002CB5      1823                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000253A  6700 005E               1824                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
0000253E  0C39 0004 00002CB5      1825                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002546  6700 0006               1826                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
0000254A  6000 0060               1827                      BRA     FN_ID8_Error                * Invalid register value
0000254E                          1828                      
0000254E  0C39 0001 00002C4A      1829  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002556  6700 001E               1830                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
0000255A  0C39 0003 00002C4A      1831                      CMP.B   #3, opID                    * opID = 3 - size is word
00002562  6700 0024               1832                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002566  0C39 0002 00002C4A      1833                      CMP.B   #2, opID                    * opID = 0 - size is long
0000256E  6700 002A               1834                      BEQ     Fn_ID8_DtaSrcLng            * Load next
00002572  6000 0038               1835                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
00002576                          1836  
00002576  33DA 00002CBE           1837  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000257C  13FC 0000 00002CC2      1838                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002584  6000 0028               1839                      BRA     Fn_ID8_Done
00002588  33DA 00002CBE           1840  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
0000258E  13FC 0001 00002CC2      1841                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002596  6000 0016               1842                      BRA     Fn_ID8_Done
0000259A  23DA 00002CBE           1843  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000025A0  13FC 0002 00002CC2      1844                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000025A8  6000 0004               1845                      BRA     Fn_ID8_Done
000025AC                          1846  
000025AC                          1847  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
000025AC                          1848                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025AC  4E75                    1849                      RTS   
000025AE                          1850              
000025AE  4E75                    1851  Fn_ID8_Done        RTS
000025AE  4E75                    1852  -------------------- end include --------------------
000025B0                          1853                      INCLUDE 'SR_ID9.X68'
000025B0                          1854  
000025B0                          1855  
000025B0                          1856  SR_ID9      * This is to grab the first four that are already set, ID4
000025B0  3639 00002C48           1857                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025B6  183C 000C               1858                      MOVE.B  #12,D4
000025BA  E86B                    1859                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000025BC  13C3 00002C4A           1860                      MOVE.B  D3, opID        
000025C2                          1861                      
000025C2                          1862                      * Read next 3 bits into D3
000025C2  3639 00002C48           1863                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025C8  183C 0004               1864                      MOVE.B  #4, D4
000025CC  E96B                    1865                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000025CE  183C 000D               1866                      MOVE.B  #13,D4
000025D2  E86B                    1867                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000025D4  13C3 00002CB3           1868                      MOVE.B  D3, opDstReg
000025DA                          1869                      
000025DA                          1870                      * Read next 3 bits into D3
000025DA  3639 00002C48           1871                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025E0  183C 0007               1872                      MOVE.B  #7, D4
000025E4  E96B                    1873                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000025E6  183C 000D               1874                      MOVE.B  #13,D4
000025EA  E86B                    1875                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000025EC  13C3 00002CB4           1876                      MOVE.B  D3, opDstMod
000025F2                          1877  
000025F2                          1878                      ** Read next 3 bits
000025F2                          1879                      **
000025F2  3639 00002C48           1880                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025F8  183C 000A               1881                      MOVE.B  #10, D4
000025FC  E96B                    1882                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000025FE  183C 000D               1883                      MOVE.B  #13,D4
00002602  E86B                    1884                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002604  13C3 00002CB6           1885                      MOVE.B  D3, opSrcMod
0000260A                          1886  
0000260A                          1887                      ** Read next 3 bits
0000260A                          1888                      **
0000260A  3639 00002C48           1889                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002610  183C 000D               1890                      MOVE.B  #13, D4
00002614  E96B                    1891                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002616  183C 000D               1892                      MOVE.B  #13,D4
0000261A  E86B                    1893                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000261C  13C3 00002CB5           1894                      MOVE.B  D3, opSrcReg
00002622                          1895              
00002622                          1896              ** Find out if its Dn, ea or ea, Dn
00002622                          1897              ** ea, Dn - 0,1,2
00002622                          1898              ** Dn, ea - 4,5,6
00002622  47F9 00002D19           1899              LEA     opNam_SUB,A3
00002628  0C39 0003 00002CB4      1900              CMP.B   #3,opDstMod
00002630  6D00 0012               1901              BLT     Fn_ID9_Case1
00002634  0C39 0007 00002CB4      1902              CMP.B   #7,opDstMod
0000263C  6D00 0048               1903              BLT     Fn_ID9_Case2
00002640  6000 0178               1904              BRA     Fn_ID9_Error
00002644                          1905  
00002644  13F9 00002CB4 00002C4A  1906  Fn_ID9_Case1MOVE.B  opDstMod,opID
0000264E  13F9 00002CB6 00002CB4  1907              MOVE.B  opSrcMod,opDstMod
00002658  1C39 00002CB3           1908              MOVE.B  opDstReg,D6
0000265E  13F9 00002CB5 00002CB3  1909              MOVE.B  opSrcReg,opDstReg
00002668  13C6 00002CB5           1910              MOVE.B  D6,opSrcReg
0000266E  13FC 0000 00002CB6      1911              MOVE.B  #0,opSrcMod
00002676                          1912              ** Immediate data?
00002676  0C39 0007 00002CB4      1913              CMP.B   #7, opDstMod
0000267E  6700 002E               1914                      BEQ     Fn_ID9_DataDst
00002682  6000 0138               1915                      BRA     Fn_ID9_Done
00002686                          1916  
00002686  13F9 00002CB4 00002C4A  1917  Fn_ID9_Case2MOVE.B  opDstMod,opID
00002690  5939 00002C4A           1918              SUB.B   #4,opID
00002696  13FC 0000 00002CB4      1919              MOVE.B  #0,opDstMod
0000269E                          1920              ** Immediate data?
0000269E  0C39 0007 00002CB6      1921              CMP.B   #7, opSrcMod
000026A6  6700 008C               1922                      BEQ     Fn_ID9_DataSrc
000026AA  6000 0110               1923                      BRA     Fn_ID9_Done
000026AE                          1924              
000026AE  0C39 0000 00002CB3      1925  Fn_ID9_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000026B6  6700 0058               1926                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000026BA  0C39 0001 00002CB3      1927                      CMP.B   #1, opDstReg                * Check if source register is 1
000026C2  6700 005E               1928                      BEQ     Fn_ID9_DtaDstLng            * Load next long
000026C6  0C39 0004 00002CB3      1929                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000026CE  6700 0006               1930                      BEQ     Fn_ID9_DtaDstImd            * Load first word into word one
000026D2  6000 00E6               1931                      BRA     FN_ID9_Error                * Invalid register value
000026D6                          1932                      
000026D6  0C39 0001 00002C4A      1933  Fn_ID9_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000026DE  6700 001E               1934                      BEQ     Fn_ID9_DtaDstByt            * Load next byte
000026E2  0C39 0003 00002C4A      1935                      CMP.B   #3, opID                    * opID = 3 - size is word
000026EA  6700 0024               1936                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000026EE  0C39 0002 00002C4A      1937                      CMP.B   #2, opID                    * opID = 0 - size is long
000026F6  6700 002A               1938                      BEQ     Fn_ID9_DtaDstLng            * Load next
000026FA  6000 00BE               1939                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
000026FE                          1940  
000026FE  33DA 00002CB8           1941  Fn_ID9_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002704  13FC 0000 00002CBC      1942                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
0000270C  6000 00AE               1943                      BRA     Fn_ID9_Done
00002710  33DA 00002CB8           1944  Fn_ID9_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002716  13FC 0001 00002CBC      1945                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000271E  6000 009C               1946                      BRA     Fn_ID9_Done
00002722  23DA 00002CB8           1947  Fn_ID9_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002728  13FC 0002 00002CBC      1948                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002730  6000 008A               1949                      BRA     Fn_ID9_Done
00002734                          1950              
00002734  0C39 0000 00002CB5      1951  Fn_ID9_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
0000273C  6700 0058               1952                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
00002740  0C39 0001 00002CB5      1953                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002748  6700 005E               1954                      BEQ     Fn_ID9_DtaSrcLng            * Load next long
0000274C  0C39 0004 00002CB5      1955                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002754  6700 0006               1956                      BEQ     Fn_ID9_DtaSrcImd            * Load first word into word one
00002758  6000 0060               1957                      BRA     FN_ID9_Error                * Invalid register value
0000275C                          1958                      
0000275C  0C39 0001 00002C4A      1959  Fn_ID9_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002764  6700 001E               1960                      BEQ     Fn_ID9_DtaSrcByt            * Load next byte
00002768  0C39 0003 00002C4A      1961                      CMP.B   #3, opID                    * opID = 3 - size is word
00002770  6700 0024               1962                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
00002774  0C39 0002 00002C4A      1963                      CMP.B   #2, opID                    * opID = 0 - size is long
0000277C  6700 002A               1964                      BEQ     Fn_ID9_DtaSrcLng            * Load next
00002780  6000 0038               1965                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
00002784                          1966  
00002784  33DA 00002CBE           1967  Fn_ID9_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000278A  13FC 0000 00002CC2      1968                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002792  6000 0028               1969                      BRA     Fn_ID9_Done
00002796  33DA 00002CBE           1970  Fn_ID9_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
0000279C  13FC 0001 00002CC2      1971                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000027A4  6000 0016               1972                      BRA     Fn_ID9_Done
000027A8  23DA 00002CBE           1973  Fn_ID9_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000027AE  13FC 0002 00002CC2      1974                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000027B6  6000 0004               1975                      BRA     Fn_ID9_Done
000027BA                          1976  
000027BA                          1977  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
000027BA                          1978                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000027BA  4E75                    1979                      RTS   
000027BC                          1980  
000027BC  4E75                    1981  Fn_ID9_Done        RTS
000027BC  4E75                    1982  -------------------- end include --------------------
000027BE                          1983                      INCLUDE 'SR_IDA.X68'
000027BE                          1984  
000027BE                          1985  
000027BE                          1986  SR_IDA
000027BE                          1987  
000027BE                          1988  
000027BE  4E75                    1989  Fn_IDA_Done        RTS
000027BE  4E75                    1990  -------------------- end include --------------------
000027C0                          1991                      INCLUDE 'SR_IDB.X68'
000027C0                          1992  
000027C0                          1993  
000027C0                          1994  SR_IDB
000027C0                          1995  
000027C0                          1996  
000027C0  4E75                    1997  Fn_IDB_Done        RTS
000027C0  4E75                    1998  -------------------- end include --------------------
000027C2                          1999                      INCLUDE 'SR_IDC.X68'
000027C2                          2000  
000027C2                          2001  
000027C2                          2002  SR_IDC      * This is to grab the first four that are already set, ID4
000027C2  3639 00002C48           2003                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000027C8  183C 000C               2004                      MOVE.B  #12,D4
000027CC  E86B                    2005                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000027CE  13C3 00002C4A           2006                      MOVE.B  D3, opID        
000027D4                          2007                      
000027D4                          2008                      * Read next 3 bits into D3
000027D4  3639 00002C48           2009                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000027DA  183C 0004               2010                      MOVE.B  #4, D4
000027DE  E96B                    2011                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000027E0  183C 000D               2012                      MOVE.B  #13,D4
000027E4  E86B                    2013                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000027E6  13C3 00002CB3           2014                      MOVE.B  D3, opDstReg
000027EC                          2015                      
000027EC                          2016                      * Read next 3 bits into D3
000027EC  3639 00002C48           2017                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000027F2  183C 0007               2018                      MOVE.B  #7, D4
000027F6  E96B                    2019                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000027F8  183C 000D               2020                      MOVE.B  #13,D4
000027FC  E86B                    2021                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000027FE  13C3 00002CB4           2022                      MOVE.B  D3, opDstMod
00002804                          2023  
00002804                          2024                      ** Read next 3 bits
00002804                          2025                      **
00002804  3639 00002C48           2026                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000280A  183C 000A               2027                      MOVE.B  #10, D4
0000280E  E96B                    2028                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002810  183C 000D               2029                      MOVE.B  #13,D4
00002814  E86B                    2030                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002816  13C3 00002CB6           2031                      MOVE.B  D3, opSrcMod
0000281C                          2032  
0000281C                          2033                      ** Read next 3 bits
0000281C                          2034                      **
0000281C  3639 00002C48           2035                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002822  183C 000D               2036                      MOVE.B  #13, D4
00002826  E96B                    2037                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002828  183C 000D               2038                      MOVE.B  #13,D4
0000282C  E86B                    2039                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000282E  13C3 00002CB5           2040                      MOVE.B  D3, opSrcReg
00002834                          2041              
00002834                          2042              ** Find out if its Dn, ea or ea, Dn
00002834                          2043              ** ea, Dn - 0,1,2
00002834                          2044              ** Dn, ea - 4,5,6
00002834  47F9 00002D1D           2045              LEA     opNam_AND,A3
0000283A  0C39 0003 00002CB4      2046              CMP.B   #3,opDstMod
00002842  6D00 0012               2047              BLT     Fn_IDC_Case1
00002846  0C39 0007 00002CB4      2048              CMP.B   #7,opDstMod
0000284E  6D00 0048               2049              BLT     Fn_IDC_Case2
00002852  6000 0178               2050              BRA     Fn_IDC_Error
00002856                          2051  
00002856  13F9 00002CB4 00002C4A  2052  Fn_IDC_Case1MOVE.B  opDstMod,opID
00002860  13F9 00002CB6 00002CB4  2053              MOVE.B  opSrcMod,opDstMod
0000286A  1C39 00002CB3           2054              MOVE.B  opDstReg,D6
00002870  13F9 00002CB5 00002CB3  2055              MOVE.B  opSrcReg,opDstReg
0000287A  13C6 00002CB5           2056              MOVE.B  D6,opSrcReg
00002880  13FC 0000 00002CB6      2057              MOVE.B  #0,opSrcMod
00002888                          2058              ** Immediate data?
00002888  0C39 0007 00002CB4      2059              CMP.B   #7, opDstMod
00002890  6700 002E               2060                      BEQ     Fn_IDC_DataDst
00002894  6000 0138               2061                      BRA     Fn_IDC_Done
00002898                          2062  
00002898  13F9 00002CB4 00002C4A  2063  Fn_IDC_Case2MOVE.B  opDstMod,opID
000028A2  5939 00002C4A           2064              SUB.B   #4,opID
000028A8  13FC 0000 00002CB4      2065              MOVE.B  #0,opDstMod
000028B0                          2066              ** Immediate data?
000028B0  0C39 0007 00002CB6      2067              CMP.B   #7, opSrcMod
000028B8  6700 008C               2068                      BEQ     Fn_IDC_DataSrc
000028BC  6000 0110               2069                      BRA     Fn_IDC_Done
000028C0                          2070              
000028C0  0C39 0000 00002CB3      2071  Fn_IDC_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000028C8  6700 0058               2072                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000028CC  0C39 0001 00002CB3      2073                      CMP.B   #1, opDstReg                * Check if source register is 1
000028D4  6700 005E               2074                      BEQ     Fn_IDC_DtaDstLng            * Load next long
000028D8  0C39 0004 00002CB3      2075                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000028E0  6700 0006               2076                      BEQ     Fn_IDC_DtaDstImd            * Load first word into word one
000028E4  6000 00E6               2077                      BRA     FN_IDC_Error                * Invalid register value
000028E8                          2078                      
000028E8  0C39 0001 00002C4A      2079  Fn_IDC_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000028F0  6700 001E               2080                      BEQ     Fn_IDC_DtaDstByt            * Load next byte
000028F4  0C39 0003 00002C4A      2081                      CMP.B   #3, opID                    * opID = 3 - size is word
000028FC  6700 0024               2082                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
00002900  0C39 0002 00002C4A      2083                      CMP.B   #2, opID                    * opID = 0 - size is long
00002908  6700 002A               2084                      BEQ     Fn_IDC_DtaDstLng            * Load next
0000290C  6000 00BE               2085                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002910                          2086  
00002910  33DA 00002CB8           2087  Fn_IDC_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002916  13FC 0000 00002CBC      2088                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
0000291E  6000 00AE               2089                      BRA     Fn_IDC_Done
00002922  33DA 00002CB8           2090  Fn_IDC_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002928  13FC 0001 00002CBC      2091                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002930  6000 009C               2092                      BRA     Fn_IDC_Done
00002934  23DA 00002CB8           2093  Fn_IDC_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
0000293A  13FC 0002 00002CBC      2094                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002942  6000 008A               2095                      BRA     Fn_IDC_Done
00002946                          2096              
00002946  0C39 0000 00002CB5      2097  Fn_IDC_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
0000294E  6700 0058               2098                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002952  0C39 0001 00002CB5      2099                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000295A  6700 005E               2100                      BEQ     Fn_IDC_DtaSrcLng            * Load next long
0000295E  0C39 0004 00002CB5      2101                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002966  6700 0006               2102                      BEQ     Fn_IDC_DtaSrcImd            * Load first word into word one
0000296A  6000 0060               2103                      BRA     FN_IDC_Error                * Invalid register value
0000296E                          2104                      
0000296E  0C39 0001 00002C4A      2105  Fn_IDC_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002976  6700 001E               2106                      BEQ     Fn_IDC_DtaSrcByt            * Load next byte
0000297A  0C39 0003 00002C4A      2107                      CMP.B   #3, opID                    * opID = 3 - size is word
00002982  6700 0024               2108                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002986  0C39 0002 00002C4A      2109                      CMP.B   #2, opID                    * opID = 0 - size is long
0000298E  6700 002A               2110                      BEQ     Fn_IDC_DtaSrcLng            * Load next
00002992  6000 0038               2111                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002996                          2112  
00002996  33DA 00002CBE           2113  Fn_IDC_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000299C  13FC 0000 00002CC2      2114                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000029A4  6000 0028               2115                      BRA     Fn_IDC_Done
000029A8  33DA 00002CBE           2116  Fn_IDC_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000029AE  13FC 0001 00002CC2      2117                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000029B6  6000 0016               2118                      BRA     Fn_IDC_Done
000029BA  23DA 00002CBE           2119  Fn_IDC_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000029C0  13FC 0002 00002CC2      2120                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000029C8  6000 0004               2121                      BRA     Fn_IDC_Done
000029CC                          2122  
000029CC                          2123  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
000029CC                          2124                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000029CC  4E75                    2125                      RTS   
000029CE                          2126  
000029CE  4E75                    2127  Fn_IDC_Done        RTS
000029CE  4E75                    2128  -------------------- end include --------------------
000029D0                          2129                      INCLUDE 'SR_IDD.X68'
000029D0                          2130  
000029D0                          2131  
000029D0                          2132  SR_IDD      * This is to grab the first four that are already set, ID4
000029D0  3639 00002C48           2133                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000029D6  183C 000C               2134                      MOVE.B  #12,D4
000029DA  E86B                    2135                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000029DC  13C3 00002C4A           2136                      MOVE.B  D3, opID        
000029E2                          2137                      
000029E2                          2138                      * Read next 3 bits into D3
000029E2  3639 00002C48           2139                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000029E8  183C 0004               2140                      MOVE.B  #4, D4
000029EC  E96B                    2141                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000029EE  183C 000D               2142                      MOVE.B  #13,D4
000029F2  E86B                    2143                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000029F4  13C3 00002CB3           2144                      MOVE.B  D3, opDstReg
000029FA                          2145                      
000029FA                          2146                      * Read next 3 bits into D3
000029FA  3639 00002C48           2147                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A00  183C 0007               2148                      MOVE.B  #7, D4
00002A04  E96B                    2149                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002A06  183C 000D               2150                      MOVE.B  #13,D4
00002A0A  E86B                    2151                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A0C  13C3 00002CB4           2152                      MOVE.B  D3, opDstMod
00002A12                          2153  
00002A12                          2154                      ** Read next 3 bits
00002A12                          2155                      **
00002A12  3639 00002C48           2156                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A18  183C 000A               2157                      MOVE.B  #10, D4
00002A1C  E96B                    2158                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A1E  183C 000D               2159                      MOVE.B  #13,D4
00002A22  E86B                    2160                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A24  13C3 00002CB6           2161                      MOVE.B  D3, opSrcMod
00002A2A                          2162  
00002A2A                          2163                      ** Read next 3 bits
00002A2A                          2164                      **
00002A2A  3639 00002C48           2165                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A30  183C 000D               2166                      MOVE.B  #13, D4
00002A34  E96B                    2167                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A36  183C 000D               2168                      MOVE.B  #13,D4
00002A3A  E86B                    2169                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A3C  13C3 00002CB5           2170                      MOVE.B  D3, opSrcReg
00002A42                          2171              
00002A42                          2172              ** Find out if its Dn, ea or ea, Dn
00002A42                          2173              ** ea, Dn - 0,1,2
00002A42                          2174              ** Dn, ea - 4,5,6
00002A42  0C39 0003 00002CB4      2175              CMP.B   #3,opDstMod
00002A4A  6D00 002A               2176              BLT     Fn_IDD_Case1
00002A4E  0C39 0003 00002CB4      2177              CMP.B   #3,opDstMod
00002A56  6700 0094               2178              BEQ     Fn_IDD_Case3
00002A5A  0C39 0007 00002CB4      2179              CMP.B   #7,opDstMod
00002A62  6D00 005A               2180              BLT     Fn_IDD_Case2
00002A66  0C39 0007 00002CB4      2181              CMP.B   #7,opDstMod
00002A6E  6700 007C               2182              BEQ     Fn_IDD_Case3
00002A72  6000 01B2               2183              BRA     Fn_IDD_Error
00002A76                          2184  
00002A76  47F9 00002D21           2185  Fn_IDD_Case1LEA     opNam_ADD,A3
00002A7C  13F9 00002CB4 00002C4A  2186              MOVE.B  opDstMod,opID
00002A86  13F9 00002CB6 00002CB4  2187              MOVE.B  opSrcMod,opDstMod
00002A90  1C39 00002CB3           2188              MOVE.B  opDstReg,D6
00002A96  13F9 00002CB5 00002CB3  2189              MOVE.B  opSrcReg,opDstReg
00002AA0  13C6 00002CB5           2190              MOVE.B  D6,opSrcReg
00002AA6  13FC 0000 00002CB6      2191              MOVE.B  #0,opSrcMod
00002AAE                          2192              ** Immediate data?
00002AAE  0C39 0007 00002CB4      2193              CMP.B   #7, opDstMod
00002AB6  6700 0062               2194                      BEQ     Fn_IDD_DataDst
00002ABA  6000 016C               2195                      BRA     Fn_IDD_Done
00002ABE                          2196  
00002ABE  47F9 00002D21           2197  Fn_IDD_Case2LEA     opNam_ADD,A3
00002AC4  13F9 00002CB4 00002C4A  2198              MOVE.B  opDstMod,opID
00002ACE  5939 00002C4A           2199              SUB.B   #4,opID
00002AD4  13FC 0000 00002CB4      2200              MOVE.B  #0,opDstMod
00002ADC                          2201              ** Immediate data?
00002ADC  0C39 0007 00002CB6      2202              CMP.B   #7, opSrcMod
00002AE4  6700 00BA               2203                      BEQ     Fn_IDD_DataSrc
00002AE8  6000 013E               2204                      BRA     Fn_IDD_Done
00002AEC                          2205              
00002AEC  47F9 00002D25           2206  Fn_IDD_Case3LEA     opNam_ADDA,A3
00002AF2  13F9 00002CB4 00002C4A  2207              MOVE.B  opDstMod,opID
00002AFC  5939 00002C4A           2208              SUB.B   #4,opID
00002B02  13FC 0000 00002CB4      2209              MOVE.B  #0,opDstMod
00002B0A                          2210              ** Immediate data?
00002B0A  0C39 0007 00002CB6      2211              CMP.B   #7, opSrcMod
00002B12  6700 008C               2212                      BEQ     Fn_IDD_DataSrc
00002B16  6000 0110               2213                      BRA     Fn_IDD_Done
00002B1A                          2214              
00002B1A  0C39 0000 00002CB3      2215  Fn_IDD_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002B22  6700 0058               2216                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002B26  0C39 0001 00002CB3      2217                      CMP.B   #1, opDstReg                * Check if source register is 1
00002B2E  6700 005E               2218                      BEQ     Fn_IDD_DtaDstLng            * Load next long
00002B32  0C39 0004 00002CB3      2219                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002B3A  6700 0006               2220                      BEQ     Fn_IDD_DtaDstImd            * Load first word into word one
00002B3E  6000 00E6               2221                      BRA     FN_IDD_Error                * Invalid register value
00002B42                          2222                      
00002B42  0C39 0001 00002C4A      2223  Fn_IDD_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002B4A  6700 001E               2224                      BEQ     Fn_IDD_DtaDstByt            * Load next byte
00002B4E  0C39 0003 00002C4A      2225                      CMP.B   #3, opID                    * opID = 3 - size is word
00002B56  6700 0024               2226                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002B5A  0C39 0002 00002C4A      2227                      CMP.B   #2, opID                    * opID = 0 - size is long
00002B62  6700 002A               2228                      BEQ     Fn_IDD_DtaDstLng            * Load next
00002B66  6000 00BE               2229                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002B6A                          2230  
00002B6A  33DA 00002CB8           2231  Fn_IDD_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002B70  13FC 0000 00002CBC      2232                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002B78  6000 00AE               2233                      BRA     Fn_IDD_Done
00002B7C  33DA 00002CB8           2234  Fn_IDD_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002B82  13FC 0001 00002CBC      2235                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002B8A  6000 009C               2236                      BRA     Fn_IDD_Done
00002B8E  23DA 00002CB8           2237  Fn_IDD_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002B94  13FC 0002 00002CBC      2238                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002B9C  6000 008A               2239                      BRA     Fn_IDD_Done
00002BA0                          2240              
00002BA0  0C39 0000 00002CB5      2241  Fn_IDD_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002BA8  6700 0058               2242                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002BAC  0C39 0001 00002CB5      2243                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002BB4  6700 005E               2244                      BEQ     Fn_IDD_DtaSrcLng            * Load next long
00002BB8  0C39 0004 00002CB5      2245                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002BC0  6700 0006               2246                      BEQ     Fn_IDD_DtaSrcImd            * Load first word into word one
00002BC4  6000 0060               2247                      BRA     FN_IDD_Error                * Invalid register value
00002BC8                          2248                      
00002BC8  0C39 0001 00002C4A      2249  Fn_IDD_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002BD0  6700 001E               2250                      BEQ     Fn_IDD_DtaSrcByt            * Load next byte
00002BD4  0C39 0003 00002C4A      2251                      CMP.B   #3, opID                    * opID = 3 - size is word
00002BDC  6700 0024               2252                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002BE0  0C39 0002 00002C4A      2253                      CMP.B   #2, opID                    * opID = 0 - size is long
00002BE8  6700 002A               2254                      BEQ     Fn_IDD_DtaSrcLng            * Load next
00002BEC  6000 0038               2255                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002BF0                          2256  
00002BF0  33DA 00002CBE           2257  Fn_IDD_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002BF6  13FC 0000 00002CC2      2258                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002BFE  6000 0028               2259                      BRA     Fn_IDD_Done
00002C02  33DA 00002CBE           2260  Fn_IDD_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002C08  13FC 0001 00002CC2      2261                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002C10  6000 0016               2262                      BRA     Fn_IDD_Done
00002C14  23DA 00002CBE           2263  Fn_IDD_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002C1A  13FC 0002 00002CC2      2264                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002C22  6000 0004               2265                      BRA     Fn_IDD_Done
00002C26                          2266  
00002C26                          2267  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
00002C26                          2268                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002C26  4E75                    2269                      RTS   
00002C28                          2270  
00002C28  4E75                    2271  Fn_IDD_Done        RTS
00002C28  4E75                    2272  -------------------- end include --------------------
00002C2A                          2273                      INCLUDE 'SR_IDE.X68'
00002C2A                          2274  
00002C2A                          2275  SR_IDE
00002C2A                          2276  
00002C2A  4E75                    2277                RTS
00002C2A  4E75                    2278  -------------------- end include --------------------
00002C2C                          2279  
00002C2C                          2280  ** -----------------------------------------------------------
00002C2C                          2281  ** Variables and constants
00002C2C                          2282  ** -----------------------------------------------------------
00002C2C                          2283  
00002C2C  =0000001A               2284  maxLines            EQU      26                      * Max lines to display
00002C2C                          2285  
00002C2C= 00000000                2286  adrValStart         DC.L     $00000000               * Value of starting address - set by user
00002C30= 38 39 41 42 43 44 ...   2287  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
00002C39= FF                      2288  adrStsStart         DC.B     $FF                     * Status of starting address
00002C3A                          2289                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002C3A= 00000000                2290  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
00002C3E= 38 39 41 42 43 44 ...   2291  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
00002C47= FF                      2292  adrStsEnd           DC.B     $FF                     * Status of ending address
00002C48                          2293                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002C48                          2294  
00002C48= 0000                    2295  opWord              DC.W     $0000                   * 16 bit instruction Word
00002C4A= 00                      2296  opID                DC.B     $00                     * First 4 bit value ID
00002C4B= 01                      2297  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
00002C4C                          2298  
00002C4C= 00000000                2299  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
00002C50= 38 39 41 42 43 44 ...   2300  opStrAdr            DC.B     '89ABCDEF',0            * String address
00002C5A= 00000000                2301  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
00002C5E                          2302  
00002C5E= 50 6C 61 63 65 68 ...   2303  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
00002CAE= 00000000                2304  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002CB2                          2305  
00002CB2= FF                      2306  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002CB3                          2307  
00002CB3= FF                      2308  opDstReg            DC.B     $FF                     * Destination Register Value
00002CB4= FF                      2309  opDstMod            DC.B     $FF                     * Destination Mode Value
00002CB5= FF                      2310  opSrcReg            DC.B     $FF                     * Source Register Value
00002CB6= FF                      2311  opSrcMod            DC.B     $FF                     * Source Register Mode
00002CB7                          2312  
00002CB8= 00000000                2313  opDta1              DC.L     $00000000               * Data value one (most likely source)
00002CBC= FF                      2314  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
00002CBE= 00000000                2315  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002CC2= FF                      2316  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002CC3= 30 30 30 30 00          2317  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002CC8= 30 30 30 30 30 30 ...   2318  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002CD1                          2319  
00002CD1= 44 41 54 41 00          2320  opNam_DATA          DC.B     'DATA',0
00002CD6= 4D 4F 56 45 00          2321  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
00002CDB= 4D 4F 56 45 41 00       2322  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002CE1= 4C 45 41 00             2323  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002CE5= 4E 4F 54 00             2324  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002CE9= 4D 4F 56 45 4D 00       2325  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
00002CEF= 4E 4F 50 00             2326  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002CF3= 52 54 53 00             2327  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002CF7= 4A 53 52 00             2328  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
00002CFB= 41 44 44 51 00          2329  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002D00= 42 52 41 00             2330  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002D04= 42 45 51 00             2331  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002D08= 42 47 54 00             2332  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
00002D0C= 42 4C 45 00             2333  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
00002D10= 4D 4F 56 45 51 00       2334  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
00002D16= 4F 52 00                2335  opNam_OR            DC.B     'OR',0                  * String value for instruction
00002D19= 53 55 42 00             2336  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
00002D1D= 41 4E 44 00             2337  opNam_AND           DC.B     'AND',0                 * String value for instruction
00002D21= 41 44 44 00             2338  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
00002D25= 41 44 44 41 00          2339  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
00002D2A= 41 53 4C 00             2340  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
00002D2E= 41 53 52 00             2341  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
00002D32= 4C 53 4C 00             2342  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
00002D36= 4C 53 52 00             2343  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
00002D3A= 52 4F 4C 00             2344  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
00002D3E= 52 4F 52 00             2345  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
00002D42                          2346  
00002D42= 2E 42 00                2347  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
00002D45= 2E 57 00                2348  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
00002D48= 2E 4C 00                2349  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
00002D4B                          2350  
00002D4B= 50 6C 61 63 65 68 ...   2351  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
00002D9C= 45 72 72 6F 72 00       2352  msgErr              DC.B     'Error',0               * Debug message
00002DA2                          2353  
00002DA2= 33 20 43 6F 72 65 ...   2354  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002DB9= 4D 65 6D 6F 72 79 ...   2355  msgHdr02a           DC.B     'Memory range:',0
00002DC7= 20 74 6F 20 00          2356  msgHdr02b           DC.B     ' to ',0
00002DCC                          2357  
00002DCC= 20 2D 20 41 6C 6C ...   2358  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
00002DFB= 20 2D 20 56 61 6C ...   2359  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
00002E2D= 20 2D 20 53 74 61 ...   2360  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
00002E62= 20 20 20 40 20 58 ...   2361  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002E81= 20 2D 20 41 64 64 ...   2362  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002EC2= 20 20 20 28 61 75 ...   2363  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002ED7= 50 6C 65 61 73 65 ...   2364  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00002EF9= 49 6E 76 61 6C 69 ...   2365  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
00002F1B= 49 6E 76 61 6C 69 ...   2366  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
00002F48= 53 74 61 72 74 69 ...   2367  msgStrAdr1Scc       DC.B     'Starting address: ',0
00002F5B= 50 6C 65 61 73 65 ...   2368  msgStrAdr2          DC.B     'Please enter an ending address: ',0
00002F7C= 49 6E 76 61 6C 69 ...   2369  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
00002F9C= 49 6E 76 61 6C 69 ...   2370  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
00002FC7                          2371  
00002FC7= 48 69 74 20 45 6E ...   2372  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
00002FEA= 59 6F 75 20 68 61 ...   2373  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
0000301D= 20 20 20 20 20 20 ...   2374  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
0000304F= 54 68 61 6E 6B 20 ...   2375  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
00003079                          2376  
00003079= 2A 2A 2A 2A 2A 2A ...   2377  msgLine             DC.B     '**************************************************',CR,LF,0
000030AE= 0D 0A 00                2378  msgNewLine          DC.B     CR,LF,0
000030B1= 2C 00                   2379  opComma             DC.B     ',',0
000030B3= 2E 00                   2380  opPeriod            DC.B     '.',0
000030B5= 20 00                   2381  opSpace             DC.B     ' ',0
000030B8= 0900                    2382  opTab               DC.W     $0900                  * Tab - doesn't work as expected
000030BA= 00                      2383  opBlank             DC.B     '',0
000030BB  =0000000D               2384  CR                  EQU      $0D                     * ASCII code for Carriage Return
000030BB  =0000000A               2385  LF                  EQU      $0A                     * ASCII code for Line Feed
000030BB                          2386  
000030BB                          2387                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           2C3E
ADRSTRSTART         2C30
ADRSTSEND           2C47
ADRSTSSTART         2C39
ADRVALEND           2C3A
ADRVALSTART         2C2C
CR                  D
FN_ASCII_LCLTR      1994
FN_ASCII_NUM        1988
FN_ASCII_UCLTR      198E
FN_CPY_STR_DONE     19F2
FN_CPY_STR_LOOP     19E4
FN_DSP_DATA         15CA
FN_DSP_DONE         1962
FN_DSP_DTA1         1662
FN_DSP_DTA1_00      16BA
FN_DSP_DTA1_01      16CE
FN_DSP_DTA1_02      16E2
FN_DSP_DTA1_03      16FE
FN_DSP_DTA1_04      171E
FN_DSP_DTA1_07      173E
FN_DSP_DTA1_BYT     1766
FN_DSP_DTA1_ERR     17CC
FN_DSP_DTA1_LNG     17AA
FN_DSP_DTA1_WRD     1788
FN_DSP_DTA2         17E8
FN_DSP_DTA2_00      1840
FN_DSP_DTA2_01      1854
FN_DSP_DTA2_02      1868
FN_DSP_DTA2_03      1884
FN_DSP_DTA2_04      18A4
FN_DSP_DTA2_07      18C4
FN_DSP_DTA2_BYT     18EC
FN_DSP_DTA2_ERR     1952
FN_DSP_DTA2_LNG     1930
FN_DSP_DTA2_WRD     190E
FN_DSP_INSTR        15E6
FN_DSP_OPR1         1656
FN_DSP_OPR2         17DC
FN_DSP_SIZB         1626
FN_DSP_SIZL         1646
FN_DSP_SIZW         1636
FN_HEX_LTR          19AC
FN_HEX_NUM          19A6
FN_HEX_STR_DONE     19DE
FN_HEX_STR_LOOP     19B2
FN_ID4_CHECKD1      1CEC
FN_ID4_CHECKD2      1D10
FN_ID4_CHECKD3      1D40
FN_ID4_DATA         2036
FN_ID4_DONE         20BE
FN_ID4_DTABYT       2086
FN_ID4_DTAIMD       205E
FN_ID4_DTALNG       20AA
FN_ID4_DTAWRD       2098
FN_ID4_ERROR        20BC
FN_ID4_JSR          1D58
FN_ID4_JSR_SRC      1DF4
FN_ID4_LEA          1E04
FN_ID4_LEA_SRC      1E64
FN_ID4_MOVEMMTOR    1EE4
FN_ID4_MOVEMRTOM    1E74
FN_ID4_MOVEM_SRC    1F50
FN_ID4_NOP          1F60
FN_ID4_NOT          1FA0
FN_ID4_NOT_SRC      1FDC
FN_ID4_RTS          1FF6
FN_ID4_VERIFY_JSR   1D64
FN_ID4_VERIFY_LEA   1E10
FN_ID4_VERIFY_MMR   1EF0
FN_ID4_VERIFY_MRM   1E80
FN_ID4_VERIFY_NOP   1F6C
FN_ID4_VERIFY_NOT   1FAC
FN_ID4_VERIFY_RTS   2002
FN_ID5_CHKDSTMOD    21D6
FN_ID5_CHKDSTREG    21E6
FN_ID5_DONE         2228
FN_ID5_DTADSTLNG    2214
FN_ID5_DTADSTWRD    2202
FN_ID5_DTASRCBYT    21A0
FN_ID5_DTASRCIMD    2178
FN_ID5_DTASRCLNG    21C4
FN_ID5_DTASRCWRD    21B2
FN_ID5_ERROR        2226
FN_ID5_VERIFY       2138
FN_ID6_BEQ          22AA
FN_ID6_BGT          22B4
FN_ID6_BLE          22BE
FN_ID6_BRA          22A0
FN_ID6_DISPLACEMENT  22C4
FN_ID6_DONE         2318
FN_ID6_DSPLCMNT16   22F2
FN_ID6_DSPLCMNT32   2304
FN_ID6_ERROR        2316
FN_ID7_DONE         23A0
FN_ID7_ERROR        239E
FN_ID8_CASE1        2436
FN_ID8_CASE2        2478
FN_ID8_DATADST      24A0
FN_ID8_DATASRC      2526
FN_ID8_DONE         25AE
FN_ID8_DTADSTBYT    24F0
FN_ID8_DTADSTIMD    24C8
FN_ID8_DTADSTLNG    2514
FN_ID8_DTADSTWRD    2502
FN_ID8_DTASRCBYT    2576
FN_ID8_DTASRCIMD    254E
FN_ID8_DTASRCLNG    259A
FN_ID8_DTASRCWRD    2588
FN_ID8_ERROR        25AC
FN_ID9_CASE1        2644
FN_ID9_CASE2        2686
FN_ID9_DATADST      26AE
FN_ID9_DATASRC      2734
FN_ID9_DONE         27BC
FN_ID9_DTADSTBYT    26FE
FN_ID9_DTADSTIMD    26D6
FN_ID9_DTADSTLNG    2722
FN_ID9_DTADSTWRD    2710
FN_ID9_DTASRCBYT    2784
FN_ID9_DTASRCIMD    275C
FN_ID9_DTASRCLNG    27A8
FN_ID9_DTASRCWRD    2796
FN_ID9_ERROR        27BA
FN_IDA_DONE         27BE
FN_IDB_DONE         27C0
FN_IDC_CASE1        2856
FN_IDC_CASE2        2898
FN_IDC_DATADST      28C0
FN_IDC_DATASRC      2946
FN_IDC_DONE         29CE
FN_IDC_DTADSTBYT    2910
FN_IDC_DTADSTIMD    28E8
FN_IDC_DTADSTLNG    2934
FN_IDC_DTADSTWRD    2922
FN_IDC_DTASRCBYT    2996
FN_IDC_DTASRCIMD    296E
FN_IDC_DTASRCLNG    29BA
FN_IDC_DTASRCWRD    29A8
FN_IDC_ERROR        29CC
FN_IDD_CASE1        2A76
FN_IDD_CASE2        2ABE
FN_IDD_CASE3        2AEC
FN_IDD_DATADST      2B1A
FN_IDD_DATASRC      2BA0
FN_IDD_DONE         2C28
FN_IDD_DTADSTBYT    2B6A
FN_IDD_DTADSTIMD    2B42
FN_IDD_DTADSTLNG    2B8E
FN_IDD_DTADSTWRD    2B7C
FN_IDD_DTASRCBYT    2BF0
FN_IDD_DTASRCIMD    2BC8
FN_IDD_DTASRCLNG    2C14
FN_IDD_DTASRCWRD    2C02
FN_IDD_ERROR        2C26
FN_MAIN_CHKAGN      1140
FN_MAIN_CHKEND      1132
FN_MAIN_CHKLIN      10FA
FN_MAIN_CHKPAG      1110
FN_MAIN_CONTINUE    1178
FN_MAIN_DONE        117C
FN_MAIN_DSP         10F4
FN_MAIN_ERRINS      10EE
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_MOVE_CHKDSTMOD   1BE0
FN_MOVE_CHKDSTREG   1BF0
FN_MOVE_CHKSRCREG   1B5A
FN_MOVE_DONE        1C30
FN_MOVE_DTADSTLNG   1C1E
FN_MOVE_DTADSTWRD   1C0C
FN_MOVE_DTASRCBYT   1BAA
FN_MOVE_DTASRCIMD   1B82
FN_MOVE_DTASRCLNG   1BCE
FN_MOVE_DTASRCWRD   1BBC
FN_MOVE_ERROR       1C38
FN_MOVE_INS01       1A7A
FN_MOVE_INS02       1A8A
FN_MOVE_SIZB        1B26
FN_MOVE_SIZL        1B3E
FN_MOVE_SIZW        1B32
FN_MOVE_SRCMOD      1B4A
FN_MOVE_VERIFY      1AA2
FN_UI_CHKHEX        13DC
FN_UI_CHKHEXASL     1430
FN_UI_CHKHEXDONE    1418
FN_UI_CHKHEXLOOP    13E2
FN_UI_CHKHEXRDR     1432
FN_UI_CHKLEN        13A8
FN_UI_CHKVAL        14BC
FN_UI_CHKVALCMP     14F0
FN_UI_CHKVALEBIG    14EA
FN_UI_CHKVALEMAX    14DC
FN_UI_CHKVALSBIG    14D6
FN_UI_CHKVALSMAX    14C8
FN_UI_CHKVALSONE    1516
FN_UI_CHKVALSWP     14FA
FN_UI_CHKVALSWRD    1500
FN_UI_DONE          1518
FN_UI_DSPSTART      1258
FN_UI_END           1350
FN_UI_ENDE1         136C
FN_UI_ENDE2         137C
FN_UI_END_IN        138C
FN_UI_HDRNEXT       127C
FN_UI_LOOP          1226
FN_UI_SETEHEX       1494
FN_UI_SETEHEXI1     14A4
FN_UI_SETEHEXI2     14B0
FN_UI_SETELEN       13B4
FN_UI_SETELENI1     13C4
FN_UI_SETELENI2     13D0
FN_UI_SETVHEX       143C
FN_UI_SETVHEXI1     144C
FN_UI_SETVHEXI2     1470
FN_UI_START         12F8
FN_UI_STARTE1       1314
FN_UI_STARTE2       1324
FN_UI_START_IN      1334
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             304F
MSGENDMEM01         2FEA
MSGENDMEM02         301D
MSGERR              2D9C
MSGHDR01            2DA2
MSGHDR02A           2DB9
MSGHDR02B           2DC7
MSGINTEMP           2D4B
MSGLINE             3079
MSGNEWLINE          30AE
MSGPAGE             2FC7
MSGSTRADR1          2ED7
MSGSTRADR1ERR1      2EF9
MSGSTRADR1ERR2      2F1B
MSGSTRADR1SCC       2F48
MSGSTRADR2          2F5B
MSGSTRADR2ERR1      2F7C
MSGSTRADR2ERR2      2F9C
MSGSTRINTRO         2DCC
MSGSTRNOTE          2E81
MSGSTRNOTEMORE      2EC2
MSGSTRRANGE         2DFB
MSGSTRSIZE          2E2D
MSGSTRSIZEEXMPL     2E62
OPBLANK             30BA
OPCOMMA             30B1
OPDSTMOD            2CB4
OPDSTREG            2CB3
OPDTA1              2CB8
OPDTA1T             2CBC
OPDTA2              2CBE
OPDTA2T             2CC2
OPERR               2C4B
OPID                2C4A
OPNAM_ADD           2D21
OPNAM_ADDA          2D25
OPNAM_ADDQ          2CFB
OPNAM_AND           2D1D
OPNAM_ASL           2D2A
OPNAM_ASR           2D2E
OPNAM_BEQ           2D04
OPNAM_BGT           2D08
OPNAM_BLE           2D0C
OPNAM_BRA           2D00
OPNAM_DATA          2CD1
OPNAM_JSR           2CF7
OPNAM_LEA           2CE1
OPNAM_LSL           2D32
OPNAM_LSR           2D36
OPNAM_MOVE          2CD6
OPNAM_MOVEA         2CDB
OPNAM_MOVEM         2CE9
OPNAM_MOVEQ         2D10
OPNAM_NOP           2CEF
OPNAM_NOT           2CE5
OPNAM_OR            2D16
OPNAM_ROL           2D3A
OPNAM_ROR           2D3E
OPNAM_RTS           2CF3
OPNAM_SUB           2D19
OPNXTADR            2C5A
OPOUTBUF            2C5E
OPPERIOD            30B3
OPPTRNAM            2CAE
OPSIZB              2D42
OPSIZL              2D48
OPSIZW              2D45
OPSPACE             30B5
OPSRCMOD            2CB6
OPSRCREG            2CB5
OPSTRADR            2C50
OPSTRDTALNG         2CC8
OPSTRDTAWRD         2CC3
OPTAB               30B8
OPVALADR            2C4C
OPVALSIZ            2CB2
OPWORD              2C48
SR_ASCII_HEX        1974
SR_CNT_STR_BUF      19F4
SR_CPY_STR_BUF      19E4
SR_DSP_DISPLAY      1592
SR_DSP_HEADER       1530
SR_HEX_ASCII        199A
SR_HEX_STR          19B2
SR_ID3              19F8
SR_ID4              1C3A
SR_ID5              20C0
SR_ID6              222A
SR_ID7              231A
SR_ID8              23A2
SR_ID9              25B0
SR_IDA              27BE
SR_IDB              27C0
SR_IDC              27C2
SR_IDD              29D0
SR_IDE              2C2A
SR_IDX              19F6
SR_JUMP             1196
SR_UI_INPUT         1216
