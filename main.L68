00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/7/2021 4:14:23 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 00002C8E    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 00002C9C    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 00002C8E             51                      LEA     adrValStart,A4
00001020  4BF9 00002C92             52                      LEA     adrStrStart,A5
00001026  4EB9 000019D4             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 00002C9C             54                      LEA     adrValEnd,A4
00001032  4BF9 00002CA0             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019D4             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 000011B8             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 00002C8E             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001552             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 00002CAE             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 00002CAA             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 00002CBC             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 00002CAC        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 00002CAD        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002D14        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002D15        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002D16        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002D17        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002D18        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002D1A    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 00002D1E        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 00002D20    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002D24        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA  23FC 00000000 00002D34    96                      MOVE.L  #$00000000,opMask
000010D4  13FC 0000 00002D38        97                      MOVE.B  #$00,opRotate
000010DC  13FC 0000 00002D39        98                      MOVE.B  #$00,opSizDir
000010E4  13FC 0000 00002D3A        99                      MOVE.B  #$00,opIR
000010EC                           100  
000010EC                           101                      ** Jump table
000010EC                           102                      **
000010EC  3A39 00002CAA            103                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010F2  1C3C 000C                104                      MOVE.B  #12,D6
000010F6  EC6D                     105                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010F8  CAFC 0008                106                      MULU    #8,D5                   * offset is multiple of 8
000010FC  4EB0 5000                107                      JSR     0(A0,D5)                * Jump indirect with index
00001100                           108  
00001100                           109                      ** Invalid instruction
00001100                           110                      **
00001100  0C39 0001 00002CAD       111                      CMP.B   #1,opErr
00001108  6700 0006                112                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
0000110C  6000 0008                113                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
00001110  2479 00002CBC            114  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
00001116                           115  
00001116                           116                      ** Display result
00001116                           117                      **
00001116  4EB9 000015B4            118  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
0000111C                           119  
0000111C                           120                      ** Max lines display stop, wait for enter
0000111C                           121                      **
0000111C  5207                     122  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
0000111E                           123  
0000111E  2C07                     124                      MOVE.L  D7,D6                   * Line counter to D6 for division
00001120  8CFC 001A                125                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001124  4846                     126                      SWAP    D6                      * Swap for remainder (modulo)
00001126  BC3C 0000                127                      CMP.B   #0,D6                   * Check remainder for zero
0000112A  6700 0006                128                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000112E  6000 0024                129                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001132                           130  
00001132                           131                      ** Logic to check ENTER key to show next page
00001132                           132                      **
00001132  43F9 00003031            133  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001138  103C 000E                134                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000113C  4E4F                     135                      TRAP    #15                     * Display to screen
0000113E  103C 0005                136                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001142  4E4F                     137                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001144                           138  
00001144                           139                      ** Clear screen
00001144  103C 000B                140                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001148  323C FF00                141                      MOVE.W  #$FF00,D1               * Clear the screen
0000114C  4E4F                     142                      TRAP    #15
0000114E                           143  
0000114E                           144                      ** Display header
0000114E  4EB9 00001552            145                      JSR     SR_DSP_HEADER
00001154                           146  
00001154                           147                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001154                           148                      **
00001154  B5F9 00002C9C            149  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
0000115A  6C00 0006                150                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000115E  6000 003A                151                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001162                           152  
00001162                           153                      ** Logic to check for for Y or N to check another region of memory
00001162                           154                      **
00001162  43F9 00003054            155  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001168  103C 000E                156                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000116C  4E4F                     157                      TRAP    #15                     * Display to screen
0000116E  43F9 00003087            158                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001174  103C 000E                159                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001178  4E4F                     160                      TRAP    #15                     * Display to screen
0000117A                           161  
0000117A  43F9 00002DB5            162                      LEA     msgInTemp,A1            * Load placeholder for input string
00001180  103C 0002                163                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001184  4E4F                     164                      TRAP    #15                     * Read string to (A1), length in D1.W
00001186  0C11 0059                165                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
0000118A  6700 FE7A                166                      BEQ     Fn_MAIN_Start           * Restart program
0000118E  0C11 0079                167                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001192  6700 FE72                168                      BEQ     Fn_MAIN_Start           * Restart program
00001196  6000 0006                169                      BRA     Fn_Main_Done            * Exit program
0000119A                           170  
0000119A  6000 FEC0                171  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000119E                           172  
0000119E                           173  Fn_MAIN_Done        ** That's all folks
0000119E  103C 000B                174                      MOVE.B  #11,D0                  * Trap task 2 does the following:
000011A2  323C FF00                175                      MOVE.W  #$FF00,D1               * Clear the screen
000011A6  4E4F                     176                      TRAP    #15
000011A8                           177  
000011A8                           178                      ** Thank you message
000011A8  43F9 000030B9            179                      LEA     msgDone,A1              * Loads MESSAGE into A1
000011AE  103C 000E                180                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000011B2  4E4F                     181                      TRAP    #15                     * Display to screen
000011B4                           182  
000011B4                           183  
000011B4  4E72 2700                184                      STOP   #$2700                   * Stop execution
000011B8                           185  
000011B8                           186  ** -----------------------------------------------------------
000011B8                           187  ** JUMP TABLE: First 4 bits of instruction
000011B8                           188  **
000011B8                           189  ** Jump instruction: pointing to label (xxx).L
000011B8                           190  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
000011B8                           191  **                          label address (Long)
000011B8                           192  **
000011B8                           193  ** RTS instruction:
000011B8                           194  **  |4    E    |7    5     |               - Offset 2 bytes
000011B8                           195  **
000011B8                           196  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
000011B8                           197  **
000011B8                           198  ** Note: should find a value since 4 bits is 0 to F
000011B8                           199  ** Note: There aren't any instructions that start with F
000011B8                           200  **
000011B8                           201  ** -----------------------------------------------------------
000011B8  4EB9 00001A18            202  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
000011BE  4E75                     203                      RTS
000011C0  4EB9 00001A1A            204                      JSR     SR_ID3
000011C6  4E75                     205                      RTS
000011C8  4EB9 00001A1A            206                      JSR     SR_ID3
000011CE  4E75                     207                      RTS
000011D0  4EB9 00001A1A            208                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011D6  4E75                     209                      RTS
000011D8  4EB9 00001C5C            210                      JSR     SR_ID4
000011DE  4E75                     211                      RTS
000011E0  4EB9 000020EA            212                      JSR     SR_ID5
000011E6  4E75                     213                      RTS
000011E8  4EB9 0000225C            214                      JSR     SR_ID6
000011EE  4E75                     215                      RTS
000011F0  4EB9 00002354            216                      JSR     SR_ID7
000011F6  4E75                     217                      RTS
000011F8  4EB9 000023E4            218                      JSR     SR_ID8
000011FE  4E75                     219                      RTS
00001200  4EB9 000025FA            220                      JSR     SR_ID9
00001206  4E75                     221                      RTS
00001208  4EB9 00002810            222                      JSR     SR_IDA
0000120E  4E75                     223                      RTS
00001210  4EB9 00002812            224                      JSR     SR_IDB
00001216  4E75                     225                      RTS
00001218  4EB9 00002814            226                      JSR     SR_IDC
0000121E  4E75                     227                      RTS
00001220  4EB9 00002A2A            228                      JSR     SR_IDD
00001226  4E75                     229                      RTS
00001228  4EB9 00002C8C            230                      JSR     SR_IDE
0000122E  4E75                     231                      RTS
00001230  4EB9 00001A18            232                      JSR     SR_IDX                   * No instructions @ ID=15
00001236  4E75                     233                      RTS
00001238                           234  
00001238                           235  ** -----------------------------------------------------------
00001238                           236  ** UI: User mem input
00001238                           237  ** -----------------------------------------------------------
00001238                           238  SR_UI_INPUT
00001238  13F8 00FF 00002C9B       239                      MOVE.B  $FF,adrStsStart         * Reset starting address status
00001240  13F8 00FF 00002CA9       240                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001248                           241  
00001248                           242  Fn_UI_Loop          ** Clear screen
00001248  103C 000B                243                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000124C  323C FF00                244                      MOVE.W  #$FF00,D1               * Clear the screen
00001250  4E4F                     245                      TRAP    #15
00001252                           246  
00001252                           247                      ** Header
00001252                           248                      ** ***************************************
00001252                           249  
00001252  43F9 000030E3            250                      LEA     msgLine,A1              * '********************'
00001258  103C 000E                251                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000125C  4E4F                     252                      TRAP    #15                     * Display to screen
0000125E                           253  
0000125E  43F9 00002E0C            254                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001264  103C 000E                255                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001268  4E4F                     256                      TRAP    #15                     * Display to screen
0000126A                           257  
0000126A  0C39 0000 00002C9B       258                      CMP.B   #0,adrStsStart          * Starting address is set
00001272  6700 0006                259                      BEQ     Fn_UI_DspStart          * Display starting address
00001276  6000 0026                260                      BRA     Fn_UI_HdrNext           * Display the rest of the header
0000127A                           261  
0000127A  43F9 00002FB2            262  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
00001280  103C 000E                263                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001284  4E4F                     264                      TRAP    #15                     * Display to screen
00001286                           265  
00001286  43F9 00002C92            266                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000128C  103C 000E                267                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001290  4E4F                     268                      TRAP    #15                     * Display to screen
00001292                           269  
00001292  43F9 00003118            270                      LEA     msgNewLine,A1           * CR,LF
00001298  103C 000E                271                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129C  4E4F                     272                      TRAP    #15                     * Display to screen
0000129E                           273  
0000129E  43F9 000030E3            274  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
000012A4  103C 000E                275                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012A8  4E4F                     276                      TRAP    #15                     * Display to screen
000012AA                           277  
000012AA  43F9 00002E36            278                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
000012B0  103C 000E                279                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B4  4E4F                     280                      TRAP    #15                     * Display to screen
000012B6                           281  
000012B6  43F9 00002E65            282                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
000012BC  103C 000E                283                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C0  4E4F                     284                      TRAP    #15                     * Display to screen
000012C2                           285  
000012C2  43F9 00002E97            286                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012C8  103C 000E                287                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CC  4E4F                     288                      TRAP    #15                     * Display to screen
000012CE                           289  
000012CE  43F9 00002ECC            290                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012D4  103C 000E                291                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012D8  4E4F                     292                      TRAP    #15                     * Display to screen
000012DA                           293  
000012DA  43F9 00002EEB            294                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012E0  103C 000E                295                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012E4  4E4F                     296                      TRAP    #15                     * Display to screen
000012E6                           297  
000012E6  43F9 00002F2C            298                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012EC  103C 000E                299                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012F0  4E4F                     300                      TRAP    #15                     * Display to screen
000012F2                           301  
000012F2  43F9 00003118            302                      LEA     msgNewLine,A1           * CR,LF
000012F8  103C 000E                303                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012FC  4E4F                     304                      TRAP    #15                     * Display to screen
000012FE                           305  
000012FE                           306                      ** Input check
000012FE                           307                      ** ***************************************
000012FE                           308  
000012FE  0C39 0000 00002C9B       309                      CMP.B #0,adrStsStart            * Check status of address 0 = success
00001306  6600 0012                310                      BNE   Fn_UI_Start               * Input starting address
0000130A                           311  
0000130A  0C39 0000 00002CA9       312                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
00001312  6600 005E                313                      BNE   Fn_UI_End                 * Input ending address
00001316                           314  
00001316                           315                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
00001316  6000 01C6                316                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
0000131A                           317  
0000131A                           318  Fn_UI_Start         ** Input Start Address
0000131A                           319                      ** ***************************************
0000131A                           320  
0000131A                           321                      ** Check errors
0000131A  0C39 0001 00002C9B       322                      CMP.B   #1,adrStsStart
00001322  6700 0012                323                      BEQ     Fn_UI_StartE1           * Error: length
00001326  0C39 0002 00002C9B       324                      CMP.B   #2,adrStsStart
0000132E  6700 0016                325                      BEQ     Fn_UI_StartE2           * Error: hex value
00001332  6000 0022                326                      BRA     Fn_UI_Start_In          * No error: ask for input
00001336                           327  
00001336  43F9 00002F63            328  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000133C  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001340  4E4F                     330                      TRAP    #15
00001342  6000 0012                331                      BRA     Fn_UI_Start_In          * User input
00001346                           332  
00001346  43F9 00002F85            333  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000134C  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001350  4E4F                     335                      TRAP    #15
00001352  6000 0002                336                      BRA     Fn_UI_Start_In          * User input
00001356                           337  
00001356  43F9 00002F41            338  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000135C  103C 000E                339                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001360  4E4F                     340                      TRAP    #15                     * Display to screen
00001362                           341  
00001362  43F9 00002DB5            342                      LEA     msgInTemp,A1            * Load placeholder for input string
00001368  103C 0002                343                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000136C  4E4F                     344                      TRAP    #15                     * Read string to (A1), length in D1.W
0000136E                           345  
0000136E  6000 005A                346                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001372                           347  
00001372                           348  Fn_UI_End           ** Input End Address
00001372                           349                      ** ***************************************
00001372                           350  
00001372                           351                      ** Check errors
00001372  0C39 0001 00002CA9       352                      CMP.B   #1,adrStsEnd
0000137A  6700 0012                353                      BEQ     Fn_UI_EndE1             * Error: length
0000137E  0C39 0002 00002CA9       354                      CMP.B   #2,adrStsEnd
00001386  6700 0016                355                      BEQ     Fn_UI_EndE2             * Error: hex value
0000138A  6000 0022                356                      BRA     Fn_UI_End_In            * No error: ask for input
0000138E                           357  
0000138E  43F9 00002FE6            358  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001394  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001398  4E4F                     360                      TRAP    #15
0000139A  6000 0012                361                      BRA     Fn_UI_End_In            * User input
0000139E                           362  
0000139E  43F9 00003006            363  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
000013A4  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013A8  4E4F                     365                      TRAP    #15
000013AA  6000 0002                366                      BRA     Fn_UI_End_In            * User input
000013AE                           367  
000013AE  43F9 00002FC5            368  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
000013B4  103C 000E                369                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013B8  4E4F                     370                      TRAP    #15                     * Display to screen
000013BA                           371  
000013BA  43F9 00002DB5            372                      LEA     msgInTemp,A1            * Load placeholder for input string
000013C0  103C 0002                373                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013C4  4E4F                     374                      TRAP    #15                     * Read string to (A1), length in D1.W
000013C6                           375  
000013C6  6000 0002                376                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013CA                           377  
000013CA                           378  Fn_UI_ChkLen        ** Check length
000013CA                           379                      **   length should be 8 ascii characters
000013CA                           380                      **   value stored in D1.W from input
000013CA                           381                      ** ***************************************
000013CA                           382  
000013CA  B27C 0008                383                      CMP.W   #8,D1                   * Address should be 8 chars long
000013CE  6600 0006                384                      BNE     Fn_UI_SetELen           * Invalid address length
000013D2  6000 002A                385                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013D6                           386  
000013D6                           387  Fn_UI_SetELen       ** Error: length
000013D6  0C39 0000 00002C9B       388                      CMP.B #0,adrStsStart
000013DE  6600 0006                389                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013E2  6000 000E                390                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013E6                           391  Fn_UI_SetELenI1     ** Set error on input 1
000013E6  13FC 0001 00002C9B       392                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013EE  6000 FE58                393                      BRA     Fn_UI_Loop
000013F2                           394  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013F2  13FC 0001 00002CA9       395                      MOVE.B  #1,adrStsEnd
000013FA  6000 FE4C                396                      BRA     Fn_UI_Loop
000013FE                           397  
000013FE                           398  Fn_UI_ChkHex        ** Check hex values
000013FE                           399                      **   30 - 39 (0-9)
000013FE                           400                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013FE                           401                      ** ***************************************
000013FE                           402  
000013FE  163C 0000                403                      MOVE.B  #0,D3                   * Loop counter
00001402  4286                     404                      CLR.L   D6                      * Temporary address storage
00001404                           405  
00001404                           406  Fn_UI_ChkHexLoop    ** Check hex values one at a time
00001404  1819                     407                      MOVE.B  (A1)+,D4                * Unload byte and increment input
00001406                           408  
00001406  B83C 0030                409                      CMP.B   #$30,D4
0000140A  6D00 00AA                410                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140E                           411  
0000140E  B83C 0039                412                      CMP.B   #$39,D4
00001412  6F00 0026                413                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001416                           414  
00001416  B83C 0041                415                      CMP.B   #$41,D4
0000141A  6D00 009A                416                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000141E                           417  
0000141E  B83C 0046                418                      CMP.B   #$46,D4
00001422  6F00 0016                419                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001426                           420  
00001426  B83C 0061                421                      CMP.B   #$61,D4
0000142A  6D00 008A                422                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000142E                           423  
0000142E  B83C 0066                424                      CMP.B   #$66,D4
00001432  6F00 0006                425                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001436                           426  
00001436  6000 007E                427                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
0000143A                           428  
0000143A                           429  Fn_UI_ChkHexDone    ** Check if at end of loop
0000143A                           430  
0000143A  5203                     431                      ADDI.B  #1,D3                   * Increment loop counter
0000143C                           432  
0000143C                           433                      ** Insert ascii value into temp address
0000143C  1A04                     434                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000143E  4EB9 00001996            435                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001444  DC05                     436                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001446  B63C 0008                437                      CMP.B   #8,D3                   * To shift or not to shift
0000144A  6D00 0006                438                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000144E  6000 0004                439                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001452  E986                     440  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001454                           441  
00001454                           442  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001454  B63C 0008                443                      CMP.B   #8,D3                   * Loop 8 times
00001458  66AA                     444                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
0000145A  6000 0002                445                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000145E                           446  
0000145E                           447  Fn_UI_SetVHex       ** Valid: hex values
0000145E  0C39 0000 00002C9B       448                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001466  6600 0006                449                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
0000146A  6000 0026                450                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000146E                           451  
0000146E                           452  Fn_UI_SetVHexI1     ** Set valid on input 1
0000146E  13FC 0000 00002C9B       453                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001476  23C6 00002C8E            454                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000147C  49F9 00002C8E            455                      LEA     adrValStart,A4
00001482  4BF9 00002C92            456                      LEA     adrStrStart,A5
00001488  4EB9 000019D4            457                      JSR     SR_HEX_STR              * Copy address value to string for display
0000148E  6000 FDB8                458                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001492                           459  
00001492                           460  Fn_UI_SetVHexI2     ** Set valid on input 2
00001492  13FC 0000 00002CA9       461                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
0000149A  23C6 00002C9C            462                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
000014A0  49F9 00002C9C            463                      LEA     adrValEnd,A4
000014A6  4BF9 00002CA0            464                      LEA     adrStrEnd,A5
000014AC  4EB9 000019D4            465                      JSR     SR_HEX_STR              * Copy address value to string for display
000014B2  6000 FD94                466                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
000014B6                           467  
000014B6                           468  Fn_UI_SetEHex       ** Error: hex values
000014B6  0C39 0000 00002C9B       469                      CMP.B   #0,adrStsStart
000014BE  6600 0006                470                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014C2  6000 000E                471                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014C6                           472  
000014C6                           473  Fn_UI_SetEHexI1     ** Set error on input 1
000014C6  13FC 0002 00002C9B       474                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014CE  6000 FD78                475                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014D2                           476  
000014D2                           477  Fn_UI_SetEHexI2     ** Set error on input 2
000014D2  13FC 0002 00002CA9       478                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014DA  6000 FD6C                479                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014DE                           480  
000014DE                           481  Fn_UI_ChkVal        ** Check address range, order
000014DE                           482                      **   Address automagic - will fix addresses if invalid input
000014DE                           483                      ** Note: addresses are unsigned; should not be less than zero
000014DE                           484                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014DE                           485                      ** Note: subtracting one from Start address if not even
000014DE                           486                      **       doesn't really matter if end address is even or odd
000014DE                           487                      ** ***************************************
000014DE                           488  
000014DE  2A39 00002C8E            489                      MOVE.L  adrValStart,D5
000014E4  2C39 00002C9C            490                      MOVE.L  adrValEnd,D6
000014EA                           491  
000014EA  BABC 00FFFFEC            492  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014F0  6200 0006                493                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014F4  6000 0008                494                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014F8                           495  
000014F8  2A3C 00FFFFEC            496  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014FE                           497  
000014FE  BCBC 00FFFFED            498  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
00001504  6200 0006                499                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
00001508  6000 0008                500                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
0000150C                           501  
0000150C  2C3C 00FFFFED            502  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
00001512                           503  
00001512  BA86                     504  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
00001514  6200 0006                505                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
00001518  6000 0008                506                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
0000151C                           507  
0000151C  2805                     508  Fn_UI_ChkValSwp     MOVE.L  D5,D4
0000151E  2A06                     509                      MOVE.L  D6,D5
00001520  2C04                     510                      MOVE.L  D4,D6
00001522                           511  
00001522                           512  FN_UI_ChkValSWrd    ** Check start for word boundry
00001522  1605                     513                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001524  183C 0002                514                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001528  86C4                     515                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
0000152A  4843                     516                      SWAP    D3                       * Swap for remainder (the modulo part)
0000152C  B63C 0000                517                      CMP.B   #0,D3                    * If zero, then even
00001530  6600 0006                518                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001534  6000 0004                519                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001538                           520  
00001538  5385                     521  Fn_UI_ChkValSOne    SUBI.L  #1,D5
0000153A                           522  
0000153A                           523  Fn_UI_Done          ** All done with input, time to go
0000153A                           524                      ** ***************************************
0000153A                           525  
0000153A  23C5 00002C8E            526                      MOVE.L  D5,adrValStart          * Move final address to Start
00001540  23C6 00002C9C            527                      MOVE.L  D6,adrValEnd            * Move final address to End
00001546                           528  
00001546                           529                      ** Clear screen
00001546  103C 000B                530                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000154A  323C FF00                531                      MOVE.W  #$FF00,D1               * Clear the screen
0000154E  4E4F                     532                      TRAP    #15
00001550                           533  
00001550  4E75                     534                      RTS
00001552                           535  
00001552                           536  ** -----------------------------------------------------------
00001552                           537  ** UI: Display Header
00001552                           538  ** -----------------------------------------------------------
00001552                           539  SR_DSP_HEADER
00001552                           540  
00001552                           541                      ** Header line 03
00001552  43F9 000030E3            542                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001558  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155C  4E4F                     544                      TRAP    #15                     * Display to screen
0000155E                           545  
0000155E                           546                      ** Header line 01
0000155E  43F9 00002E0C            547                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001564  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001568  4E4F                     549                      TRAP    #15                     * Display to screen
0000156A                           550  
0000156A                           551                      ** Header line 02
0000156A  43F9 00002E23            552                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
00001570  103C 000E                553                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001574  4E4F                     554                      TRAP    #15                     * Display to screen
00001576                           555  
00001576  43F9 00002C92            556                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000157C  103C 000E                557                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001580  4E4F                     558                      TRAP    #15                     * Display to screen
00001582                           559  
00001582  43F9 00002E31            560                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001588  103C 000E                561                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158C  4E4F                     562                      TRAP    #15
0000158E                           563  
0000158E  43F9 00002CA0            564                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001594  103C 000E                565                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001598  4E4F                     566                      TRAP    #15                     * Display to screen
0000159A                           567  
0000159A  43F9 00003118            568                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
000015A0  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015A4  4E4F                     570                      TRAP    #15                     * Display to screen
000015A6                           571  
000015A6                           572                      ** Header line 03
000015A6  43F9 000030E3            573                      LEA     msgLine,A1              * Loads MESSAGE into A1
000015AC  103C 000E                574                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015B0  4E4F                     575                      TRAP    #15                     * Display to screen
000015B2                           576  
000015B2  4E75                     577                      RTS
000015B4                           578  
000015B4                           579  ** -----------------------------------------------------------
000015B4                           580  ** UI: Display item
000015B4                           581  ** -----------------------------------------------------------
000015B4                           582  SR_DSP_DISPLAY
000015B4                           583                      ** Output buffer
000015B4                           584                      **   Need buffer for spacing issues
000015B4                           585                      **
000015B4  47F9 00002CC0            586                      LEA     opOutBuf,A3             * Reset pointer to output buffer
000015BA  16BC 0000                587                      MOVE.B  #$00,(A3)               * Insert NULL
000015BE                           588  
000015BE                           589                      ** Push opValAdr to opStrAdr
000015BE  49F9 00002CAE            590                      LEA     opValAdr,A4             * input hex
000015C4  4BF9 00002CB2            591                      LEA     opStrAdr,A5             * output string
000015CA  4EB9 000019D4            592                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015D0  49F9 00002CB2            593                      LEA     opStrAdr,A4
000015D6  4EB9 00001A06            594                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015DC                           595  
000015DC                           596                      ** Instruction or DATA redirector
000015DC                           597                      **
000015DC  0C39 0001 00002CAD       598                      CMP.B   #1, opErr               * Check instruction type
000015E4  6700 0006                599                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015E8  6000 001E                600                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015EC                           601  
000015EC                           602  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015EC                           603                      **
000015EC                           604  
000015EC                           605                      ** Space
000015EC  49F9 0000311F            606                      LEA     opSpace,A4
000015F2  4EB9 00001A06            607                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F8                           608  
000015F8                           609                      ** Instruction name
000015F8  49F9 00002D3B            610                      LEA     opNam_DATA,A4
000015FE  4EB9 00001A06            611                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001604                           612  
00001604  6000 037E                613                      BRA     Fn_Dsp_Done
00001608                           614  
00001608                           615  Fn_Dsp_Instr        ** Process instruction
00001608                           616                      **
00001608                           617  
00001608                           618                      ** Space
00001608  49F9 0000311F            619                      LEA     opSpace,A4
0000160E  4EB9 00001A06            620                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001614                           621  
00001614                           622                      ** Instruction name
00001614  2879 00002D10            623                      MOVE.L  opPtrNam,A4
0000161A  4EB9 00001A06            624                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001620                           625  
00001620                           626                      ** Instruciton size
00001620                           627                      **
00001620  0C39 0000 00002D14       628                      CMP.B   #0,opValSiz
00001628  6700 001E                629                      BEQ     Fn_DSP_SizB             * Size is Byte
0000162C  0C39 0001 00002D14       630                      CMP.B   #1,opValSiz
00001634  6700 0022                631                      BEQ     Fn_DSP_SizW             * Size is Word
00001638  0C39 0002 00002D14       632                      CMP.B   #2,opValSiz
00001640  6700 0026                633                      BEQ     Fn_DSP_SizL             * Size is Long
00001644  6000 003E                634                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001648                           635  
00001648  49F9 00002DAC            636  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000164E  4EB9 00001A06            637                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001654  6000 0022                638                      BRA     Fn_DSP_OPR1
00001658                           639  
00001658  49F9 00002DAF            640  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000165E  4EB9 00001A06            641                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001664  6000 0012                642                      BRA     Fn_DSP_OPR1
00001668                           643  
00001668  49F9 00002DB2            644  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000166E  4EB9 00001A06            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001674  6000 0002                646                      BRA     Fn_DSP_OPR1
00001678                           647  
00001678                           648  Fn_DSP_OPR1         ** Display First Operand
00001678  49F9 00003122            649                      LEA     opTab,A4                * Tab (or calculated spaces)
0000167E  4EB9 00001A06            650                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001684                           651  
00001684                           652  Fn_DSP_DTA1         ** Data 1 (source)
00001684                           653                      ** **************************************************
00001684                           654                      **
00001684                           655  
00001684                           656                      ** Check if source mode set (may not have a source)
00001684  0C39 00FF 00002D1A       657                      CMP.B   #$FF,opDta1
0000168C  6700 017C                658                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
00001690                           659  
00001690                           660                      ** Check source mode
00001690                           661                      **
00001690  0C39 0000 00002D18       662                      CMP.B   #0,opSrcMod
00001698  6700 0042                663                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000169C  0C39 0001 00002D18       664                      CMP.B   #1,opSrcMod
000016A4  6700 004A                665                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
000016A8  0C39 0002 00002D18       666                      CMP.B   #2,opSrcMod
000016B0  6700 0052                667                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
000016B4  0C39 0003 00002D18       668                      CMP.B   #3,opSrcMod
000016BC  6700 0062                669                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
000016C0  0C39 0004 00002D18       670                      CMP.B   #4,opSrcMod
000016C8  6700 0076                671                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016CC  0C39 0007 00002D18       672                      CMP.B   #7,opSrcMod
000016D4  6700 008A                673                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016D8                           674  
000016D8  6000 0114                675                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016DC                           676  
000016DC                           677  Fn_DSP_DTA1_00      ** Handling data mode 0
000016DC  16FC 0044                678                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016E0  1639 00002D17            679                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016E6  0603 0030                680                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016EA  16C3                     681                      MOVE.B  D3,(A3)+                * Insert Register value
000016EC  6000 0110                682                      BRA     Fn_DSP_OPR2             * Display data 2
000016F0                           683  
000016F0                           684  Fn_DSP_DTA1_01      ** Handling data mode 1
000016F0  16FC 0041                685                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016F4  1639 00002D17            686                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016FA  0603 0030                687                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016FE  16C3                     688                      MOVE.B  D3,(A3)+                * Insert Register value
00001700  6000 00FC                689                      BRA     Fn_DSP_OPR2             * Display data 2
00001704                           690  
00001704                           691  Fn_DSP_DTA1_02      ** Handling data mode 2
00001704  16FC 0028                692                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001708  16FC 0041                693                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000170C  1639 00002D17            694                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001712  0603 0030                695                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001716  16C3                     696                      MOVE.B  D3,(A3)+                * Insert Register value
00001718  16FC 0029                697                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000171C  6000 00E0                698                      BRA     Fn_DSP_OPR2             * Display data 2
00001720                           699  
00001720                           700  Fn_DSP_DTA1_03      ** Handling data mode 3
00001720  16FC 0028                701                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001724  16FC 0041                702                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001728  1639 00002D17            703                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000172E  0603 0030                704                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001732  16C3                     705                      MOVE.B  D3,(A3)+                * Insert Register value
00001734  16FC 0029                706                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001738  16FC 002B                707                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000173C  6000 00C0                708                      BRA     Fn_DSP_OPR2             * Display data 2
00001740                           709  
00001740                           710  Fn_DSP_DTA1_04      ** Handling data mode 4
00001740  16FC 002D                711                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001744  16FC 0028                712                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001748  16FC 0041                713                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000174C  1639 00002D17            714                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001752  0603 0030                715                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001756  16C3                     716                      MOVE.B  D3,(A3)+                * Insert Register value
00001758  16FC 0029                717                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000175C  6000 00A0                718                      BRA     Fn_DSP_OPR2             * Display data 2
00001760                           719  
00001760                           720  Fn_DSP_DTA1_07      ** Handling data mode 7
00001760  0C39 0000 00002D1E       721                      CMP.B   #0,opDta1T
00001768  6700 001E                722                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000176C  0C39 0001 00002D1E       723                      CMP.B   #1,opDta1T
00001774  6700 0034                724                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001778  0C39 0002 00002D1E       725                      CMP.B   #2,opDta1T
00001780  6700 004A                726                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001784                           727  
00001784  6000 0068                728                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001788                           729  
00001788                           730  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001788  49F9 00002D1A            731                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002D25            732                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019D4            733                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002D25            734                      LEA     opStrDtaWrd,A4
000017A0  4EB9 00001A06            735                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0056                736                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           737  
000017AA                           738  Fn_DSP_DTA1_WRD     ** Display data Word
000017AA  49F9 00002D1A            739                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002D25            740                      LEA     opStrDtaWrd,A5          * output string
000017B6  4EB9 000019D4            741                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002D25            742                      LEA     opStrDtaWrd,A4
000017C2  4EB9 00001A06            743                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0034                744                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           745  
000017CC                           746  Fn_DSP_DTA1_LNG     ** Display data Long
000017CC  49F9 00002D1A            747                      LEA     opDta1,A4               * input hex
000017D2  4BF9 00002D2A            748                      LEA     opStrDtaLng,A5          * output string
000017D8  4EB9 000019D4            749                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017DE  49F9 00002D2A            750                      LEA     opStrDtaLng,A4
000017E4  4EB9 00001A06            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017EA  6000 0012                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017EE                           753  
000017EE                           754  Fn_DSP_DTA1_ERR     ** Something is messed up
000017EE  49F9 00002E06            755                      LEA     msgErr,A4
000017F4  4EB9 00001A06            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017FA  6000 0002                757                      BRA     Fn_DSP_OPR2             * Display data 2
000017FE                           758  
000017FE                           759  Fn_DSP_OPR2         ** Display Second Operand
000017FE  49F9 0000311B            760                      LEA     opComma,A4              * Comma
00001804  4EB9 00001A06            761                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000180A                           762  
0000180A                           763  Fn_DSP_DTA2         ** Data 2 (destination)
0000180A                           764                      ** **************************************************
0000180A                           765                      **
0000180A                           766  
0000180A                           767                      ** Check if destination mode set (may not have a destination)
0000180A  0C39 00FF 00002D16       768                      CMP.B   #$FF,opDstMod
00001812  6700 0170                769                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
00001816                           770  
00001816  0C39 0000 00002D16       771                      CMP.B   #0,opDstMod
0000181E  6700 0042                772                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001822  0C39 0001 00002D16       773                      CMP.B   #1,opDstMod
0000182A  6700 004A                774                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000182E  0C39 0002 00002D16       775                      CMP.B   #2,opDstMod
00001836  6700 0052                776                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
0000183A  0C39 0003 00002D16       777                      CMP.B   #3,opDstMod
00001842  6700 0062                778                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001846  0C39 0004 00002D16       779                      CMP.B   #4,opDstMod
0000184E  6700 0076                780                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001852  0C39 0007 00002D16       781                      CMP.B   #7,opDstMod
0000185A  6700 008A                782                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000185E                           783  
0000185E  6000 0114                784                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001862                           785  
00001862                           786  Fn_DSP_DTA2_00      ** Handling mode 0
00001862  16FC 0044                787                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001866  1639 00002D15            788                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000186C  0603 0030                789                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001870  16C3                     790                      MOVE.B  D3,(A3)+                * Insert Register value
00001872  6000 0110                791                      BRA     Fn_DSP_DONE             * Done with display
00001876                           792  
00001876                           793  Fn_DSP_DTA2_01      ** Handling mode 1
00001876  16FC 0041                794                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000187A  1639 00002D15            795                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001880  0603 0030                796                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001884  16C3                     797                      MOVE.B  D3,(A3)+                * Insert Register value
00001886  6000 00FC                798                      BRA     Fn_DSP_DONE             * Done with display
0000188A                           799  
0000188A                           800  Fn_DSP_DTA2_02      ** Handling mode 2
0000188A  16FC 0028                801                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000188E  16FC 0041                802                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001892  1639 00002D15            803                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001898  0603 0030                804                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000189C  16C3                     805                      MOVE.B  D3,(A3)+                * Insert Register value
0000189E  16FC 0029                806                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018A2  6000 00E0                807                      BRA     Fn_DSP_DONE             * Done with display
000018A6                           808  
000018A6                           809  Fn_DSP_DTA2_03      ** Handling mode 3
000018A6  16FC 0028                810                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AA  16FC 0041                811                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018AE  1639 00002D15            812                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
000018B4  0603 0030                813                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018B8  16C3                     814                      MOVE.B  D3,(A3)+                * Insert Register value
000018BA  16FC 0029                815                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018BE  16FC 002B                816                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018C2  6000 00C0                817                      BRA     Fn_DSP_DONE             * Done with display
000018C6                           818  
000018C6                           819  Fn_DSP_DTA2_04      ** Handling mode 4
000018C6  16FC 002D                820                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018CA  16FC 0028                821                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018CE  16FC 0041                822                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018D2  1639 00002D17            823                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018D8  0603 0030                824                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018DC  16C3                     825                      MOVE.B  D3,(A3)+                * Insert Register value
000018DE  16FC 0029                826                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018E2  6000 00A0                827                      BRA     Fn_DSP_DONE             * Done with display
000018E6                           828  
000018E6                           829  Fn_DSP_DTA2_07      ** Handling mode 8
000018E6  0C39 0000 00002D24       830                      CMP.B   #0,opDta2T
000018EE  6700 001E                831                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018F2  0C39 0001 00002D24       832                      CMP.B   #1,opDta2T
000018FA  6700 0034                833                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018FE  0C39 0002 00002D24       834                      CMP.B   #2,opDta2T
00001906  6700 004A                835                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
0000190A                           836  
0000190A  6000 0068                837                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
0000190E                           838  
0000190E                           839  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
0000190E  49F9 00002D20            840                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002D25            841                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019D4            842                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002D25            843                      LEA     opStrDtaWrd,A4
00001926  4EB9 00001A06            844                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0056                845                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           846  
00001930                           847  Fn_DSP_DTA2_WRD     ** Display data Word
00001930  49F9 00002D20            848                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002D25            849                      LEA     opStrDtaWrd,A5          * output string
0000193C  4EB9 000019D4            850                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002D25            851                      LEA     opStrDtaWrd,A4
00001948  4EB9 00001A06            852                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0034                853                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           854  
00001952                           855  Fn_DSP_DTA2_LNG     ** Display data Long
00001952  49F9 00002D20            856                      LEA     opDta2,A4               * input hex
00001958  4BF9 00002D2A            857                      LEA     opStrDtaLng,A5          * output string
0000195E  4EB9 000019D4            858                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001964  49F9 00002D2A            859                      LEA     opStrDtaLng,A4
0000196A  4EB9 00001A06            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001970  6000 0012                861                      BRA     Fn_DSP_DONE             * Display data 2
00001974                           862  
00001974                           863  Fn_DSP_DTA2_ERR     ** Something is messed up
00001974  49F9 00002E06            864                      LEA     msgErr,A4
0000197A  4EB9 00001A06            865                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001980  6000 0002                866                      BRA     Fn_DSP_DONE             * Display data 2
00001984                           867  
00001984                           868  Fn_Dsp_Done         ** Done with instruction display
00001984  16BC 0000                869                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001988  43F9 00002CC0            870                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000198E  103C 000D                871                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001992  4E4F                     872                      TRAP    #15
00001994                           873  
00001994                           874                      ** We're all done here - time to go
00001994                           875                      **
00001994  4E75                     876                      RTS                             * Return back to caller
00001996                           877  
00001996                           878  ** -----------------------------------------------------------
00001996                           879  ** Convert single ASCII value to hexadecimal
00001996                           880  **    ASCII values should be in range 0-9, A-F
00001996                           881  **
00001996                           882  ** Parameters
00001996                           883  **   D5 - Hex value to assess. Converted value returned in D5
00001996                           884  **
00001996                           885  ** Example:
00001996                           886  **   $30 -> $0
00001996                           887  **   $41 -> $A
00001996                           888  **   $61 -> $A
00001996                           889  ** -----------------------------------------------------------
00001996                           890  SR_ASCII_HEX
00001996  BA3C 0039                891                      CMP.B   #$39,D5
0000199A  6F00 000E                892                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000199E  BA3C 0046                893                      CMP.B   #$46,D5
000019A2  6F00 000C                894                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
000019A6  6000 000E                895                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
000019AA                           896  
000019AA  0405 0030                897  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
000019AE  4E75                     898                      RTS
000019B0  0405 0037                899  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
000019B4  4E75                     900                      RTS
000019B6  0405 0057                901  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
000019BA  4E75                     902                      RTS
000019BC                           903  
000019BC                           904  ** -----------------------------------------------------------
000019BC                           905  ** Convert single hexadecimal value to ASCII
000019BC                           906  **    hexadecimal values should be in range 0-9, A-F
000019BC                           907  **
000019BC                           908  ** Parameters
000019BC                           909  **   D5 - Hex value to assess. Converted value returned in D5
000019BC                           910  **
000019BC                           911  ** Example:
000019BC                           912  **   $0 -> $30
000019BC                           913  **   $A -> $41
000019BC                           914  **   $a -> $41
000019BC                           915  **
000019BC                           916  ** Note: this function is case insensitive an $a = $A = $41 etc.
000019BC                           917  ** -----------------------------------------------------------
000019BC                           918  SR_HEX_ASCII
000019BC  BA3C 0009                919                      CMP.B   #$9,D5
000019C0  6F00 0006                920                      BLE     Fn_HEX_Num              * Hex $0-$9
000019C4  6000 0008                921                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019C8                           922  
000019C8  0605 0030                923  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019CC  4E75                     924                      RTS
000019CE  0605 0037                925  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019D2  4E75                     926                      RTS
000019D4                           927  
000019D4                           928  ** -----------------------------------------------------------
000019D4                           929  ** Copy hexadecimal value to string
000019D4                           930  **
000019D4                           931  ** Parameters
000019D4                           932  **   A4 - Pointer to value copying from
000019D4                           933  **   A5 - Pointer to defined constant
000019D4                           934  **
000019D4                           935  ** Data registers
000019D4                           936  **   D4 - Current byte      (hex value A4)
000019D4                           937  **   D5 - Temp byte         (hex value or string)
000019D4                           938  **   D6 - Number to shift
000019D4                           939  **
000019D4                           940  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019D4                           941  **
000019D4                           942  ** -----------------------------------------------------------
000019D4                           943  SR_HEX_STR
000019D4                           944  
000019D4  181C                     945  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019D6                           946  
000019D6  1A15                     947                      MOVE.B  (A5),D5
000019D8  BA3C 0000                948                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019DC  6700 0022                949                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019E0                           950  
000019E0                           951                      ** First Hex value (high order value)
000019E0  1A04                     952                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019E2  1C3C 0004                953                      MOVE.B  #4,D6
000019E6  EC2D                     954                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019E8  4EB8 19BC                955                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019EC  1AC5                     956                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019EE                           957  
000019EE                           958                      ** Second Hex value (low order value)
000019EE  1A04                     959                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019F0  1C3C 0004                960                      MOVE.B  #4,D6
000019F4  ED2D                     961                      LSL.B   D6,D5
000019F6  EC2D                     962                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019F8  4EB8 19BC                963                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019FC  1AC5                     964                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019FE                           965  
000019FE  60D4                     966                      BRA     Fn_Hex_Str_Loop
00001A00                           967  Fn_Hex_Str_Done
00001A00  1AFC 0000                968                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
00001A04                           969  
00001A04  4E75                     970                      RTS
00001A06                           971  
00001A06                           972  ** -----------------------------------------------------------
00001A06                           973  ** Copy string to output buffer @ A3
00001A06                           974  **
00001A06                           975  ** Parameters
00001A06                           976  **   A4 - Pointer to string copying from
00001A06                           977  **
00001A06                           978  ** Data registers
00001A06                           979  **   D5 - Temp byte         (hex value or string)
00001A06                           980  ** -----------------------------------------------------------
00001A06                           981  SR_CPY_STR_BUF
00001A06                           982  
00001A06  1A14                     983  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
00001A08  BA3C 0000                984                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
00001A0C  6700 0006                985                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
00001A10                           986  
00001A10  16DC                     987                      MOVE.B  (A4)+,(A3)+
00001A12  60F2                     988                      BRA     Fn_CPY_STR_Loop
00001A14                           989  
00001A14  4E75                     990  Fn_CPY_STR_Done     RTS
00001A16                           991  
00001A16                           992  ** -----------------------------------------------------------
00001A16                           993  ** Length of string output buffer
00001A16                           994  ** -----------------------------------------------------------
00001A16                           995  SR_CNT_STR_BUF
00001A16                           996  
00001A16  4E75                     997                      RTS
00001A18                           998  
00001A18                           999  ** -----------------------------------------------------------
00001A18                          1000  ** Includes: Subroutines etc.
00001A18                          1001  ** -----------------------------------------------------------
00001A18                          1002                      INCLUDE 'SR_IDX.X68'
00001A18                          1003  
00001A18                          1004  
00001A18                          1005  SR_IDX
00001A18                          1006  
00001A18  4E75                    1007                RTS
00001A18  4E75                    1008  -------------------- end include --------------------
00001A1A                          1009                      INCLUDE 'SR_ID3.X68'
00001A1A                          1010  
00001A1A                          1011  
00001A1A                          1012  SR_ID3
00001A1A                          1013  
00001A1A                          1014                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
00001A1A                          1015  
00001A1A                          1016  
00001A1A                          1017                      ** ***************************************
00001A1A                          1018                      ** Read first 4 bits
00001A1A                          1019                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
00001A1A                          1020                      ** Note: most instructions will be in this format 3,3,3,3
00001A1A                          1021                      **    I think there is only one instrction that is 4,8
00001A1A                          1022                      **
00001A1A                          1023                      ** ***************************************
00001A1A  3639 00002CAA           1024                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A20  183C 000C               1025                      MOVE.B  #12,D4
00001A24  E86B                    1026                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A26  13C3 00002CAC           1027                      MOVE.B  D3, opID
00001A2C                          1028  
00001A2C                          1029                      ** Read next 3 bits
00001A2C                          1030                      **
00001A2C  3639 00002CAA           1031                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A32  183C 0004               1032                      MOVE.B  #4, D4
00001A36  E96B                    1033                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A38  183C 000D               1034                      MOVE.B  #13,D4
00001A3C  E86B                    1035                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A3E  13C3 00002D15           1036                      MOVE.B  D3, opDstReg
00001A44                          1037  
00001A44                          1038                      ** Read next 3 bits
00001A44                          1039                      **
00001A44  3639 00002CAA           1040                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A4A  183C 0007               1041                      MOVE.B  #7, D4
00001A4E  E96B                    1042                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A50  183C 000D               1043                      MOVE.B  #13,D4
00001A54  E86B                    1044                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A56  13C3 00002D16           1045                      MOVE.B  D3, opDstMod
00001A5C                          1046  
00001A5C                          1047                      ** Read next 3 bits
00001A5C                          1048                      **
00001A5C  3639 00002CAA           1049                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A62  183C 000A               1050                      MOVE.B  #10, D4
00001A66  E96B                    1051                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A68  183C 000D               1052                      MOVE.B  #13,D4
00001A6C  E86B                    1053                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A6E  13C3 00002D18           1054                      MOVE.B  D3, opSrcMod
00001A74                          1055  
00001A74                          1056                      ** Read next 3 bits
00001A74                          1057                      **
00001A74  3639 00002CAA           1058                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A7A  183C 000D               1059                      MOVE.B  #13, D4
00001A7E  E96B                    1060                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A80  183C 000D               1061                      MOVE.B  #13,D4
00001A84  E86B                    1062                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A86  13C3 00002D17           1063                      MOVE.B  D3, opSrcReg
00001A8C                          1064  
00001A8C                          1065                      ** ***************************************
00001A8C                          1066                      ** Verify this is MOVE or MOVEA
00001A8C                          1067                      **
00001A8C                          1068                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A8C                          1069                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A8C                          1070                      **
00001A8C                          1071                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A8C                          1072                      **
00001A8C                          1073                      ** ***************************************
00001A8C  0C39 0001 00002D16      1074                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A94  6700 0016               1075                      BEQ     Fn_ID3_Ins02                * Set as instruction 0 MOVEA
00001A98  6000 0002               1076                      BRA     Fn_ID3_Ins01                * Set as instruction 1 MOVE
00001A9C                          1077  
00001A9C  47F9 00002D40           1078  Fn_ID3_Ins01        LEA     opNam_MOVE,A3
00001AA2  23CB 00002D10           1079                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA8  6000 001A               1080                      BRA     Fn_ID3_Verify
00001AAC                          1081  
00001AAC  0C39 0001 00002CAC      1082  Fn_ID3_Ins02        CMP.B   #1, opID
00001AB4  6700 01A4               1083                      BEQ     Fn_ID3_Error               * MOVEA cannot have opID = 1 (byte)
00001AB8  47F9 00002D45           1084                      LEA     opNam_MOVEA,A3
00001ABE  23CB 00002D10           1085                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AC4                          1086  
00001AC4                          1087                      ** ***************************************
00001AC4                          1088                      ** Verify other instruction parameters are correct
00001AC4                          1089                      **
00001AC4                          1090                      **    DstMod = 0 to 7
00001AC4                          1091                      **    DstReg = 0 to 7
00001AC4                          1092                      **    SrcMod = 0 to 7
00001AC4                          1093                      **    SrcReg = 0 to 7
00001AC4                          1094                      **
00001AC4                          1095                      ** ***************************************
00001AC4  0C39 0000 00002D16      1096  Fn_ID3_Verify       CMP.B   #0, opDstMod                * Destination mode is >= 0
00001ACC  6D00 018C               1097                      BLT     Fn_ID3_Error
00001AD0  0C39 0007 00002D16      1098                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AD8  6E00 0180               1099                      BGT     Fn_ID3_Error
00001ADC  0C39 0000 00002D15      1100                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AE4  6D00 0174               1101                      BLT     Fn_ID3_Error
00001AE8  0C39 0007 00002D15      1102                      CMP.B   #7, opDstReg                * Destination register <= 7
00001AF0  6E00 0168               1103                      BGT     Fn_ID3_Error
00001AF4                          1104  
00001AF4  0C39 0000 00002D18      1105                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001AFC  6D00 015C               1106                      BLT     Fn_ID3_Error
00001B00  0C39 0007 00002D18      1107                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001B08  6E00 0150               1108                      BGT     Fn_ID3_Error
00001B0C  0C39 0000 00002D17      1109                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001B14  6D00 0144               1110                      BLT     Fn_ID3_Error
00001B18  0C39 0007 00002D17      1111                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001B20  6E00 0138               1112                      BGT     Fn_ID3_Error
00001B24                          1113  
00001B24                          1114                      ** ***************************************
00001B24                          1115                      ** Set instruction size - the .B,.W,.L part
00001B24                          1116                      ** Note: size set by opID only for MOVE, MOVEA
00001B24                          1117                      **       other instructions use 3 bits for size
00001B24                          1118                      ** ***************************************
00001B24  0C39 0001 00002CAC      1119                      CMP.B   #1, opID                    * Instruction size is Byte
00001B2C  6700 001A               1120                      BEQ     Fn_ID3_SizB
00001B30  0C39 0003 00002CAC      1121                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B38  6700 001A               1122                      BEQ     Fn_ID3_SizW
00001B3C  0C39 0002 00002CAC      1123                      CMP.B   #2, opID                    * Instruction size is Long
00001B44  6700 001A               1124                      BEQ     Fn_ID3_SizL
00001B48  13FC 0000 00002D14      1125  Fn_ID3_SizB         MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B50  6000 001A               1126                      BRA     Fn_ID3_SrcMod
00001B54  13FC 0001 00002D14      1127  Fn_ID3_SizW         MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B5C  6000 000E               1128                      BRA     Fn_ID3_SrcMod
00001B60  13FC 0002 00002D14      1129  Fn_ID3_SizL         MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B68  6000 0002               1130                      BRA     Fn_ID3_SrcMod
00001B6C                          1131  
00001B6C                          1132                      ** ***************************************
00001B6C                          1133                      ** Grab extra DATA if needed
00001B6C                          1134                      **
00001B6C                          1135                      **    If DstMod = 7
00001B6C                          1136                      **       DstReg = 0 (get Word)
00001B6C                          1137                      **       DstReg = 1 (get Long)
00001B6C                          1138                      **
00001B6C                          1139                      **    If SrcMod = 7
00001B6C                          1140                      **       SrcReg = 0 (get Word)
00001B6C                          1141                      **       SrcReg = 1 (get Long)
00001B6C                          1142                      **       SrcReg = 4
00001B6C                          1143                      **          MOVE.B, MOVE.W (get Word)
00001B6C                          1144                      **          MOVE.L         (get Long)
00001B6C                          1145                      **
00001B6C                          1146                      ** SOURCE
00001B6C                          1147                      **
00001B6C                          1148                      ** ***************************************
00001B6C  0C39 0007 00002D18      1149  Fn_ID3_SrcMod       CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B74  6700 0006               1150                      BEQ     Fn_ID3_ChkSrcReg            * Check source register
00001B78  6000 0088               1151                      BRA     Fn_ID3_ChkDstMod           * Source not 7, now check destination Mod
00001B7C  0C39 0000 00002D17      1152  Fn_ID3_ChkSrcReg    CMP.B   #0, opSrcReg                 * Check is source register is 0
00001B84  6700 0058               1153                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001B88  0C39 0001 00002D17      1154                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B90  6700 005E               1155                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001B94  0C39 0004 00002D17      1156                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B9C  6700 0006               1157                      BEQ     Fn_ID3_DtaSrcImd            * Load first word into word one
00001BA0  6000 00B8               1158                      BRA     FN_ID3_Error                * Invalid register value
00001BA4                          1159  
00001BA4                          1160                      ** Note: Checking immediate value
00001BA4                          1161                      **       opID as size is specific to MOVE, MOVEA
00001BA4                          1162                      **       other instructions will use 3 bits to set size, not part of ID
00001BA4                          1163                      **
00001BA4  0C39 0001 00002CAC      1164  Fn_ID3_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00001BAC  6700 001E               1165                      BEQ     Fn_ID3_DtaSrcByt            * Load next byte
00001BB0  0C39 0003 00002CAC      1166                      CMP.B   #3, opID                    * opID = 3 - size is word
00001BB8  6700 0024               1167                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001BBC  0C39 0002 00002CAC      1168                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BC4  6700 002A               1169                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001BC8  6000 0090               1170                      BRA     Fn_ID3_Error                * Invalid opID (this should never happen)
00001BCC                          1171  
00001BCC  33DA 00002D1A           1172  Fn_ID3_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BD2  13FC 0000 00002D1E      1173                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BDA  6000 0026               1174                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BDE  33DA 00002D1A           1175  Fn_ID3_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BE4  13FC 0001 00002D1E      1176                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BEC  6000 0014               1177                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BF0  23DA 00002D1A           1178  Fn_ID3_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BF6  13FC 0002 00002D1E      1179                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BFE  6000 0002               1180                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001C02                          1181  
00001C02                          1182                      ** DESTINATION
00001C02                          1183                      **
00001C02  0C39 0007 00002D16      1184  Fn_ID3_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00001C0A  6700 0006               1185                      BEQ     Fn_ID3_ChkDstReg            * Check destination register
00001C0E  6000 0042               1186                      BRA     Fn_ID3_Done                 * Destination not 7, done with data
00001C12  0C39 0000 00002D15      1187  Fn_ID3_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00001C1A  6700 0012               1188                      BEQ     Fn_ID3_DtaDstWrd            * Load next word
00001C1E  0C39 0001 00002D15      1189                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C26  6700 0018               1190                      BEQ     Fn_ID3_DtaDstLng            * Load next long
00001C2A  6000 002E               1191                      BRA     fn_ID3_Error                * Invalid registration Mode
00001C2E                          1192  
00001C2E  33DA 00002D20           1193  Fn_ID3_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C34  13FC 0001 00002D24      1194                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C3C  6000 0014               1195                      BRA     Fn_ID3_Done
00001C40  23DA 00002D20           1196  Fn_ID3_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C46  13FC 0002 00002D24      1197                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C4E  6000 0002               1198                      BRA     Fn_ID3_Done
00001C52                          1199  
00001C52  13FC 0000 00002CAD      1200  Fn_ID3_Done         MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C5A                          1201  
00001C5A                          1202  Fn_ID3_Error                                           * Exit out if error - main subroutine will handle DATA
00001C5A                          1203                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C5A  4E75                    1204                      RTS                                 * Return to main
00001C5A  4E75                    1205  -------------------- end include --------------------
00001C5C                          1206                      INCLUDE 'SR_ID4.X68'
00001C5C                          1207  
00001C5C                          1208  SR_ID4              * This is to grab the first four that are already set, ID4
00001C5C  3639 00002CAA           1209                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C62  183C 000C               1210                      MOVE.B  #12,D4
00001C66  E86B                    1211                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C68  13C3 00002CAC           1212                      MOVE.B  D3, opID        
00001C6E                          1213                      
00001C6E                          1214                      * Read next 3 bits into D3
00001C6E  3639 00002CAA           1215                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C74  183C 0004               1216                      MOVE.B  #4, D4
00001C78  E96B                    1217                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C7A  183C 000D               1218                      MOVE.B  #13,D4
00001C7E  E86B                    1219                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C80  13C3 00002D15           1220                      MOVE.B  D3, opDstReg
00001C86                          1221                      
00001C86                          1222                      * Read next 3 bits into D3
00001C86  3639 00002CAA           1223                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C8C  183C 0007               1224                      MOVE.B  #7, D4
00001C90  E96B                    1225                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C92  183C 000D               1226                      MOVE.B  #13,D4
00001C96  E86B                    1227                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C98  13C3 00002D16           1228                      MOVE.B  D3, opDstMod
00001C9E                          1229  
00001C9E                          1230                      ** Read next 3 bits
00001C9E                          1231                      **
00001C9E  3639 00002CAA           1232                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CA4  183C 000A               1233                      MOVE.B  #10, D4
00001CA8  E96B                    1234                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CAA  183C 000D               1235                      MOVE.B  #13,D4
00001CAE  E86B                    1236                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CB0  13C3 00002D18           1237                      MOVE.B  D3, opSrcMod
00001CB6                          1238  
00001CB6                          1239                      ** Read next 3 bits
00001CB6                          1240                      **
00001CB6  3639 00002CAA           1241                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CBC  183C 000D               1242                      MOVE.B  #13, D4
00001CC0  E96B                    1243                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CC2  183C 000D               1244                      MOVE.B  #13,D4
00001CC6  E86B                    1245                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CC8  13C3 00002D17           1246                      MOVE.B  D3, opSrcReg
00001CCE                          1247                      
00001CCE                          1248                      ** ***************************************
00001CCE                          1249                      ** Verify instruction
00001CCE                          1250                      **
00001CCE                          1251                      ** JSR: If DstReg=7, DstMod=2 
00001CCE                          1252                      ** LEA: If DstReg=0-7, DstMod=7
00001CCE                          1253                      ** MOVEM:
00001CCE                          1254                      **    RegToMem: DestReg=4, DestMod=2,3
00001CCE                          1255                      **    MemToReg: DestReg=6, DestMod=2,3
00001CCE                          1256                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CCE                          1257                      ** NOT: If DstReg=3, DstMod=0-2
00001CCE                          1258                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CCE                          1259                      **
00001CCE                          1260                      ** ***************************************
00001CCE  0C39 0000 00002D16      1261                      CMP.B   #0, opDstMod
00001CD6  6700 02EA               1262                      BEQ     Fn_ID4_NOT
00001CDA  0C39 0001 00002D16      1263                      CMP.B   #1, opDstMod
00001CE2  6700 002A               1264                      BEQ     Fn_ID4_CheckD1
00001CE6  0C39 0002 00002D16      1265                      CMP.B   #2, opDstMod
00001CEE  6700 0042               1266                      BEQ     Fn_ID4_CheckD2
00001CF2  0C39 0003 00002D16      1267                      CMP.B   #3, opDstMod
00001CFA  6700 0066               1268                      BEQ     Fn_ID4_CheckD3
00001CFE  0C39 0007 00002D16      1269                      CMP.B   #7, opDstMod
00001D06  6700 011E               1270                      BEQ     Fn_ID4_LEA
00001D0A  6000 03D2               1271                      BRA     Fn_ID4_Error
00001D0E                          1272                      
00001D0E                          1273  Fn_ID4_CheckD1
00001D0E  0C39 0003 00002D15      1274                      CMP.B   #3, opDstReg
00001D16  6700 02AA               1275                      BEQ     Fn_ID4_NOT
00001D1A  0C39 0001 00002D17      1276                      CMP.B   #1, opSrcReg
00001D22  6700 025E               1277                      BEQ     Fn_ID4_NOP
00001D26  0C39 0005 00002D17      1278                      CMP.B   #5, opSrcReg
00001D2E  6700 02E8               1279                      BEQ     Fn_ID4_RTS
00001D32                          1280                      
00001D32                          1281  Fn_ID4_CheckD2
00001D32  0C39 0003 00002D15      1282                      CMP.B   #3, opDstReg
00001D3A  6700 0286               1283                      BEQ     Fn_ID4_NOT
00001D3E  0C39 0004 00002D15      1284                      CMP.B   #4, opDstReg
00001D46  6700 014E               1285                      BEQ     Fn_ID4_MOVEMRTOM
00001D4A  0C39 0006 00002D15      1286                      CMP.B   #6, opDstReg
00001D52  6700 01B2               1287                      BEQ     Fn_ID4_MOVEMMTOR
00001D56  0C39 0007 00002D15      1288                      CMP.B   #7, opDstReg
00001D5E  6700 001A               1289                      BEQ     Fn_ID4_JSR
00001D62                          1290  Fn_ID4_CheckD3
00001D62  0C39 0004 00002D15      1291                      CMP.B   #4, opDstReg
00001D6A  6700 012A               1292                      BEQ     Fn_ID4_MOVEMRTOM
00001D6E  0C39 0006 00002D15      1293                      CMP.B   #6, opDstReg
00001D76  6700 018E               1294                      BEQ     Fn_ID4_MOVEMMTOR
00001D7A                          1295  
00001D7A  47F9 00002D61           1296  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D80  23CB 00002D10           1297                      MOVE.L  A3, opPtrNam
00001D86                          1298                      
00001D86  0C39 0007 00002D15      1299  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D8E  6600 034E               1300                      BNE     Fn_ID4_Error
00001D92  0C39 0002 00002D16      1301                      CMP.B   #2, opDstMod
00001D9A  6600 0342               1302                      BNE     Fn_ID4_Error
00001D9E                          1303                      
00001D9E                          1304                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D9E  0C39 0000 00002D15      1305                      CMP.B   #0, opDstReg
00001DA6  6700 0336               1306                      BEQ     Fn_ID4_Error
00001DAA  0C39 0001 00002D15      1307                      CMP.B   #1, opDstReg
00001DB2  6700 032A               1308                      BEQ     Fn_ID4_Error
00001DB6  0C39 0003 00002D15      1309                      CMP.B   #3, opDstReg
00001DBE  6700 031E               1310                      BEQ     Fn_ID4_Error
00001DC2  0C39 0004 00002D15      1311                      CMP.B   #4, opDstReg
00001DCA  6700 0312               1312                      BEQ     Fn_ID4_Error
00001DCE                          1313                      
00001DCE                          1314                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DCE  0C39 0000 00002D18      1315                      CMP.B   #0, opSrcMod
00001DD6  6700 0306               1316                      BEQ     Fn_ID4_Error
00001DDA  0C39 0001 00002D18      1317                      CMP.B   #1, opSrcMod
00001DE2  6700 02FA               1318                      BEQ     Fn_ID4_Error
00001DE6  0C39 0003 00002D18      1319                      CMP.B   #3, opSrcMod
00001DEE  6700 02EE               1320                      BEQ     Fn_ID4_Error
00001DF2  0C39 0004 00002D18      1321                      CMP.B   #4, opSrcMod
00001DFA  6700 02E2               1322                      BEQ     Fn_ID4_Error
00001DFE                          1323                      
00001DFE                          1324                      * Make sure src reg is between 0-7
00001DFE  0C39 0000 00002D17      1325                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E06  6D00 02D6               1326                      BLT     Fn_ID4_Error
00001E0A  0C39 0007 00002D17      1327                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E12  6E00 02CA               1328                      BGT     Fn_ID4_Error
00001E16                          1329                      
00001E16  0C39 0007 00002D18      1330  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001E1E  6700 0238               1331                      BEQ     Fn_ID4_Data
00001E22  6000 02BC               1332                      BRA     Fn_ID4_Done
00001E26                          1333  
00001E26  47F9 00002D4B           1334  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E2C  23CB 00002D10           1335                      MOVE.L  A3, opPtrNam
00001E32                          1336                      
00001E32  0C39 0007 00002D16      1337  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E3A  6600 02A2               1338                      BNE     Fn_ID4_Error
00001E3E                          1339                      
00001E3E                          1340                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E3E  0C39 0000 00002D18      1341                      CMP.B   #0, opSrcMod
00001E46  6700 0296               1342                      BEQ     Fn_ID4_Error
00001E4A  0C39 0001 00002D18      1343                      CMP.B   #1, opSrcMod
00001E52  6700 028A               1344                      BEQ     Fn_ID4_Error
00001E56  0C39 0003 00002D18      1345                      CMP.B   #3, opSrcMod
00001E5E  6700 027E               1346                      BEQ     Fn_ID4_Error
00001E62  0C39 0004 00002D18      1347                      CMP.B   #4, opSrcMod
00001E6A  6700 0272               1348                      BEQ     Fn_ID4_Error
00001E6E                          1349                      
00001E6E                          1350                      * Make sure src reg is between 0-7
00001E6E  0C39 0000 00002D17      1351                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E76  6D00 0266               1352                      BLT     Fn_ID4_Error
00001E7A  0C39 0007 00002D17      1353                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E82  6E00 025A               1354                      BGT     Fn_ID4_Error
00001E86                          1355                      
00001E86  0C39 0007 00002D18      1356  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E8E  6700 01C8               1357                      BEQ     Fn_ID4_Data
00001E92  6000 024C               1358                      BRA     Fn_ID4_Done
00001E96                          1359  
00001E96  47F9 00002D53           1360  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E9C  23CB 00002D10           1361                      MOVE.L  A3, opPtrNam
00001EA2                          1362                      
00001EA2  0C39 0004 00002D15      1363  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001EAA  6600 0232               1364                      BNE     Fn_ID4_Error
00001EAE                          1365                      
00001EAE                          1366                      * Make sure dest mode is only 2 or 3
00001EAE  0C39 0003 00002D17      1367                      CMP.B   #3, opSrcReg                * Destination register > 2
00001EB6  6D00 0226               1368                      BLT     Fn_ID4_Error
00001EBA  0C39 0003 00002D17      1369                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EC2  6E00 021A               1370                      BGT     Fn_ID4_Error
00001EC6                          1371                      
00001EC6                          1372                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EC6  0C39 0000 00002D18      1373                      CMP.B   #0, opSrcMod
00001ECE  6700 020E               1374                      BEQ     Fn_ID4_Error
00001ED2  0C39 0001 00002D18      1375                      CMP.B   #1, opSrcMod
00001EDA  6700 0202               1376                      BEQ     Fn_ID4_Error
00001EDE  0C39 0003 00002D18      1377                      CMP.B   #3, opSrcMod
00001EE6  6700 01F6               1378                      BEQ     Fn_ID4_Error
00001EEA                          1379                      
00001EEA                          1380                      * Make sure src reg is between 0-7
00001EEA  0C39 0000 00002D17      1381                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001EF2  6D00 01EA               1382                      BLT     Fn_ID4_Error
00001EF6  0C39 0007 00002D17      1383                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EFE  6E00 01DE               1384                      BGT     Fn_ID4_Error
00001F02  6000 006E               1385                      BRA Fn_ID4_MOVEM_Src
00001F06                          1386  
00001F06  47F9 00002D53           1387  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001F0C  23CB 00002D10           1388                      MOVE.L  A3, opPtrNam
00001F12                          1389                      
00001F12  0C39 0006 00002D15      1390  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001F1A  6600 01C2               1391                      BNE     Fn_ID4_Error
00001F1E                          1392                      
00001F1E                          1393                      * Make sure dest mode is only 2 or 3
00001F1E  0C39 0003 00002D17      1394                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F26  6D00 01B6               1395                      BLT     Fn_ID4_Error
00001F2A  0C39 0003 00002D17      1396                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F32  6E00 01AA               1397                      BGT     Fn_ID4_Error
00001F36                          1398                      
00001F36                          1399                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F36  0C39 0000 00002D18      1400                      CMP.B   #0, opSrcMod
00001F3E  6700 019E               1401                      BEQ     Fn_ID4_Error
00001F42  0C39 0001 00002D18      1402                      CMP.B   #1, opSrcMod
00001F4A  6700 0192               1403                      BEQ     Fn_ID4_Error
00001F4E  0C39 0003 00002D18      1404                      CMP.B   #3, opSrcMod
00001F56  6700 0186               1405                      BEQ     Fn_ID4_Error
00001F5A                          1406                      
00001F5A                          1407                      * Make sure src reg is between 0-7
00001F5A  0C39 0000 00002D17      1408                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F62  6D00 017A               1409                      BLT     Fn_ID4_Error
00001F66  0C39 0007 00002D17      1410                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F6E  6E00 016E               1411                      BGT     Fn_ID4_Error
00001F72                          1412                      
00001F72  0C39 0007 00002D18      1413  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F7A  6700 00DC               1414                      BEQ     Fn_ID4_Data
00001F7E  6000 0160               1415                      BRA     Fn_ID4_Done
00001F82                          1416  
00001F82  47F9 00002D59           1417  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F88  23CB 00002D10           1418                      MOVE.L  A3, opPtrNam
00001F8E                          1419  
00001F8E  0C39 0007 00002D15      1420  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F96  6600 0146               1421                      BNE     Fn_ID4_Error
00001F9A  0C39 0001 00002D16      1422                      CMP.B   #1, opDstMod
00001FA2  6600 013A               1423                      BNE     Fn_ID4_Error
00001FA6  0C39 0006 00002D18      1424                      CMP.B   #6, opSrcMod
00001FAE  6600 012E               1425                      BNE     Fn_ID4_Error
00001FB2  0C39 0001 00002D17      1426                      CMP.B   #1, opSrcReg
00001FBA  6600 0122               1427                      BNE     Fn_ID4_Error
00001FBE  6000 0120               1428                      BRA     Fn_ID4_Done
00001FC2                          1429  
00001FC2                          1430  
00001FC2  47F9 00002D4F           1431  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FC8  23CB 00002D10           1432                      MOVE.L  A3, opPtrNam
00001FCE                          1433                      
00001FCE  0C39 0003 00002D15      1434  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FD6  6600 0106               1435                      BNE     Fn_ID4_Error
00001FDA                          1436                      
00001FDA                          1437                      * Make sure src mode is not 1
00001FDA  0C39 0001 00002D18      1438                      CMP.B   #1, opSrcMod
00001FE2  6700 00FA               1439                      BEQ     Fn_ID4_Error
00001FE6                          1440                      
00001FE6                          1441                      * Make sure src reg is between 0-7
00001FE6  0C39 0000 00002D17      1442                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FEE  6D00 00EE               1443                      BLT     Fn_ID4_Error
00001FF2  0C39 0007 00002D17      1444                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FFA  6E00 00E2               1445                      BGT     Fn_ID4_Error
00001FFE                          1446                      
00001FFE  33F9 00002D16 00002CAC  1447  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00002008  0C39 0007 00002D18      1448                      CMP.B   #7, opSrcMod
00002010  6700 0046               1449                      BEQ     Fn_ID4_Data
00002014  6000 00CA               1450                      BRA     Fn_ID4_Done
00002018                          1451  
00002018  47F9 00002D5D           1452  Fn_ID4_RTS          LEA    opNam_RTS,A3
0000201E  23CB 00002D10           1453                      MOVE.L A3, opPtrNam
00002024                          1454                      
00002024  0C39 0007 00002D15      1455  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000202C  6600 00B0               1456                      BNE     Fn_ID4_Error
00002030  0C39 0001 00002D16      1457                      CMP.B   #1, opDstMod
00002038  6600 00A4               1458                      BNE     Fn_ID4_Error
0000203C  0C39 0006 00002D18      1459                      CMP.B   #6, opSrcMod
00002044  6600 0098               1460                      BNE     Fn_ID4_Error
00002048  0C39 0005 00002D17      1461                      CMP.B   #5, opSrcReg
00002050  6600 008C               1462                      BNE     Fn_ID4_Error
00002054  6000 008A               1463                      BRA     Fn_ID4_Done
00002058                          1464  
00002058  0C39 0000 00002D17      1465  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
00002060  6700 0058               1466                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002064  0C39 0001 00002D17      1467                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000206C  6700 005E               1468                      BEQ     Fn_ID4_DtaLng               * Load next long
00002070  0C39 0004 00002D17      1469                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002078  6700 0006               1470                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000207C  6000 0060               1471                      BRA     FN_ID4_Error                * Invalid register value
00002080                          1472                      
00002080  0C39 0001 00002CAC      1473  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002088  6700 001E               1474                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000208C  0C39 0003 00002CAC      1475                      CMP.B   #3, opID                    * opID = 3 - size is word
00002094  6700 0024               1476                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002098  0C39 0002 00002CAC      1477                      CMP.B   #2, opID                    * opID = 0 - size is long
000020A0  6700 002A               1478                      BEQ     Fn_ID4_DtaLng               * Load next
000020A4  6000 0038               1479                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
000020A8                          1480  
000020A8  33DA 00002D20           1481  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000020AE  13FC 0000 00002D24      1482                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000020B6  6000 0028               1483                      BRA     Fn_ID4_Done
000020BA  33DA 00002D20           1484  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
000020C0  13FC 0001 00002D24      1485                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020C8  6000 0016               1486                      BRA     Fn_ID4_Done
000020CC  23DA 00002D20           1487  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020D2  13FC 0002 00002D24      1488                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020DA  6000 0004               1489                      BRA     Fn_ID4_Done
000020DE                          1490  
000020DE                          1491  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
000020DE                          1492                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000020DE  4E75                    1493                      RTS                                  * Return to main
000020E0                          1494  
000020E0  13FC 0000 00002CAD      1495  Fn_ID4_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000020E8  4E75                    1496              RTS
000020EA                          1497  
000020EA                          1498  
000020EA                          1499  
000020EA                          1500  -------------------- end include --------------------
000020EA                          1501                      INCLUDE 'SR_ID5.X68'
000020EA                          1502  
000020EA                          1503  
000020EA                          1504  SR_ID5              * This is to grab the first four that are already set, ID5
000020EA  3639 00002CAA           1505                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020F0  183C 000C               1506                      MOVE.B  #12,D4
000020F4  E86B                    1507                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000020F6  13C3 00002CAC           1508                      MOVE.B  D3, opID        
000020FC                          1509                      
000020FC                          1510                      * Read next 3 bits into D3
000020FC  3639 00002CAA           1511                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002102  183C 0004               1512                      MOVE.B  #4, D4
00002106  E96B                    1513                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002108  183C 000D               1514                      MOVE.B  #13,D4
0000210C  E86B                    1515                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000210E  13C3 00002D18           1516                      MOVE.B  D3, opSrcMod
00002114                          1517                      
00002114                          1518                      * Read next 3 bits into D3
00002114  3639 00002CAA           1519                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000211A  183C 0007               1520                      MOVE.B  #7, D4
0000211E  E96B                    1521                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002120  183C 000D               1522                      MOVE.B  #13,D4
00002124  E86B                    1523                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002126  13C3 00002CAC           1524                      MOVE.B  D3, opID
0000212C                          1525  
0000212C                          1526                      ** Read next 3 bits
0000212C                          1527                      **
0000212C  3639 00002CAA           1528                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002132  183C 000A               1529                      MOVE.B  #10, D4
00002136  E96B                    1530                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002138  183C 000D               1531                      MOVE.B  #13,D4
0000213C  E86B                    1532                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000213E  13C3 00002D16           1533                      MOVE.B  D3, opDstMod
00002144                          1534  
00002144                          1535                      ** Read next 3 bits
00002144                          1536                      **
00002144  3639 00002CAA           1537                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000214A  183C 000D               1538                      MOVE.B  #13, D4
0000214E  E96B                    1539                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002150  183C 000D               1540                      MOVE.B  #13,D4
00002154  E86B                    1541                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002156  13C3 00002D15           1542                      MOVE.B  D3, opDstReg
0000215C                          1543              
0000215C                          1544              ** Set name
0000215C  47F9 00002D65           1545              LEA     opNam_ADDQ,A3
00002162                          1546              
00002162                          1547  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
00002162  0C39 0000 00002D18      1548                      CMP.B   #0, opSrcMod                * Destination register >= 0
0000216A  6D00 00E4               1549                      BLT     Fn_ID5_Error
0000216E  0C39 0007 00002D15      1550                      CMP.B   #7, opDstReg                * Destination register <= 7
00002176  6E00 00D8               1551                      BGT     Fn_ID5_Error
0000217A                          1552              
0000217A                          1553              * Make sure opId  is between 0-2
0000217A  0C39 0000 00002CAC      1554                      CMP.B   #0, opID                    * Destination register >= 0
00002182  6D00 00CC               1555                      BLT     Fn_ID5_Error
00002186  0C39 0002 00002CAC      1556                      CMP.B   #2, opID                    * Destination register <= 2
0000218E  6E00 00C0               1557                      BGT     Fn_ID5_Error
00002192                          1558              
00002192                          1559              * Move data to  appropriate places for printing
00002192  13FC 0007 00002D18      1560              MOVE.B  #7,opSrcMod
0000219A  13FC 0004 00002D17      1561              MOVE.B  #4,opSrcReg
000021A2                          1562  
000021A2                          1563                      ** Note: Checking immediate value
000021A2                          1564                      **       opID as size is specific to MOVE, MOVEA
000021A2                          1565                      **       other instructions will use 3 bits to set size, not part of ID
000021A2                          1566                      **
000021A2  0C39 0001 00002CAC      1567  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000021AA  6700 001E               1568                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
000021AE  0C39 0003 00002CAC      1569                      CMP.B   #3, opID                    * opID = 3 - size is word
000021B6  6700 0024               1570                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
000021BA  0C39 0002 00002CAC      1571                      CMP.B   #2, opID                    * opID = 0 - size is long
000021C2  6700 002A               1572                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
000021C6  6000 0088               1573                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
000021CA                          1574  
000021CA  33DA 00002D1A           1575  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000021D0  13FC 0000 00002D1E      1576                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000021D8  6000 0026               1577                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021DC  33DA 00002D1A           1578  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000021E2  13FC 0001 00002D1E      1579                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000021EA  6000 0014               1580                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021EE  23DA 00002D1A           1581  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000021F4  13FC 0002 00002D1E      1582                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
000021FC  6000 0002               1583                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
00002200                          1584              
00002200  0C39 0007 00002D16      1585  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00002208  6700 0006               1586                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
0000220C  6000 0044               1587                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
00002210  0C39 0000 00002D15      1588  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00002218  6700 0012               1589                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
0000221C  0C39 0001 00002D15      1590                      CMP.B   #1, opDstReg                * Check if destination register is 1
00002224  6700 0018               1591                      BEQ     Fn_ID5_DtaDstLng            * Load next long
00002228  6000 0026               1592                      BRA     Fn_ID5_Error                * Invalid registration Mode
0000222C                          1593  
0000222C  33DA 00002D20           1594  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002232  13FC 0001 00002D24      1595                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
0000223A  6000 0016               1596                      BRA     Fn_ID5_Done
0000223E  23DA 00002D20           1597  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002244  13FC 0002 00002D24      1598                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
0000224C  6000 0004               1599                      BRA     Fn_ID5_Done
00002250                          1600  
00002250                          1601  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
00002250                          1602                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002250  4E75                    1603                      RTS   
00002252                          1604              
00002252  13FC 0000 00002CAD      1605  Fn_ID5_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
0000225A  4E75                    1606              RTS
0000225A  4E75                    1607  -------------------- end include --------------------
0000225C                          1608                      INCLUDE 'SR_ID6.X68'
0000225C                          1609  
0000225C                          1610  
0000225C                          1611  SR_ID6              * This is to grab the first four that are already set, ID6
0000225C  3639 00002CAA           1612                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002262  183C 000C               1613                      MOVE.B  #12,D4
00002266  E86B                    1614                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002268  13C3 00002CAC           1615                      MOVE.B  D3, opID        
0000226E                          1616                      
0000226E                          1617                      * Read next 4 bits into D3
0000226E  3639 00002CAA           1618                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002274  183C 0004               1619                      MOVE.B  #4, D4
00002278  E96B                    1620                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
0000227A  183C 000C               1621                      MOVE.B  #12,D4
0000227E  E86B                    1622                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
00002280  13C3 00002CAC           1623                      MOVE.B  D3, opID
00002286                          1624                      
00002286                          1625                      * Read next 8 bits into D3
00002286  3639 00002CAA           1626                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000228C  183C 0007               1627                      MOVE.B  #7, D4
00002290  E96B                    1628                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
00002292  183C 0008               1629                      MOVE.B  #8,D4
00002296  E86B                    1630                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002298  13C3 00002D16           1631                      MOVE.B  D3, opDstMod
0000229E                          1632              
0000229E                          1633              ** Condition is stored in opID - displacement is in DstMod
0000229E                          1634              ** All thats leftis to branch per condition and output name, check reg if needed more
0000229E                          1635              ** BRA - opID=0
0000229E                          1636              ** BEQ - opID=7
0000229E                          1637              ** BGT - opID=14
0000229E                          1638              ** BLE - opID=15
0000229E  0C39 0000 00002CAC      1639              CMP.B   #0,opID
000022A6  6700 002A               1640              BEQ     Fn_ID6_BRA
000022AA  0C39 0007 00002CAC      1641              CMP.B   #7,opID
000022B2  6700 0028               1642              BEQ     Fn_ID6_BEQ
000022B6  0C39 000E 00002CAC      1643              CMP.B   #14,opID
000022BE  6700 0026               1644              BEQ     Fn_ID6_BGT
000022C2  0C39 000F 00002CAC      1645              CMP.B   #15,opID
000022CA  6700 0024               1646              BEQ     Fn_ID6_BLE
000022CE  6000 0078               1647              BRA     Fn_ID6_ERROR
000022D2                          1648  
000022D2  47F9 00002D6A           1649  Fn_ID6_BRA  LEA     opNam_BRA,A3
000022D8  6000 001C               1650              BRA     Fn_ID6_Displacement
000022DC                          1651              
000022DC  47F9 00002D6E           1652  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
000022E2  6000 0012               1653              BRA     Fn_ID6_Displacement
000022E6                          1654              
000022E6  47F9 00002D72           1655  Fn_ID6_BGT  LEA     opNam_BGT,A3
000022EC  6000 0008               1656              BRA     Fn_ID6_Displacement
000022F0                          1657              
000022F0  47F9 00002D76           1658  Fn_ID6_BLE  LEA     opNam_BLE,A3
000022F6                          1659              
000022F6  0C39 0000 00002D16      1660  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
000022FE  6700 0024               1661              BEQ     Fn_ID6_Dsplcmnt16
00002302  0C39 00FF 00002D16      1662              CMP.B   #$FF,opDstMod
0000230A  6700 002A               1663              BEQ     Fn_ID6_Dsplcmnt32
0000230E                          1664              ** 8 bit is good
0000230E  33F9 00002D16 00002D20  1665              MOVE.W  opDstMod,opDta2
00002318  13FC 0000 00002D24      1666              MOVE.B  #0,opDta2T
00002320  6000 0028               1667              BRA     Fn_ID6_Done
00002324                          1668              
00002324  33DA 00002D20           1669  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
0000232A  13FC 0001 00002D24      1670              MOVE.B  #1,opDta2T
00002332  6000 0016               1671              BRA     Fn_ID6_Done
00002336                          1672  
00002336  23DA 00002D20           1673  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
0000233C  13FC 0002 00002D24      1674              MOVE.B  #2,opDta2T
00002344  6000 0004               1675              BRA     Fn_ID6_Done 
00002348                          1676  
00002348                          1677  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
00002348                          1678                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002348  4E75                    1679                      RTS 
0000234A                          1680  
0000234A  13FC 0000 00002CAD      1681  Fn_ID6_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002352  4E75                    1682              RTS
00002352  4E75                    1683  -------------------- end include --------------------
00002354                          1684                      INCLUDE 'SR_ID7.X68'
00002354                          1685  
00002354                          1686  
00002354                          1687  SR_ID7              * This is to grab the first four that are already set, ID7
00002354  3639 00002CAA           1688                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000235A  183C 000C               1689                      MOVE.B  #12,D4
0000235E  E86B                    1690                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002360  13C3 00002CAC           1691                      MOVE.B  D3, opID        
00002366                          1692                      
00002366                          1693                      * Read next 3 bits into D3
00002366  3639 00002CAA           1694                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000236C  183C 0004               1695                      MOVE.B  #4, D4
00002370  E96B                    1696                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002372  183C 000D               1697                      MOVE.B  #13,D4
00002376  E86B                    1698                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002378  13C3 00002D1A           1699                      MOVE.B  D3, opDta1      
0000237E                          1700              
0000237E                          1701              * Read next 1 bits into D3
0000237E  3639 00002CAA           1702                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002384  183C 0007               1703                      MOVE.B  #7, D4
00002388  E96B                    1704                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000238A  183C 000F               1705                      MOVE.B  #15,D4
0000238E  E86B                    1706                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002390  13C3 00002D16           1707                      MOVE.B  D3, opDstMod    
00002396  0C39 0000 00002D16      1708              CMP.B   #0,opDstMod
0000239E  6600 0038               1709              BNE     Fn_ID7_Error
000023A2                          1710              
000023A2                          1711              * Read next 8 bits into D3
000023A2  3639 00002CAA           1712                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023A8  183C 0008               1713                      MOVE.B  #8, D4
000023AC  E96B                    1714                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000023AE  183C 0008               1715                      MOVE.B  #8,D4
000023B2  E86B                    1716                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
000023B4  13C3 00002D20           1717                      MOVE.B  D3, opDta2
000023BA                          1718  
000023BA  47F9 00002D7A           1719              LEA     opNam_MOVEQ,A3
000023C0                          1720              * Set appropriate data
000023C0  13FC 0001 00002D24      1721              MOVE.B  #1, opDta2T
000023C8  13FC 0007 00002D18      1722              MOVE.B  #7, opSrcMod
000023D0  13FC 0000 00002D17      1723              MOVE.B  #0, opSrcReg
000023D8                          1724  
000023D8                          1725  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
000023D8                          1726                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000023D8  4E75                    1727                      RTS                                  * Return to main
000023DA                          1728              
000023DA  13FC 0000 00002CAD      1729  Fn_ID7_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000023E2  4E75                    1730              RTS
000023E2  4E75                    1731  -------------------- end include --------------------
000023E4                          1732                      INCLUDE 'SR_ID8.X68'
000023E4                          1733  
000023E4                          1734  
000023E4                          1735  SR_ID8              * This is to grab the first four that are already set, ID4
000023E4  3639 00002CAA           1736                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023EA  183C 000C               1737                      MOVE.B  #12,D4
000023EE  E86B                    1738                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000023F0  13C3 00002CAC           1739                      MOVE.B  D3, opID        
000023F6                          1740                      
000023F6                          1741                      * Read next 3 bits into D3
000023F6  3639 00002CAA           1742                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023FC  183C 0004               1743                      MOVE.B  #4, D4
00002400  E96B                    1744                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002402  183C 000D               1745                      MOVE.B  #13,D4
00002406  E86B                    1746                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002408  13C3 00002D15           1747                      MOVE.B  D3, opDstReg
0000240E                          1748                      
0000240E                          1749                      * Read next 3 bits into D3
0000240E  3639 00002CAA           1750                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002414  183C 0007               1751                      MOVE.B  #7, D4
00002418  E96B                    1752                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000241A  183C 000D               1753                      MOVE.B  #13,D4
0000241E  E86B                    1754                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002420  13C3 00002D16           1755                      MOVE.B  D3, opDstMod
00002426                          1756  
00002426                          1757                      ** Read next 3 bits
00002426                          1758                      **
00002426  3639 00002CAA           1759                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000242C  183C 000A               1760                      MOVE.B  #10, D4
00002430  E96B                    1761                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002432  183C 000D               1762                      MOVE.B  #13,D4
00002436  E86B                    1763                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002438  13C3 00002D18           1764                      MOVE.B  D3, opSrcMod
0000243E                          1765  
0000243E                          1766                      ** Read next 3 bits
0000243E                          1767                      **
0000243E  3639 00002CAA           1768                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002444  183C 000D               1769                      MOVE.B  #13, D4
00002448  E96B                    1770                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000244A  183C 000D               1771                      MOVE.B  #13,D4
0000244E  E86B                    1772                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002450  13C3 00002D17           1773                      MOVE.B  D3, opSrcReg
00002456                          1774              
00002456                          1775              ** Find out if its Dn, ea or ea, Dn
00002456                          1776              ** ea, Dn - 0,1,2
00002456                          1777              ** Dn, ea - 4,5,6
00002456  47F9 00002D80           1778              LEA     opNam_OR,A3
0000245C  0C39 0003 00002D16      1779              CMP.B   #3,opDstMod
00002464  6D00 0012               1780              BLT     Fn_ID8_Case1
00002468  0C39 0007 00002D16      1781              CMP.B   #7,opDstMod
00002470  6D00 0048               1782              BLT     Fn_ID8_Case2
00002474  6000 0178               1783              BRA     Fn_ID8_Error
00002478                          1784  
00002478  13F9 00002D16 00002CAC  1785  Fn_ID8_Case1MOVE.B  opDstMod,opID
00002482  13F9 00002D18 00002D16  1786              MOVE.B  opSrcMod,opDstMod
0000248C  1C39 00002D15           1787              MOVE.B  opDstReg,D6
00002492  13F9 00002D17 00002D15  1788              MOVE.B  opSrcReg,opDstReg
0000249C  13C6 00002D17           1789              MOVE.B  D6,opSrcReg
000024A2  13FC 0000 00002D18      1790              MOVE.B  #0,opSrcMod
000024AA                          1791              ** Immediate data?
000024AA  0C39 0007 00002D16      1792              CMP.B   #7, opDstMod
000024B2  6700 002E               1793                      BEQ     Fn_ID8_DataDst
000024B6  6000 0138               1794                      BRA     Fn_ID8_Done
000024BA                          1795  
000024BA  13F9 00002D16 00002CAC  1796  Fn_ID8_Case2MOVE.B  opDstMod,opID
000024C4  5939 00002CAC           1797              SUB.B   #4,opID
000024CA  13FC 0000 00002D16      1798              MOVE.B  #0,opDstMod
000024D2                          1799              ** Immediate data?
000024D2  0C39 0007 00002D18      1800              CMP.B   #7, opSrcMod
000024DA  6700 008C               1801                      BEQ     Fn_ID8_DataSrc
000024DE  6000 0110               1802                      BRA     Fn_ID8_Done
000024E2                          1803              
000024E2  0C39 0000 00002D15      1804  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000024EA  6700 0058               1805                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024EE  0C39 0001 00002D15      1806                      CMP.B   #1, opDstReg                * Check if source register is 1
000024F6  6700 005E               1807                      BEQ     Fn_ID8_DtaDstLng            * Load next long
000024FA  0C39 0004 00002D15      1808                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002502  6700 0006               1809                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
00002506  6000 00E6               1810                      BRA     FN_ID8_Error                * Invalid register value
0000250A                          1811                      
0000250A  0C39 0001 00002CAC      1812  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002512  6700 001E               1813                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
00002516  0C39 0003 00002CAC      1814                      CMP.B   #3, opID                    * opID = 3 - size is word
0000251E  6700 0024               1815                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
00002522  0C39 0002 00002CAC      1816                      CMP.B   #2, opID                    * opID = 0 - size is long
0000252A  6700 002A               1817                      BEQ     Fn_ID8_DtaDstLng            * Load next
0000252E  6000 00BE               1818                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
00002532                          1819  
00002532  33DA 00002D1A           1820  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002538  13FC 0000 00002D1E      1821                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002540  6000 00AE               1822                      BRA     Fn_ID8_Done
00002544  33DA 00002D1A           1823  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
0000254A  13FC 0001 00002D1E      1824                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002552  6000 009C               1825                      BRA     Fn_ID8_Done
00002556  23DA 00002D1A           1826  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
0000255C  13FC 0002 00002D1E      1827                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002564  6000 008A               1828                      BRA     Fn_ID8_Done
00002568                          1829              
00002568  0C39 0000 00002D17      1830  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002570  6700 0058               1831                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002574  0C39 0001 00002D17      1832                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000257C  6700 005E               1833                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
00002580  0C39 0004 00002D17      1834                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002588  6700 0006               1835                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
0000258C  6000 0060               1836                      BRA     FN_ID8_Error                * Invalid register value
00002590                          1837                      
00002590  0C39 0001 00002CAC      1838  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002598  6700 001E               1839                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
0000259C  0C39 0003 00002CAC      1840                      CMP.B   #3, opID                    * opID = 3 - size is word
000025A4  6700 0024               1841                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
000025A8  0C39 0002 00002CAC      1842                      CMP.B   #2, opID                    * opID = 0 - size is long
000025B0  6700 002A               1843                      BEQ     Fn_ID8_DtaSrcLng            * Load next
000025B4  6000 0038               1844                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000025B8                          1845  
000025B8  33DA 00002D20           1846  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000025BE  13FC 0000 00002D24      1847                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000025C6  6000 0028               1848                      BRA     Fn_ID8_Done
000025CA  33DA 00002D20           1849  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000025D0  13FC 0001 00002D24      1850                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000025D8  6000 0016               1851                      BRA     Fn_ID8_Done
000025DC  23DA 00002D20           1852  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000025E2  13FC 0002 00002D24      1853                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000025EA  6000 0004               1854                      BRA     Fn_ID8_Done
000025EE                          1855  
000025EE                          1856  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
000025EE                          1857                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025EE  4E75                    1858                      RTS   
000025F0                          1859              
000025F0  13FC 0000 00002CAD      1860  Fn_ID8_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000025F8  4E75                    1861              RTS
000025F8  4E75                    1862  -------------------- end include --------------------
000025FA                          1863                      INCLUDE 'SR_ID9.X68'
000025FA                          1864  
000025FA                          1865  
000025FA                          1866  SR_ID9      * This is to grab the first four that are already set, ID4
000025FA  3639 00002CAA           1867                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002600  183C 000C               1868                      MOVE.B  #12,D4
00002604  E86B                    1869                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002606  13C3 00002CAC           1870                      MOVE.B  D3, opID        
0000260C                          1871                      
0000260C                          1872                      * Read next 3 bits into D3
0000260C  3639 00002CAA           1873                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002612  183C 0004               1874                      MOVE.B  #4, D4
00002616  E96B                    1875                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002618  183C 000D               1876                      MOVE.B  #13,D4
0000261C  E86B                    1877                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000261E  13C3 00002D15           1878                      MOVE.B  D3, opDstReg
00002624                          1879                      
00002624                          1880                      * Read next 3 bits into D3
00002624  3639 00002CAA           1881                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000262A  183C 0007               1882                      MOVE.B  #7, D4
0000262E  E96B                    1883                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002630  183C 000D               1884                      MOVE.B  #13,D4
00002634  E86B                    1885                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002636  13C3 00002D16           1886                      MOVE.B  D3, opDstMod
0000263C                          1887  
0000263C                          1888                      ** Read next 3 bits
0000263C                          1889                      **
0000263C  3639 00002CAA           1890                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002642  183C 000A               1891                      MOVE.B  #10, D4
00002646  E96B                    1892                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002648  183C 000D               1893                      MOVE.B  #13,D4
0000264C  E86B                    1894                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000264E  13C3 00002D18           1895                      MOVE.B  D3, opSrcMod
00002654                          1896  
00002654                          1897                      ** Read next 3 bits
00002654                          1898                      **
00002654  3639 00002CAA           1899                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000265A  183C 000D               1900                      MOVE.B  #13, D4
0000265E  E96B                    1901                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002660  183C 000D               1902                      MOVE.B  #13,D4
00002664  E86B                    1903                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002666  13C3 00002D17           1904                      MOVE.B  D3, opSrcReg
0000266C                          1905              
0000266C                          1906              ** Find out if its Dn, ea or ea, Dn
0000266C                          1907              ** ea, Dn - 0,1,2
0000266C                          1908              ** Dn, ea - 4,5,6
0000266C  47F9 00002D83           1909              LEA     opNam_SUB,A3
00002672  0C39 0003 00002D16      1910              CMP.B   #3,opDstMod
0000267A  6D00 0012               1911              BLT     Fn_ID9_Case1
0000267E  0C39 0007 00002D16      1912              CMP.B   #7,opDstMod
00002686  6D00 0048               1913              BLT     Fn_ID9_Case2
0000268A  6000 0178               1914              BRA     Fn_ID9_Error
0000268E                          1915  
0000268E  13F9 00002D16 00002CAC  1916  Fn_ID9_Case1MOVE.B  opDstMod,opID
00002698  13F9 00002D18 00002D16  1917              MOVE.B  opSrcMod,opDstMod
000026A2  1C39 00002D15           1918              MOVE.B  opDstReg,D6
000026A8  13F9 00002D17 00002D15  1919              MOVE.B  opSrcReg,opDstReg
000026B2  13C6 00002D17           1920              MOVE.B  D6,opSrcReg
000026B8  13FC 0000 00002D18      1921              MOVE.B  #0,opSrcMod
000026C0                          1922              ** Immediate data?
000026C0  0C39 0007 00002D16      1923              CMP.B   #7, opDstMod
000026C8  6700 002E               1924                      BEQ     Fn_ID9_DataDst
000026CC  6000 0138               1925                      BRA     Fn_ID9_Done
000026D0                          1926  
000026D0  13F9 00002D16 00002CAC  1927  Fn_ID9_Case2MOVE.B  opDstMod,opID
000026DA  5939 00002CAC           1928              SUB.B   #4,opID
000026E0  13FC 0000 00002D16      1929              MOVE.B  #0,opDstMod
000026E8                          1930              ** Immediate data?
000026E8  0C39 0007 00002D18      1931              CMP.B   #7, opSrcMod
000026F0  6700 008C               1932                      BEQ     Fn_ID9_DataSrc
000026F4  6000 0110               1933                      BRA     Fn_ID9_Done
000026F8                          1934              
000026F8  0C39 0000 00002D15      1935  Fn_ID9_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002700  6700 0058               1936                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
00002704  0C39 0001 00002D15      1937                      CMP.B   #1, opDstReg                * Check if source register is 1
0000270C  6700 005E               1938                      BEQ     Fn_ID9_DtaDstLng            * Load next long
00002710  0C39 0004 00002D15      1939                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002718  6700 0006               1940                      BEQ     Fn_ID9_DtaDstImd            * Load first word into word one
0000271C  6000 00E6               1941                      BRA     FN_ID9_Error                * Invalid register value
00002720                          1942                      
00002720  0C39 0001 00002CAC      1943  Fn_ID9_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002728  6700 001E               1944                      BEQ     Fn_ID9_DtaDstByt            * Load next byte
0000272C  0C39 0003 00002CAC      1945                      CMP.B   #3, opID                    * opID = 3 - size is word
00002734  6700 0024               1946                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
00002738  0C39 0002 00002CAC      1947                      CMP.B   #2, opID                    * opID = 0 - size is long
00002740  6700 002A               1948                      BEQ     Fn_ID9_DtaDstLng            * Load next
00002744  6000 00BE               1949                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
00002748                          1950  
00002748  33DA 00002D1A           1951  Fn_ID9_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
0000274E  13FC 0000 00002D1E      1952                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002756  6000 00AE               1953                      BRA     Fn_ID9_Done
0000275A  33DA 00002D1A           1954  Fn_ID9_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002760  13FC 0001 00002D1E      1955                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002768  6000 009C               1956                      BRA     Fn_ID9_Done
0000276C  23DA 00002D1A           1957  Fn_ID9_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002772  13FC 0002 00002D1E      1958                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000277A  6000 008A               1959                      BRA     Fn_ID9_Done
0000277E                          1960              
0000277E  0C39 0000 00002D17      1961  Fn_ID9_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002786  6700 0058               1962                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000278A  0C39 0001 00002D17      1963                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002792  6700 005E               1964                      BEQ     Fn_ID9_DtaSrcLng            * Load next long
00002796  0C39 0004 00002D17      1965                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
0000279E  6700 0006               1966                      BEQ     Fn_ID9_DtaSrcImd            * Load first word into word one
000027A2  6000 0060               1967                      BRA     FN_ID9_Error                * Invalid register value
000027A6                          1968                      
000027A6  0C39 0001 00002CAC      1969  Fn_ID9_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000027AE  6700 001E               1970                      BEQ     Fn_ID9_DtaSrcByt            * Load next byte
000027B2  0C39 0003 00002CAC      1971                      CMP.B   #3, opID                    * opID = 3 - size is word
000027BA  6700 0024               1972                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
000027BE  0C39 0002 00002CAC      1973                      CMP.B   #2, opID                    * opID = 0 - size is long
000027C6  6700 002A               1974                      BEQ     Fn_ID9_DtaSrcLng            * Load next
000027CA  6000 0038               1975                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
000027CE                          1976  
000027CE  33DA 00002D20           1977  Fn_ID9_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000027D4  13FC 0000 00002D24      1978                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000027DC  6000 0028               1979                      BRA     Fn_ID9_Done
000027E0  33DA 00002D20           1980  Fn_ID9_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000027E6  13FC 0001 00002D24      1981                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000027EE  6000 0016               1982                      BRA     Fn_ID9_Done
000027F2  23DA 00002D20           1983  Fn_ID9_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000027F8  13FC 0002 00002D24      1984                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002800  6000 0004               1985                      BRA     Fn_ID9_Done
00002804                          1986  
00002804                          1987  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
00002804                          1988                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002804  4E75                    1989                      RTS   
00002806                          1990  
00002806  13FC 0000 00002CAD      1991  Fn_ID9_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
0000280E  4E75                    1992              RTS
0000280E  4E75                    1993  -------------------- end include --------------------
00002810                          1994                      INCLUDE 'SR_IDA.X68'
00002810                          1995  
00002810                          1996  
00002810                          1997  SR_IDA
00002810                          1998  
00002810                          1999  
00002810  4E75                    2000  Fn_IDA_Done        RTS
00002810  4E75                    2001  -------------------- end include --------------------
00002812                          2002                      INCLUDE 'SR_IDB.X68'
00002812                          2003  
00002812                          2004  
00002812                          2005  SR_IDB
00002812                          2006  
00002812                          2007  
00002812  4E75                    2008  Fn_IDB_Done        RTS
00002812  4E75                    2009  -------------------- end include --------------------
00002814                          2010                      INCLUDE 'SR_IDC.X68'
00002814                          2011  
00002814                          2012  
00002814                          2013  SR_IDC      * This is to grab the first four that are already set, ID4
00002814  3639 00002CAA           2014                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000281A  183C 000C               2015                      MOVE.B  #12,D4
0000281E  E86B                    2016                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002820  13C3 00002CAC           2017                      MOVE.B  D3, opID        
00002826                          2018                      
00002826                          2019                      * Read next 3 bits into D3
00002826  3639 00002CAA           2020                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000282C  183C 0004               2021                      MOVE.B  #4, D4
00002830  E96B                    2022                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002832  183C 000D               2023                      MOVE.B  #13,D4
00002836  E86B                    2024                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002838  13C3 00002D15           2025                      MOVE.B  D3, opDstReg
0000283E                          2026                      
0000283E                          2027                      * Read next 3 bits into D3
0000283E  3639 00002CAA           2028                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002844  183C 0007               2029                      MOVE.B  #7, D4
00002848  E96B                    2030                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000284A  183C 000D               2031                      MOVE.B  #13,D4
0000284E  E86B                    2032                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002850  13C3 00002D16           2033                      MOVE.B  D3, opDstMod
00002856                          2034  
00002856                          2035                      ** Read next 3 bits
00002856                          2036                      **
00002856  3639 00002CAA           2037                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000285C  183C 000A               2038                      MOVE.B  #10, D4
00002860  E96B                    2039                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002862  183C 000D               2040                      MOVE.B  #13,D4
00002866  E86B                    2041                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002868  13C3 00002D18           2042                      MOVE.B  D3, opSrcMod
0000286E                          2043  
0000286E                          2044                      ** Read next 3 bits
0000286E                          2045                      **
0000286E  3639 00002CAA           2046                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002874  183C 000D               2047                      MOVE.B  #13, D4
00002878  E96B                    2048                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000287A  183C 000D               2049                      MOVE.B  #13,D4
0000287E  E86B                    2050                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002880  13C3 00002D17           2051                      MOVE.B  D3, opSrcReg
00002886                          2052              
00002886                          2053              ** Find out if its Dn, ea or ea, Dn
00002886                          2054              ** ea, Dn - 0,1,2
00002886                          2055              ** Dn, ea - 4,5,6
00002886  47F9 00002D87           2056              LEA     opNam_AND,A3
0000288C  0C39 0003 00002D16      2057              CMP.B   #3,opDstMod
00002894  6D00 0012               2058              BLT     Fn_IDC_Case1
00002898  0C39 0007 00002D16      2059              CMP.B   #7,opDstMod
000028A0  6D00 0048               2060              BLT     Fn_IDC_Case2
000028A4  6000 0178               2061              BRA     Fn_IDC_Error
000028A8                          2062  
000028A8  13F9 00002D16 00002CAC  2063  Fn_IDC_Case1MOVE.B  opDstMod,opID
000028B2  13F9 00002D18 00002D16  2064              MOVE.B  opSrcMod,opDstMod
000028BC  1C39 00002D15           2065              MOVE.B  opDstReg,D6
000028C2  13F9 00002D17 00002D15  2066              MOVE.B  opSrcReg,opDstReg
000028CC  13C6 00002D17           2067              MOVE.B  D6,opSrcReg
000028D2  13FC 0000 00002D18      2068              MOVE.B  #0,opSrcMod
000028DA                          2069              ** Immediate data?
000028DA  0C39 0007 00002D16      2070              CMP.B   #7, opDstMod
000028E2  6700 002E               2071                      BEQ     Fn_IDC_DataDst
000028E6  6000 0138               2072                      BRA     Fn_IDC_Done
000028EA                          2073  
000028EA  13F9 00002D16 00002CAC  2074  Fn_IDC_Case2MOVE.B  opDstMod,opID
000028F4  5939 00002CAC           2075              SUB.B   #4,opID
000028FA  13FC 0000 00002D16      2076              MOVE.B  #0,opDstMod
00002902                          2077              ** Immediate data?
00002902  0C39 0007 00002D18      2078              CMP.B   #7, opSrcMod
0000290A  6700 008C               2079                      BEQ     Fn_IDC_DataSrc
0000290E  6000 0110               2080                      BRA     Fn_IDC_Done
00002912                          2081              
00002912  0C39 0000 00002D15      2082  Fn_IDC_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
0000291A  6700 0058               2083                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
0000291E  0C39 0001 00002D15      2084                      CMP.B   #1, opDstReg                * Check if source register is 1
00002926  6700 005E               2085                      BEQ     Fn_IDC_DtaDstLng            * Load next long
0000292A  0C39 0004 00002D15      2086                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002932  6700 0006               2087                      BEQ     Fn_IDC_DtaDstImd            * Load first word into word one
00002936  6000 00E6               2088                      BRA     FN_IDC_Error                * Invalid register value
0000293A                          2089                      
0000293A  0C39 0001 00002CAC      2090  Fn_IDC_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002942  6700 001E               2091                      BEQ     Fn_IDC_DtaDstByt            * Load next byte
00002946  0C39 0003 00002CAC      2092                      CMP.B   #3, opID                    * opID = 3 - size is word
0000294E  6700 0024               2093                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
00002952  0C39 0002 00002CAC      2094                      CMP.B   #2, opID                    * opID = 0 - size is long
0000295A  6700 002A               2095                      BEQ     Fn_IDC_DtaDstLng            * Load next
0000295E  6000 00BE               2096                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002962                          2097  
00002962  33DA 00002D1A           2098  Fn_IDC_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002968  13FC 0000 00002D1E      2099                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002970  6000 00AE               2100                      BRA     Fn_IDC_Done
00002974  33DA 00002D1A           2101  Fn_IDC_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
0000297A  13FC 0001 00002D1E      2102                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002982  6000 009C               2103                      BRA     Fn_IDC_Done
00002986  23DA 00002D1A           2104  Fn_IDC_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
0000298C  13FC 0002 00002D1E      2105                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002994  6000 008A               2106                      BRA     Fn_IDC_Done
00002998                          2107              
00002998  0C39 0000 00002D17      2108  Fn_IDC_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
000029A0  6700 0058               2109                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
000029A4  0C39 0001 00002D17      2110                      CMP.B   #1, opSrcReg                * Check if source register is 1
000029AC  6700 005E               2111                      BEQ     Fn_IDC_DtaSrcLng            * Load next long
000029B0  0C39 0004 00002D17      2112                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
000029B8  6700 0006               2113                      BEQ     Fn_IDC_DtaSrcImd            * Load first word into word one
000029BC  6000 0060               2114                      BRA     FN_IDC_Error                * Invalid register value
000029C0                          2115                      
000029C0  0C39 0001 00002CAC      2116  Fn_IDC_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000029C8  6700 001E               2117                      BEQ     Fn_IDC_DtaSrcByt            * Load next byte
000029CC  0C39 0003 00002CAC      2118                      CMP.B   #3, opID                    * opID = 3 - size is word
000029D4  6700 0024               2119                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
000029D8  0C39 0002 00002CAC      2120                      CMP.B   #2, opID                    * opID = 0 - size is long
000029E0  6700 002A               2121                      BEQ     Fn_IDC_DtaSrcLng            * Load next
000029E4  6000 0038               2122                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
000029E8                          2123  
000029E8  33DA 00002D20           2124  Fn_IDC_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000029EE  13FC 0000 00002D24      2125                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000029F6  6000 0028               2126                      BRA     Fn_IDC_Done
000029FA  33DA 00002D20           2127  Fn_IDC_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002A00  13FC 0001 00002D24      2128                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002A08  6000 0016               2129                      BRA     Fn_IDC_Done
00002A0C  23DA 00002D20           2130  Fn_IDC_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002A12  13FC 0002 00002D24      2131                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002A1A  6000 0004               2132                      BRA     Fn_IDC_Done
00002A1E                          2133  
00002A1E                          2134  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
00002A1E                          2135                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002A1E  4E75                    2136                      RTS   
00002A20                          2137  
00002A20  13FC 0000 00002CAD      2138  Fn_IDC_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002A28  4E75                    2139              RTS
00002A28  4E75                    2140  -------------------- end include --------------------
00002A2A                          2141                      INCLUDE 'SR_IDD.X68'
00002A2A                          2142  
00002A2A                          2143  
00002A2A                          2144  SR_IDD      * This is to grab the first four that are already set, ID4
00002A2A  3639 00002CAA           2145                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A30  183C 000C               2146                      MOVE.B  #12,D4
00002A34  E86B                    2147                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002A36  13C3 00002CAC           2148                      MOVE.B  D3, opID        
00002A3C                          2149                      
00002A3C                          2150                      * Read next 3 bits into D3
00002A3C  3639 00002CAA           2151                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A42  183C 0004               2152                      MOVE.B  #4, D4
00002A46  E96B                    2153                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002A48  183C 000D               2154                      MOVE.B  #13,D4
00002A4C  E86B                    2155                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A4E  13C3 00002D15           2156                      MOVE.B  D3, opDstReg
00002A54                          2157                      
00002A54                          2158                      * Read next 3 bits into D3
00002A54  3639 00002CAA           2159                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A5A  183C 0007               2160                      MOVE.B  #7, D4
00002A5E  E96B                    2161                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002A60  183C 000D               2162                      MOVE.B  #13,D4
00002A64  E86B                    2163                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A66  13C3 00002D16           2164                      MOVE.B  D3, opDstMod
00002A6C                          2165  
00002A6C                          2166                      ** Read next 3 bits
00002A6C                          2167                      **
00002A6C  3639 00002CAA           2168                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A72  183C 000A               2169                      MOVE.B  #10, D4
00002A76  E96B                    2170                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A78  183C 000D               2171                      MOVE.B  #13,D4
00002A7C  E86B                    2172                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A7E  13C3 00002D18           2173                      MOVE.B  D3, opSrcMod
00002A84                          2174  
00002A84                          2175                      ** Read next 3 bits
00002A84                          2176                      **
00002A84  3639 00002CAA           2177                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A8A  183C 000D               2178                      MOVE.B  #13, D4
00002A8E  E96B                    2179                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A90  183C 000D               2180                      MOVE.B  #13,D4
00002A94  E86B                    2181                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A96  13C3 00002D17           2182                      MOVE.B  D3, opSrcReg
00002A9C                          2183              
00002A9C                          2184              ** Find out if its Dn, ea or ea, Dn
00002A9C                          2185              ** ea, Dn - 0,1,2
00002A9C                          2186              ** Dn, ea - 4,5,6
00002A9C  0C39 0003 00002D16      2187              CMP.B   #3,opDstMod
00002AA4  6D00 002A               2188              BLT     Fn_IDD_Case1
00002AA8  0C39 0003 00002D16      2189              CMP.B   #3,opDstMod
00002AB0  6700 0094               2190              BEQ     Fn_IDD_Case3
00002AB4  0C39 0007 00002D16      2191              CMP.B   #7,opDstMod
00002ABC  6D00 005A               2192              BLT     Fn_IDD_Case2
00002AC0  0C39 0007 00002D16      2193              CMP.B   #7,opDstMod
00002AC8  6700 007C               2194              BEQ     Fn_IDD_Case3
00002ACC  6000 01B2               2195              BRA     Fn_IDD_Error
00002AD0                          2196  
00002AD0  47F9 00002D8B           2197  Fn_IDD_Case1LEA     opNam_ADD,A3
00002AD6  13F9 00002D16 00002CAC  2198              MOVE.B  opDstMod,opID
00002AE0  13F9 00002D18 00002D16  2199              MOVE.B  opSrcMod,opDstMod
00002AEA  1C39 00002D15           2200              MOVE.B  opDstReg,D6
00002AF0  13F9 00002D17 00002D15  2201              MOVE.B  opSrcReg,opDstReg
00002AFA  13C6 00002D17           2202              MOVE.B  D6,opSrcReg
00002B00  13FC 0000 00002D18      2203              MOVE.B  #0,opSrcMod
00002B08                          2204              ** Immediate data?
00002B08  0C39 0007 00002D16      2205              CMP.B   #7, opDstMod
00002B10  6700 0062               2206                      BEQ     Fn_IDD_DataDst
00002B14  6000 016C               2207                      BRA     Fn_IDD_Done
00002B18                          2208  
00002B18  47F9 00002D8B           2209  Fn_IDD_Case2LEA     opNam_ADD,A3
00002B1E  13F9 00002D16 00002CAC  2210              MOVE.B  opDstMod,opID
00002B28  5939 00002CAC           2211              SUB.B   #4,opID
00002B2E  13FC 0000 00002D16      2212              MOVE.B  #0,opDstMod
00002B36                          2213              ** Immediate data?
00002B36  0C39 0007 00002D18      2214              CMP.B   #7, opSrcMod
00002B3E  6700 00BA               2215                      BEQ     Fn_IDD_DataSrc
00002B42  6000 013E               2216                      BRA     Fn_IDD_Done
00002B46                          2217              
00002B46  47F9 00002D8F           2218  Fn_IDD_Case3LEA     opNam_ADDA,A3
00002B4C  13F9 00002D16 00002CAC  2219              MOVE.B  opDstMod,opID
00002B56  5939 00002CAC           2220              SUB.B   #4,opID
00002B5C  13FC 0000 00002D16      2221              MOVE.B  #0,opDstMod
00002B64                          2222              ** Immediate data?
00002B64  0C39 0007 00002D18      2223              CMP.B   #7, opSrcMod
00002B6C  6700 008C               2224                      BEQ     Fn_IDD_DataSrc
00002B70  6000 0110               2225                      BRA     Fn_IDD_Done
00002B74                          2226              
00002B74  0C39 0000 00002D15      2227  Fn_IDD_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002B7C  6700 0058               2228                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002B80  0C39 0001 00002D15      2229                      CMP.B   #1, opDstReg                * Check if source register is 1
00002B88  6700 005E               2230                      BEQ     Fn_IDD_DtaDstLng            * Load next long
00002B8C  0C39 0004 00002D15      2231                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002B94  6700 0006               2232                      BEQ     Fn_IDD_DtaDstImd            * Load first word into word one
00002B98  6000 00E6               2233                      BRA     FN_IDD_Error                * Invalid register value
00002B9C                          2234                      
00002B9C  0C39 0001 00002CAC      2235  Fn_IDD_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002BA4  6700 001E               2236                      BEQ     Fn_IDD_DtaDstByt            * Load next byte
00002BA8  0C39 0003 00002CAC      2237                      CMP.B   #3, opID                    * opID = 3 - size is word
00002BB0  6700 0024               2238                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002BB4  0C39 0002 00002CAC      2239                      CMP.B   #2, opID                    * opID = 0 - size is long
00002BBC  6700 002A               2240                      BEQ     Fn_IDD_DtaDstLng            * Load next
00002BC0  6000 00BE               2241                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002BC4                          2242  
00002BC4  33DA 00002D1A           2243  Fn_IDD_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002BCA  13FC 0000 00002D1E      2244                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002BD2  6000 00AE               2245                      BRA     Fn_IDD_Done
00002BD6  33DA 00002D1A           2246  Fn_IDD_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002BDC  13FC 0001 00002D1E      2247                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002BE4  6000 009C               2248                      BRA     Fn_IDD_Done
00002BE8  23DA 00002D1A           2249  Fn_IDD_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002BEE  13FC 0002 00002D1E      2250                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002BF6  6000 008A               2251                      BRA     Fn_IDD_Done
00002BFA                          2252              
00002BFA  0C39 0000 00002D17      2253  Fn_IDD_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002C02  6700 0058               2254                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002C06  0C39 0001 00002D17      2255                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002C0E  6700 005E               2256                      BEQ     Fn_IDD_DtaSrcLng            * Load next long
00002C12  0C39 0004 00002D17      2257                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002C1A  6700 0006               2258                      BEQ     Fn_IDD_DtaSrcImd            * Load first word into word one
00002C1E  6000 0060               2259                      BRA     FN_IDD_Error                * Invalid register value
00002C22                          2260                      
00002C22  0C39 0001 00002CAC      2261  Fn_IDD_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002C2A  6700 001E               2262                      BEQ     Fn_IDD_DtaSrcByt            * Load next byte
00002C2E  0C39 0003 00002CAC      2263                      CMP.B   #3, opID                    * opID = 3 - size is word
00002C36  6700 0024               2264                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002C3A  0C39 0002 00002CAC      2265                      CMP.B   #2, opID                    * opID = 0 - size is long
00002C42  6700 002A               2266                      BEQ     Fn_IDD_DtaSrcLng            * Load next
00002C46  6000 0038               2267                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002C4A                          2268  
00002C4A  33DA 00002D20           2269  Fn_IDD_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002C50  13FC 0000 00002D24      2270                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002C58  6000 0028               2271                      BRA     Fn_IDD_Done
00002C5C  33DA 00002D20           2272  Fn_IDD_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002C62  13FC 0001 00002D24      2273                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002C6A  6000 0016               2274                      BRA     Fn_IDD_Done
00002C6E  23DA 00002D20           2275  Fn_IDD_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002C74  13FC 0002 00002D24      2276                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002C7C  6000 0004               2277                      BRA     Fn_IDD_Done
00002C80                          2278  
00002C80                          2279  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
00002C80                          2280                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002C80  4E75                    2281                      RTS   
00002C82                          2282  
00002C82  13FC 0000 00002CAD      2283  Fn_IDD_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002C8A  4E75                    2284              RTS
00002C8A  4E75                    2285  -------------------- end include --------------------
00002C8C                          2286                      INCLUDE 'SR_IDE.X68'
00002C8C                          2287  
00002C8C                          2288  SR_IDE
00002C8C                          2289  
00002C8C  4E75                    2290                RTS
00002C8C  4E75                    2291  -------------------- end include --------------------
00002C8E                          2292  
00002C8E                          2293  ** -----------------------------------------------------------
00002C8E                          2294  ** Variables and constants
00002C8E                          2295  ** -----------------------------------------------------------
00002C8E                          2296  
00002C8E  =0000001A               2297  maxLines            EQU      26                      * Max lines to display
00002C8E                          2298  
00002C8E= 00000000                2299  adrValStart         DC.L     $00000000               * Value of starting address - set by user
00002C92= 38 39 41 42 43 44 ...   2300  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
00002C9B= FF                      2301  adrStsStart         DC.B     $FF                     * Status of starting address
00002C9C                          2302                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002C9C= 00000000                2303  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
00002CA0= 38 39 41 42 43 44 ...   2304  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
00002CA9= FF                      2305  adrStsEnd           DC.B     $FF                     * Status of ending address
00002CAA                          2306                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002CAA                          2307  
00002CAA= 0000                    2308  opWord              DC.W     $0000                   * 16 bit instruction Word
00002CAC= 00                      2309  opID                DC.B     $00                     * First 4 bit value ID
00002CAD= 01                      2310  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
00002CAE                          2311  
00002CAE= 00000000                2312  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
00002CB2= 38 39 41 42 43 44 ...   2313  opStrAdr            DC.B     '89ABCDEF',0            * String address
00002CBC= 00000000                2314  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
00002CC0                          2315  
00002CC0= 50 6C 61 63 65 68 ...   2316  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
00002D10= 00000000                2317  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002D14                          2318  
00002D14= FF                      2319  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002D15                          2320  
00002D15= FF                      2321  opDstReg            DC.B     $FF                     * Destination Register Value
00002D16= FF                      2322  opDstMod            DC.B     $FF                     * Destination Mode Value
00002D17= FF                      2323  opSrcReg            DC.B     $FF                     * Source Register Value
00002D18= FF                      2324  opSrcMod            DC.B     $FF                     * Source Register Mode
00002D19                          2325  
00002D1A= 00000000                2326  opDta1              DC.L     $00000000               * Data value one (most likely source)
00002D1E= FF                      2327  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
00002D20= 00000000                2328  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002D24= FF                      2329  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002D25= 30 30 30 30 00          2330  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002D2A= 30 30 30 30 30 30 ...   2331  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002D33                          2332  
00002D34= 00000000                2333  opMask              DC.L     $00000000               * Mask for MOVEM
00002D38= 00                      2334  opRotate            DC.B     $00                     * Rotation for IDE(14)
00002D39= 00                      2335  opSizDir            DC.B     $00                     * Size/Direction for IDE(14)
00002D3A= 00                      2336  opIR                DC.B     $00                     * Immediate/Rotate for IDE(14)
00002D3B                          2337  
00002D3B= 44 41 54 41 00          2338  opNam_DATA          DC.B     'DATA',0
00002D40= 4D 4F 56 45 00          2339  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
00002D45= 4D 4F 56 45 41 00       2340  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002D4B= 4C 45 41 00             2341  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002D4F= 4E 4F 54 00             2342  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002D53= 4D 4F 56 45 4D 00       2343  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
00002D59= 4E 4F 50 00             2344  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002D5D= 52 54 53 00             2345  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002D61= 4A 53 52 00             2346  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
00002D65= 41 44 44 51 00          2347  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002D6A= 42 52 41 00             2348  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002D6E= 42 45 51 00             2349  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002D72= 42 47 54 00             2350  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
00002D76= 42 4C 45 00             2351  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
00002D7A= 4D 4F 56 45 51 00       2352  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
00002D80= 4F 52 00                2353  opNam_OR            DC.B     'OR',0                  * String value for instruction
00002D83= 53 55 42 00             2354  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
00002D87= 41 4E 44 00             2355  opNam_AND           DC.B     'AND',0                 * String value for instruction
00002D8B= 41 44 44 00             2356  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
00002D8F= 41 44 44 41 00          2357  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
00002D94= 41 53 4C 00             2358  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
00002D98= 41 53 52 00             2359  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
00002D9C= 4C 53 4C 00             2360  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
00002DA0= 4C 53 52 00             2361  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
00002DA4= 52 4F 4C 00             2362  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
00002DA8= 52 4F 52 00             2363  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
00002DAC                          2364  
00002DAC= 2E 42 00                2365  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
00002DAF= 2E 57 00                2366  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
00002DB2= 2E 4C 00                2367  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
00002DB5                          2368  
00002DB5= 50 6C 61 63 65 68 ...   2369  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
00002E06= 45 72 72 6F 72 00       2370  msgErr              DC.B     'Error',0               * Debug message
00002E0C                          2371  
00002E0C= 33 20 43 6F 72 65 ...   2372  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002E23= 4D 65 6D 6F 72 79 ...   2373  msgHdr02a           DC.B     'Memory range:',0
00002E31= 20 74 6F 20 00          2374  msgHdr02b           DC.B     ' to ',0
00002E36                          2375  
00002E36= 20 2D 20 41 6C 6C ...   2376  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
00002E65= 20 2D 20 56 61 6C ...   2377  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
00002E97= 20 2D 20 53 74 61 ...   2378  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
00002ECC= 20 20 20 40 20 58 ...   2379  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002EEB= 20 2D 20 41 64 64 ...   2380  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002F2C= 20 20 20 28 61 75 ...   2381  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002F41= 50 6C 65 61 73 65 ...   2382  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00002F63= 49 6E 76 61 6C 69 ...   2383  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
00002F85= 49 6E 76 61 6C 69 ...   2384  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
00002FB2= 53 74 61 72 74 69 ...   2385  msgStrAdr1Scc       DC.B     'Starting address: ',0
00002FC5= 50 6C 65 61 73 65 ...   2386  msgStrAdr2          DC.B     'Please enter an ending address: ',0
00002FE6= 49 6E 76 61 6C 69 ...   2387  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
00003006= 49 6E 76 61 6C 69 ...   2388  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
00003031                          2389  
00003031= 48 69 74 20 45 6E ...   2390  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
00003054= 59 6F 75 20 68 61 ...   2391  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
00003087= 20 20 20 20 20 20 ...   2392  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
000030B9= 54 68 61 6E 6B 20 ...   2393  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
000030E3                          2394  
000030E3= 2A 2A 2A 2A 2A 2A ...   2395  msgLine             DC.B     '**************************************************',CR,LF,0
00003118= 0D 0A 00                2396  msgNewLine          DC.B     CR,LF,0
0000311B= 2C 00                   2397  opComma             DC.B     ',',0
0000311D= 2E 00                   2398  opPeriod            DC.B     '.',0
0000311F= 20 00                   2399  opSpace             DC.B     ' ',0
00003122= 0900                    2400  opTab               DC.W     $0900                  * Tab - doesn't work as expected
00003124= 00                      2401  opBlank             DC.B     '',0
00003125  =0000000D               2402  CR                  EQU      $0D                     * ASCII code for Carriage Return
00003125  =0000000A               2403  LF                  EQU      $0A                     * ASCII code for Line Feed
00003125                          2404  
00003125                          2405                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           2CA0
ADRSTRSTART         2C92
ADRSTSEND           2CA9
ADRSTSSTART         2C9B
ADRVALEND           2C9C
ADRVALSTART         2C8E
CR                  D
FN_ASCII_LCLTR      19B6
FN_ASCII_NUM        19AA
FN_ASCII_UCLTR      19B0
FN_CPY_STR_DONE     1A14
FN_CPY_STR_LOOP     1A06
FN_DSP_DATA         15EC
FN_DSP_DONE         1984
FN_DSP_DTA1         1684
FN_DSP_DTA1_00      16DC
FN_DSP_DTA1_01      16F0
FN_DSP_DTA1_02      1704
FN_DSP_DTA1_03      1720
FN_DSP_DTA1_04      1740
FN_DSP_DTA1_07      1760
FN_DSP_DTA1_BYT     1788
FN_DSP_DTA1_ERR     17EE
FN_DSP_DTA1_LNG     17CC
FN_DSP_DTA1_WRD     17AA
FN_DSP_DTA2         180A
FN_DSP_DTA2_00      1862
FN_DSP_DTA2_01      1876
FN_DSP_DTA2_02      188A
FN_DSP_DTA2_03      18A6
FN_DSP_DTA2_04      18C6
FN_DSP_DTA2_07      18E6
FN_DSP_DTA2_BYT     190E
FN_DSP_DTA2_ERR     1974
FN_DSP_DTA2_LNG     1952
FN_DSP_DTA2_WRD     1930
FN_DSP_INSTR        1608
FN_DSP_OPR1         1678
FN_DSP_OPR2         17FE
FN_DSP_SIZB         1648
FN_DSP_SIZL         1668
FN_DSP_SIZW         1658
FN_HEX_LTR          19CE
FN_HEX_NUM          19C8
FN_HEX_STR_DONE     1A00
FN_HEX_STR_LOOP     19D4
FN_ID3_CHKDSTMOD    1C02
FN_ID3_CHKDSTREG    1C12
FN_ID3_CHKSRCREG    1B7C
FN_ID3_DONE         1C52
FN_ID3_DTADSTLNG    1C40
FN_ID3_DTADSTWRD    1C2E
FN_ID3_DTASRCBYT    1BCC
FN_ID3_DTASRCIMD    1BA4
FN_ID3_DTASRCLNG    1BF0
FN_ID3_DTASRCWRD    1BDE
FN_ID3_ERROR        1C5A
FN_ID3_INS01        1A9C
FN_ID3_INS02        1AAC
FN_ID3_SIZB         1B48
FN_ID3_SIZL         1B60
FN_ID3_SIZW         1B54
FN_ID3_SRCMOD       1B6C
FN_ID3_VERIFY       1AC4
FN_ID4_CHECKD1      1D0E
FN_ID4_CHECKD2      1D32
FN_ID4_CHECKD3      1D62
FN_ID4_DATA         2058
FN_ID4_DONE         20E0
FN_ID4_DTABYT       20A8
FN_ID4_DTAIMD       2080
FN_ID4_DTALNG       20CC
FN_ID4_DTAWRD       20BA
FN_ID4_ERROR        20DE
FN_ID4_JSR          1D7A
FN_ID4_JSR_SRC      1E16
FN_ID4_LEA          1E26
FN_ID4_LEA_SRC      1E86
FN_ID4_MOVEMMTOR    1F06
FN_ID4_MOVEMRTOM    1E96
FN_ID4_MOVEM_SRC    1F72
FN_ID4_NOP          1F82
FN_ID4_NOT          1FC2
FN_ID4_NOT_SRC      1FFE
FN_ID4_RTS          2018
FN_ID4_VERIFY_JSR   1D86
FN_ID4_VERIFY_LEA   1E32
FN_ID4_VERIFY_MMR   1F12
FN_ID4_VERIFY_MRM   1EA2
FN_ID4_VERIFY_NOP   1F8E
FN_ID4_VERIFY_NOT   1FCE
FN_ID4_VERIFY_RTS   2024
FN_ID5_CHKDSTMOD    2200
FN_ID5_CHKDSTREG    2210
FN_ID5_DONE         2252
FN_ID5_DTADSTLNG    223E
FN_ID5_DTADSTWRD    222C
FN_ID5_DTASRCBYT    21CA
FN_ID5_DTASRCIMD    21A2
FN_ID5_DTASRCLNG    21EE
FN_ID5_DTASRCWRD    21DC
FN_ID5_ERROR        2250
FN_ID5_VERIFY       2162
FN_ID6_BEQ          22DC
FN_ID6_BGT          22E6
FN_ID6_BLE          22F0
FN_ID6_BRA          22D2
FN_ID6_DISPLACEMENT  22F6
FN_ID6_DONE         234A
FN_ID6_DSPLCMNT16   2324
FN_ID6_DSPLCMNT32   2336
FN_ID6_ERROR        2348
FN_ID7_DONE         23DA
FN_ID7_ERROR        23D8
FN_ID8_CASE1        2478
FN_ID8_CASE2        24BA
FN_ID8_DATADST      24E2
FN_ID8_DATASRC      2568
FN_ID8_DONE         25F0
FN_ID8_DTADSTBYT    2532
FN_ID8_DTADSTIMD    250A
FN_ID8_DTADSTLNG    2556
FN_ID8_DTADSTWRD    2544
FN_ID8_DTASRCBYT    25B8
FN_ID8_DTASRCIMD    2590
FN_ID8_DTASRCLNG    25DC
FN_ID8_DTASRCWRD    25CA
FN_ID8_ERROR        25EE
FN_ID9_CASE1        268E
FN_ID9_CASE2        26D0
FN_ID9_DATADST      26F8
FN_ID9_DATASRC      277E
FN_ID9_DONE         2806
FN_ID9_DTADSTBYT    2748
FN_ID9_DTADSTIMD    2720
FN_ID9_DTADSTLNG    276C
FN_ID9_DTADSTWRD    275A
FN_ID9_DTASRCBYT    27CE
FN_ID9_DTASRCIMD    27A6
FN_ID9_DTASRCLNG    27F2
FN_ID9_DTASRCWRD    27E0
FN_ID9_ERROR        2804
FN_IDA_DONE         2810
FN_IDB_DONE         2812
FN_IDC_CASE1        28A8
FN_IDC_CASE2        28EA
FN_IDC_DATADST      2912
FN_IDC_DATASRC      2998
FN_IDC_DONE         2A20
FN_IDC_DTADSTBYT    2962
FN_IDC_DTADSTIMD    293A
FN_IDC_DTADSTLNG    2986
FN_IDC_DTADSTWRD    2974
FN_IDC_DTASRCBYT    29E8
FN_IDC_DTASRCIMD    29C0
FN_IDC_DTASRCLNG    2A0C
FN_IDC_DTASRCWRD    29FA
FN_IDC_ERROR        2A1E
FN_IDD_CASE1        2AD0
FN_IDD_CASE2        2B18
FN_IDD_CASE3        2B46
FN_IDD_DATADST      2B74
FN_IDD_DATASRC      2BFA
FN_IDD_DONE         2C82
FN_IDD_DTADSTBYT    2BC4
FN_IDD_DTADSTIMD    2B9C
FN_IDD_DTADSTLNG    2BE8
FN_IDD_DTADSTWRD    2BD6
FN_IDD_DTASRCBYT    2C4A
FN_IDD_DTASRCIMD    2C22
FN_IDD_DTASRCLNG    2C6E
FN_IDD_DTASRCWRD    2C5C
FN_IDD_ERROR        2C80
FN_MAIN_CHKAGN      1162
FN_MAIN_CHKEND      1154
FN_MAIN_CHKLIN      111C
FN_MAIN_CHKPAG      1132
FN_MAIN_CONTINUE    119A
FN_MAIN_DONE        119E
FN_MAIN_DSP         1116
FN_MAIN_ERRINS      1110
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_UI_CHKHEX        13FE
FN_UI_CHKHEXASL     1452
FN_UI_CHKHEXDONE    143A
FN_UI_CHKHEXLOOP    1404
FN_UI_CHKHEXRDR     1454
FN_UI_CHKLEN        13CA
FN_UI_CHKVAL        14DE
FN_UI_CHKVALCMP     1512
FN_UI_CHKVALEBIG    150C
FN_UI_CHKVALEMAX    14FE
FN_UI_CHKVALSBIG    14F8
FN_UI_CHKVALSMAX    14EA
FN_UI_CHKVALSONE    1538
FN_UI_CHKVALSWP     151C
FN_UI_CHKVALSWRD    1522
FN_UI_DONE          153A
FN_UI_DSPSTART      127A
FN_UI_END           1372
FN_UI_ENDE1         138E
FN_UI_ENDE2         139E
FN_UI_END_IN        13AE
FN_UI_HDRNEXT       129E
FN_UI_LOOP          1248
FN_UI_SETEHEX       14B6
FN_UI_SETEHEXI1     14C6
FN_UI_SETEHEXI2     14D2
FN_UI_SETELEN       13D6
FN_UI_SETELENI1     13E6
FN_UI_SETELENI2     13F2
FN_UI_SETVHEX       145E
FN_UI_SETVHEXI1     146E
FN_UI_SETVHEXI2     1492
FN_UI_START         131A
FN_UI_STARTE1       1336
FN_UI_STARTE2       1346
FN_UI_START_IN      1356
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             30B9
MSGENDMEM01         3054
MSGENDMEM02         3087
MSGERR              2E06
MSGHDR01            2E0C
MSGHDR02A           2E23
MSGHDR02B           2E31
MSGINTEMP           2DB5
MSGLINE             30E3
MSGNEWLINE          3118
MSGPAGE             3031
MSGSTRADR1          2F41
MSGSTRADR1ERR1      2F63
MSGSTRADR1ERR2      2F85
MSGSTRADR1SCC       2FB2
MSGSTRADR2          2FC5
MSGSTRADR2ERR1      2FE6
MSGSTRADR2ERR2      3006
MSGSTRINTRO         2E36
MSGSTRNOTE          2EEB
MSGSTRNOTEMORE      2F2C
MSGSTRRANGE         2E65
MSGSTRSIZE          2E97
MSGSTRSIZEEXMPL     2ECC
OPBLANK             3124
OPCOMMA             311B
OPDSTMOD            2D16
OPDSTREG            2D15
OPDTA1              2D1A
OPDTA1T             2D1E
OPDTA2              2D20
OPDTA2T             2D24
OPERR               2CAD
OPID                2CAC
OPIR                2D3A
OPMASK              2D34
OPNAM_ADD           2D8B
OPNAM_ADDA          2D8F
OPNAM_ADDQ          2D65
OPNAM_AND           2D87
OPNAM_ASL           2D94
OPNAM_ASR           2D98
OPNAM_BEQ           2D6E
OPNAM_BGT           2D72
OPNAM_BLE           2D76
OPNAM_BRA           2D6A
OPNAM_DATA          2D3B
OPNAM_JSR           2D61
OPNAM_LEA           2D4B
OPNAM_LSL           2D9C
OPNAM_LSR           2DA0
OPNAM_MOVE          2D40
OPNAM_MOVEA         2D45
OPNAM_MOVEM         2D53
OPNAM_MOVEQ         2D7A
OPNAM_NOP           2D59
OPNAM_NOT           2D4F
OPNAM_OR            2D80
OPNAM_ROL           2DA4
OPNAM_ROR           2DA8
OPNAM_RTS           2D5D
OPNAM_SUB           2D83
OPNXTADR            2CBC
OPOUTBUF            2CC0
OPPERIOD            311D
OPPTRNAM            2D10
OPROTATE            2D38
OPSIZB              2DAC
OPSIZDIR            2D39
OPSIZL              2DB2
OPSIZW              2DAF
OPSPACE             311F
OPSRCMOD            2D18
OPSRCREG            2D17
OPSTRADR            2CB2
OPSTRDTALNG         2D2A
OPSTRDTAWRD         2D25
OPTAB               3122
OPVALADR            2CAE
OPVALSIZ            2D14
OPWORD              2CAA
SR_ASCII_HEX        1996
SR_CNT_STR_BUF      1A16
SR_CPY_STR_BUF      1A06
SR_DSP_DISPLAY      15B4
SR_DSP_HEADER       1552
SR_HEX_ASCII        19BC
SR_HEX_STR          19D4
SR_ID3              1A1A
SR_ID4              1C5C
SR_ID5              20EA
SR_ID6              225C
SR_ID7              2354
SR_ID8              23E4
SR_ID9              25FA
SR_IDA              2810
SR_IDB              2812
SR_IDC              2814
SR_IDD              2A2A
SR_IDE              2C8C
SR_IDX              1A18
SR_JUMP             11B8
SR_UI_INPUT         1238
