00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/6/2021 11:36:04 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 000025BC    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 000025CA    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 000025BC             51                      LEA     adrValStart,A4
00001020  4BF9 000025C0             52                      LEA     adrStrStart,A5
00001026  4EB9 000019B2             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 000025CA             54                      LEA     adrValEnd,A4
00001032  4BF9 000025CE             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019B2             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 00001196             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 000025BC             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001530             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 000025DC             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 000025D8             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 000025EA             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 000025DA        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 000025DB        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002642        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002643        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002644        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002645        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002646        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002648    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 0000264C        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 0000264E    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002652        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA                            96                      ** Jump table
000010CA                            97                      **
000010CA  3A39 000025D8             98                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010D0  1C3C 000C                 99                      MOVE.B  #12,D6
000010D4  EC6D                     100                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010D6  CAFC 0008                101                      MULU    #8,D5                   * offset is multiple of 8
000010DA  4EB0 5000                102                      JSR     0(A0,D5)                * Jump indirect with index
000010DE                           103  
000010DE                           104                      ** Invalid instruction
000010DE                           105                      **
000010DE  0C39 0001 000025DB       106                      CMP.B   #1,opErr
000010E6  6700 0006                107                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
000010EA  6000 0008                108                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
000010EE  2479 000025EA            109  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
000010F4                           110  
000010F4                           111                      ** Display result
000010F4                           112                      **
000010F4  4EB9 00001592            113  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
000010FA                           114  
000010FA                           115                      ** Max lines display stop, wait for enter
000010FA                           116                      **
000010FA  5207                     117  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
000010FC                           118  
000010FC  2C07                     119                      MOVE.L  D7,D6                   * Line counter to D6 for division
000010FE  8CFC 001A                120                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001102  4846                     121                      SWAP    D6                      * Swap for remainder (modulo)
00001104  BC3C 0000                122                      CMP.B   #0,D6                   * Check remainder for zero
00001108  6700 0006                123                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000110C  6000 0024                124                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001110                           125  
00001110                           126                      ** Logic to check ENTER key to show next page
00001110                           127                      **
00001110  43F9 00002957            128  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001116  103C 000E                129                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000111A  4E4F                     130                      TRAP    #15                     * Display to screen
0000111C  103C 0005                131                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001120  4E4F                     132                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001122                           133  
00001122                           134                      ** Clear screen
00001122  103C 000B                135                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001126  323C FF00                136                      MOVE.W  #$FF00,D1               * Clear the screen
0000112A  4E4F                     137                      TRAP    #15
0000112C                           138  
0000112C                           139                      ** Display header
0000112C  4EB9 00001530            140                      JSR     SR_DSP_HEADER
00001132                           141  
00001132                           142                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001132                           143                      **
00001132  B5F9 000025CA            144  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
00001138  6C00 0006                145                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000113C  6000 003A                146                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001140                           147  
00001140                           148                      ** Logic to check for for Y or N to check another region of memory
00001140                           149                      **
00001140  43F9 0000297A            150  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001146  103C 000E                151                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000114A  4E4F                     152                      TRAP    #15                     * Display to screen
0000114C  43F9 000029AD            153                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001152  103C 000E                154                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001156  4E4F                     155                      TRAP    #15                     * Display to screen
00001158                           156  
00001158  43F9 000026DB            157                      LEA     msgInTemp,A1            * Load placeholder for input string
0000115E  103C 0002                158                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001162  4E4F                     159                      TRAP    #15                     * Read string to (A1), length in D1.W
00001164  0C11 0059                160                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
00001168  6700 FE9C                161                      BEQ     Fn_MAIN_Start           * Restart program
0000116C  0C11 0079                162                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001170  6700 FE94                163                      BEQ     Fn_MAIN_Start           * Restart program
00001174  6000 0006                164                      BRA     Fn_Main_Done            * Exit program
00001178                           165  
00001178  6000 FEE2                166  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000117C                           167  
0000117C                           168  Fn_MAIN_Done        ** That's all folks
0000117C  103C 000B                169                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001180  323C FF00                170                      MOVE.W  #$FF00,D1               * Clear the screen
00001184  4E4F                     171                      TRAP    #15
00001186                           172  
00001186                           173                      ** Thank you message
00001186  43F9 000029DF            174                      LEA     msgDone,A1              * Loads MESSAGE into A1
0000118C  103C 000E                175                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001190  4E4F                     176                      TRAP    #15                     * Display to screen
00001192                           177  
00001192                           178  
00001192  4E72 2700                179                      STOP   #$2700                   * Stop execution
00001196                           180  
00001196                           181  ** -----------------------------------------------------------
00001196                           182  ** JUMP TABLE: First 4 bits of instruction
00001196                           183  **
00001196                           184  ** Jump instruction: pointing to label (xxx).L
00001196                           185  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
00001196                           186  **                          label address (Long)
00001196                           187  **
00001196                           188  ** RTS instruction:
00001196                           189  **  |4    E    |7    5     |               - Offset 2 bytes
00001196                           190  **
00001196                           191  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
00001196                           192  **
00001196                           193  ** Note: should find a value since 4 bits is 0 to F
00001196                           194  ** Note: There aren't any instructions that start with F
00001196                           195  **
00001196                           196  ** -----------------------------------------------------------
00001196  4EB9 000019F6            197  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
0000119C  4E75                     198                      RTS
0000119E  4EB9 000019F8            199                      JSR     SR_ID3
000011A4  4E75                     200                      RTS
000011A6  4EB9 000019F8            201                      JSR     SR_ID3
000011AC  4E75                     202                      RTS
000011AE  4EB9 000019F8            203                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011B4  4E75                     204                      RTS
000011B6  4EB9 00001C3A            205                      JSR     SR_ID4
000011BC  4E75                     206                      RTS
000011BE  4EB9 000020C0            207                      JSR     SR_ID5
000011C4  4E75                     208                      RTS
000011C6  4EB9 0000222A            209                      JSR     SR_ID6
000011CC  4E75                     210                      RTS
000011CE  4EB9 0000231A            211                      JSR     SR_ID7
000011D4  4E75                     212                      RTS
000011D6  4EB9 000023A2            213                      JSR     SR_ID8
000011DC  4E75                     214                      RTS
000011DE  4EB9 000025AA            215                      JSR     SR_ID9
000011E4  4E75                     216                      RTS
000011E6  4EB9 000025AE            217                      JSR     SR_IDA
000011EC  4E75                     218                      RTS
000011EE  4EB9 000025B0            219                      JSR     SR_IDB
000011F4  4E75                     220                      RTS
000011F6  4EB9 000025B2            221                      JSR     SR_IDC
000011FC  4E75                     222                      RTS
000011FE  4EB9 000025B6            223                      JSR     SR_IDD
00001204  4E75                     224                      RTS
00001206  4EB9 000025BA            225                      JSR     SR_IDE
0000120C  4E75                     226                      RTS
0000120E  4EB9 000019F6            227                      JSR     SR_IDX                   * No instructions @ ID=15
00001214  4E75                     228                      RTS
00001216                           229  
00001216                           230  ** -----------------------------------------------------------
00001216                           231  ** UI: User mem input
00001216                           232  ** -----------------------------------------------------------
00001216                           233  SR_UI_INPUT
00001216  13F8 00FF 000025C9       234                      MOVE.B  $FF,adrStsStart         * Reset starting address status
0000121E  13F8 00FF 000025D7       235                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001226                           236  
00001226                           237  Fn_UI_Loop          ** Clear screen
00001226  103C 000B                238                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000122A  323C FF00                239                      MOVE.W  #$FF00,D1               * Clear the screen
0000122E  4E4F                     240                      TRAP    #15
00001230                           241  
00001230                           242                      ** Header
00001230                           243                      ** ***************************************
00001230                           244  
00001230  43F9 00002A09            245                      LEA     msgLine,A1              * '********************'
00001236  103C 000E                246                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000123A  4E4F                     247                      TRAP    #15                     * Display to screen
0000123C                           248  
0000123C  43F9 00002732            249                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001242  103C 000E                250                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001246  4E4F                     251                      TRAP    #15                     * Display to screen
00001248                           252  
00001248  0C39 0000 000025C9       253                      CMP.B   #0,adrStsStart          * Starting address is set
00001250  6700 0006                254                      BEQ     Fn_UI_DspStart          * Display starting address
00001254  6000 0026                255                      BRA     Fn_UI_HdrNext           * Display the rest of the header
00001258                           256  
00001258  43F9 000028D8            257  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
0000125E  103C 000E                258                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001262  4E4F                     259                      TRAP    #15                     * Display to screen
00001264                           260  
00001264  43F9 000025C0            261                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000126A  103C 000E                262                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000126E  4E4F                     263                      TRAP    #15                     * Display to screen
00001270                           264  
00001270  43F9 00002A3E            265                      LEA     msgNewLine,A1           * CR,LF
00001276  103C 000E                266                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000127A  4E4F                     267                      TRAP    #15                     * Display to screen
0000127C                           268  
0000127C  43F9 00002A09            269  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
00001282  103C 000E                270                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001286  4E4F                     271                      TRAP    #15                     * Display to screen
00001288                           272  
00001288  43F9 0000275C            273                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
0000128E  103C 000E                274                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001292  4E4F                     275                      TRAP    #15                     * Display to screen
00001294                           276  
00001294  43F9 0000278B            277                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
0000129A  103C 000E                278                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129E  4E4F                     279                      TRAP    #15                     * Display to screen
000012A0                           280  
000012A0  43F9 000027BD            281                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012A6  103C 000E                282                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012AA  4E4F                     283                      TRAP    #15                     * Display to screen
000012AC                           284  
000012AC  43F9 000027F2            285                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012B2  103C 000E                286                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B6  4E4F                     287                      TRAP    #15                     * Display to screen
000012B8                           288  
000012B8  43F9 00002811            289                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012BE  103C 000E                290                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C2  4E4F                     291                      TRAP    #15                     * Display to screen
000012C4                           292  
000012C4  43F9 00002852            293                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012CA  103C 000E                294                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CE  4E4F                     295                      TRAP    #15                     * Display to screen
000012D0                           296  
000012D0  43F9 00002A3E            297                      LEA     msgNewLine,A1           * CR,LF
000012D6  103C 000E                298                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012DA  4E4F                     299                      TRAP    #15                     * Display to screen
000012DC                           300  
000012DC                           301                      ** Input check
000012DC                           302                      ** ***************************************
000012DC                           303  
000012DC  0C39 0000 000025C9       304                      CMP.B #0,adrStsStart            * Check status of address 0 = success
000012E4  6600 0012                305                      BNE   Fn_UI_Start               * Input starting address
000012E8                           306  
000012E8  0C39 0000 000025D7       307                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
000012F0  6600 005E                308                      BNE   Fn_UI_End                 * Input ending address
000012F4                           309  
000012F4                           310                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
000012F4  6000 01C6                311                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
000012F8                           312  
000012F8                           313  Fn_UI_Start         ** Input Start Address
000012F8                           314                      ** ***************************************
000012F8                           315  
000012F8                           316                      ** Check errors
000012F8  0C39 0001 000025C9       317                      CMP.B   #1,adrStsStart
00001300  6700 0012                318                      BEQ     Fn_UI_StartE1           * Error: length
00001304  0C39 0002 000025C9       319                      CMP.B   #2,adrStsStart
0000130C  6700 0016                320                      BEQ     Fn_UI_StartE2           * Error: hex value
00001310  6000 0022                321                      BRA     Fn_UI_Start_In          * No error: ask for input
00001314                           322  
00001314  43F9 00002889            323  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000131A  103C 000E                324                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000131E  4E4F                     325                      TRAP    #15
00001320  6000 0012                326                      BRA     Fn_UI_Start_In          * User input
00001324                           327  
00001324  43F9 000028AB            328  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000132A  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000132E  4E4F                     330                      TRAP    #15
00001330  6000 0002                331                      BRA     Fn_UI_Start_In          * User input
00001334                           332  
00001334  43F9 00002867            333  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000133A  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000133E  4E4F                     335                      TRAP    #15                     * Display to screen
00001340                           336  
00001340  43F9 000026DB            337                      LEA     msgInTemp,A1            * Load placeholder for input string
00001346  103C 0002                338                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000134A  4E4F                     339                      TRAP    #15                     * Read string to (A1), length in D1.W
0000134C                           340  
0000134C  6000 005A                341                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001350                           342  
00001350                           343  Fn_UI_End           ** Input End Address
00001350                           344                      ** ***************************************
00001350                           345  
00001350                           346                      ** Check errors
00001350  0C39 0001 000025D7       347                      CMP.B   #1,adrStsEnd
00001358  6700 0012                348                      BEQ     Fn_UI_EndE1             * Error: length
0000135C  0C39 0002 000025D7       349                      CMP.B   #2,adrStsEnd
00001364  6700 0016                350                      BEQ     Fn_UI_EndE2             * Error: hex value
00001368  6000 0022                351                      BRA     Fn_UI_End_In            * No error: ask for input
0000136C                           352  
0000136C  43F9 0000290C            353  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001372  103C 000E                354                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001376  4E4F                     355                      TRAP    #15
00001378  6000 0012                356                      BRA     Fn_UI_End_In            * User input
0000137C                           357  
0000137C  43F9 0000292C            358  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
00001382  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001386  4E4F                     360                      TRAP    #15
00001388  6000 0002                361                      BRA     Fn_UI_End_In            * User input
0000138C                           362  
0000138C  43F9 000028EB            363  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
00001392  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001396  4E4F                     365                      TRAP    #15                     * Display to screen
00001398                           366  
00001398  43F9 000026DB            367                      LEA     msgInTemp,A1            * Load placeholder for input string
0000139E  103C 0002                368                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013A2  4E4F                     369                      TRAP    #15                     * Read string to (A1), length in D1.W
000013A4                           370  
000013A4  6000 0002                371                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013A8                           372  
000013A8                           373  Fn_UI_ChkLen        ** Check length
000013A8                           374                      **   length should be 8 ascii characters
000013A8                           375                      **   value stored in D1.W from input
000013A8                           376                      ** ***************************************
000013A8                           377  
000013A8  B27C 0008                378                      CMP.W   #8,D1                   * Address should be 8 chars long
000013AC  6600 0006                379                      BNE     Fn_UI_SetELen           * Invalid address length
000013B0  6000 002A                380                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013B4                           381  
000013B4                           382  Fn_UI_SetELen       ** Error: length
000013B4  0C39 0000 000025C9       383                      CMP.B #0,adrStsStart
000013BC  6600 0006                384                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013C0  6000 000E                385                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013C4                           386  Fn_UI_SetELenI1     ** Set error on input 1
000013C4  13FC 0001 000025C9       387                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013CC  6000 FE58                388                      BRA     Fn_UI_Loop
000013D0                           389  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013D0  13FC 0001 000025D7       390                      MOVE.B  #1,adrStsEnd
000013D8  6000 FE4C                391                      BRA     Fn_UI_Loop
000013DC                           392  
000013DC                           393  Fn_UI_ChkHex        ** Check hex values
000013DC                           394                      **   30 - 39 (0-9)
000013DC                           395                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013DC                           396                      ** ***************************************
000013DC                           397  
000013DC  163C 0000                398                      MOVE.B  #0,D3                   * Loop counter
000013E0  4286                     399                      CLR.L   D6                      * Temporary address storage
000013E2                           400  
000013E2                           401  Fn_UI_ChkHexLoop    ** Check hex values one at a time
000013E2  1819                     402                      MOVE.B  (A1)+,D4                * Unload byte and increment input
000013E4                           403  
000013E4  B83C 0030                404                      CMP.B   #$30,D4
000013E8  6D00 00AA                405                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
000013EC                           406  
000013EC  B83C 0039                407                      CMP.B   #$39,D4
000013F0  6F00 0026                408                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
000013F4                           409  
000013F4  B83C 0041                410                      CMP.B   #$41,D4
000013F8  6D00 009A                411                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
000013FC                           412  
000013FC  B83C 0046                413                      CMP.B   #$46,D4
00001400  6F00 0016                414                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001404                           415  
00001404  B83C 0061                416                      CMP.B   #$61,D4
00001408  6D00 008A                417                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140C                           418  
0000140C  B83C 0066                419                      CMP.B   #$66,D4
00001410  6F00 0006                420                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001414                           421  
00001414  6000 007E                422                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
00001418                           423  
00001418                           424  Fn_UI_ChkHexDone    ** Check if at end of loop
00001418                           425  
00001418  5203                     426                      ADDI.B  #1,D3                   * Increment loop counter
0000141A                           427  
0000141A                           428                      ** Insert ascii value into temp address
0000141A  1A04                     429                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000141C  4EB9 00001974            430                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001422  DC05                     431                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001424  B63C 0008                432                      CMP.B   #8,D3                   * To shift or not to shift
00001428  6D00 0006                433                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000142C  6000 0004                434                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001430  E986                     435  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001432                           436  
00001432                           437  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001432  B63C 0008                438                      CMP.B   #8,D3                   * Loop 8 times
00001436  66AA                     439                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
00001438  6000 0002                440                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000143C                           441  
0000143C                           442  Fn_UI_SetVHex       ** Valid: hex values
0000143C  0C39 0000 000025C9       443                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001444  6600 0006                444                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
00001448  6000 0026                445                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000144C                           446  
0000144C                           447  Fn_UI_SetVHexI1     ** Set valid on input 1
0000144C  13FC 0000 000025C9       448                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001454  23C6 000025BC            449                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000145A  49F9 000025BC            450                      LEA     adrValStart,A4
00001460  4BF9 000025C0            451                      LEA     adrStrStart,A5
00001466  4EB9 000019B2            452                      JSR     SR_HEX_STR              * Copy address value to string for display
0000146C  6000 FDB8                453                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001470                           454  
00001470                           455  Fn_UI_SetVHexI2     ** Set valid on input 2
00001470  13FC 0000 000025D7       456                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
00001478  23C6 000025CA            457                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
0000147E  49F9 000025CA            458                      LEA     adrValEnd,A4
00001484  4BF9 000025CE            459                      LEA     adrStrEnd,A5
0000148A  4EB9 000019B2            460                      JSR     SR_HEX_STR              * Copy address value to string for display
00001490  6000 FD94                461                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001494                           462  
00001494                           463  Fn_UI_SetEHex       ** Error: hex values
00001494  0C39 0000 000025C9       464                      CMP.B   #0,adrStsStart
0000149C  6600 0006                465                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014A0  6000 000E                466                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014A4                           467  
000014A4                           468  Fn_UI_SetEHexI1     ** Set error on input 1
000014A4  13FC 0002 000025C9       469                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014AC  6000 FD78                470                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014B0                           471  
000014B0                           472  Fn_UI_SetEHexI2     ** Set error on input 2
000014B0  13FC 0002 000025D7       473                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014B8  6000 FD6C                474                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014BC                           475  
000014BC                           476  Fn_UI_ChkVal        ** Check address range, order
000014BC                           477                      **   Address automagic - will fix addresses if invalid input
000014BC                           478                      ** Note: addresses are unsigned; should not be less than zero
000014BC                           479                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014BC                           480                      ** Note: subtracting one from Start address if not even
000014BC                           481                      **       doesn't really matter if end address is even or odd
000014BC                           482                      ** ***************************************
000014BC                           483  
000014BC  2A39 000025BC            484                      MOVE.L  adrValStart,D5
000014C2  2C39 000025CA            485                      MOVE.L  adrValEnd,D6
000014C8                           486  
000014C8  BABC 00FFFFEC            487  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014CE  6200 0006                488                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014D2  6000 0008                489                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014D6                           490  
000014D6  2A3C 00FFFFEC            491  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014DC                           492  
000014DC  BCBC 00FFFFED            493  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
000014E2  6200 0006                494                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
000014E6  6000 0008                495                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
000014EA                           496  
000014EA  2C3C 00FFFFED            497  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
000014F0                           498  
000014F0  BA86                     499  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
000014F2  6200 0006                500                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
000014F6  6000 0008                501                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
000014FA                           502  
000014FA  2805                     503  Fn_UI_ChkValSwp     MOVE.L  D5,D4
000014FC  2A06                     504                      MOVE.L  D6,D5
000014FE  2C04                     505                      MOVE.L  D4,D6
00001500                           506  
00001500                           507  FN_UI_ChkValSWrd    ** Check start for word boundry
00001500  1605                     508                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001502  183C 0002                509                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001506  86C4                     510                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
00001508  4843                     511                      SWAP    D3                       * Swap for remainder (the modulo part)
0000150A  B63C 0000                512                      CMP.B   #0,D3                    * If zero, then even
0000150E  6600 0006                513                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001512  6000 0004                514                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001516                           515  
00001516  5385                     516  Fn_UI_ChkValSOne    SUBI.L  #1,D5
00001518                           517  
00001518                           518  Fn_UI_Done          ** All done with input, time to go
00001518                           519                      ** ***************************************
00001518                           520  
00001518  23C5 000025BC            521                      MOVE.L  D5,adrValStart          * Move final address to Start
0000151E  23C6 000025CA            522                      MOVE.L  D6,adrValEnd            * Move final address to End
00001524                           523  
00001524                           524                      ** Clear screen
00001524  103C 000B                525                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001528  323C FF00                526                      MOVE.W  #$FF00,D1               * Clear the screen
0000152C  4E4F                     527                      TRAP    #15
0000152E                           528  
0000152E  4E75                     529                      RTS
00001530                           530  
00001530                           531  ** -----------------------------------------------------------
00001530                           532  ** UI: Display Header
00001530                           533  ** -----------------------------------------------------------
00001530                           534  SR_DSP_HEADER
00001530                           535  
00001530                           536                      ** Header line 03
00001530  43F9 00002A09            537                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001536  103C 000E                538                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000153A  4E4F                     539                      TRAP    #15                     * Display to screen
0000153C                           540  
0000153C                           541                      ** Header line 01
0000153C  43F9 00002732            542                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001542  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001546  4E4F                     544                      TRAP    #15                     * Display to screen
00001548                           545  
00001548                           546                      ** Header line 02
00001548  43F9 00002749            547                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
0000154E  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001552  4E4F                     549                      TRAP    #15                     * Display to screen
00001554                           550  
00001554  43F9 000025C0            551                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000155A  103C 000E                552                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155E  4E4F                     553                      TRAP    #15                     * Display to screen
00001560                           554  
00001560  43F9 00002757            555                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001566  103C 000E                556                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000156A  4E4F                     557                      TRAP    #15
0000156C                           558  
0000156C  43F9 000025CE            559                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001572  103C 000E                560                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001576  4E4F                     561                      TRAP    #15                     * Display to screen
00001578                           562  
00001578  43F9 00002A3E            563                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
0000157E  103C 000E                564                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001582  4E4F                     565                      TRAP    #15                     * Display to screen
00001584                           566  
00001584                           567                      ** Header line 03
00001584  43F9 00002A09            568                      LEA     msgLine,A1              * Loads MESSAGE into A1
0000158A  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158E  4E4F                     570                      TRAP    #15                     * Display to screen
00001590                           571  
00001590  4E75                     572                      RTS
00001592                           573  
00001592                           574  ** -----------------------------------------------------------
00001592                           575  ** UI: Display item
00001592                           576  ** -----------------------------------------------------------
00001592                           577  SR_DSP_DISPLAY
00001592                           578                      ** Output buffer
00001592                           579                      **   Need buffer for spacing issues
00001592                           580                      **
00001592  47F9 000025EE            581                      LEA     opOutBuf,A3             * Reset pointer to output buffer
00001598  16BC 0000                582                      MOVE.B  #$00,(A3)               * Insert NULL
0000159C                           583  
0000159C                           584                      ** Push opValAdr to opStrAdr
0000159C  49F9 000025DC            585                      LEA     opValAdr,A4             * input hex
000015A2  4BF9 000025E0            586                      LEA     opStrAdr,A5             * output string
000015A8  4EB9 000019B2            587                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015AE  49F9 000025E0            588                      LEA     opStrAdr,A4
000015B4  4EB9 000019E4            589                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015BA                           590  
000015BA                           591                      ** Instruction or DATA redirector
000015BA                           592                      **
000015BA  0C39 0001 000025DB       593                      CMP.B   #1, opErr               * Check instruction type
000015C2  6700 0006                594                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015C6  6000 001E                595                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015CA                           596  
000015CA                           597  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015CA                           598                      **
000015CA                           599  
000015CA                           600                      ** Space
000015CA  49F9 00002A45            601                      LEA     opSpace,A4
000015D0  4EB9 000019E4            602                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015D6                           603  
000015D6                           604                      ** Instruction name
000015D6  49F9 00002661            605                      LEA     opNam_DATA,A4
000015DC  4EB9 000019E4            606                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015E2                           607  
000015E2  6000 037E                608                      BRA     Fn_Dsp_Done
000015E6                           609  
000015E6                           610  Fn_Dsp_Instr        ** Process instruction
000015E6                           611                      **
000015E6                           612  
000015E6                           613                      ** Space
000015E6  49F9 00002A45            614                      LEA     opSpace,A4
000015EC  4EB9 000019E4            615                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F2                           616  
000015F2                           617                      ** Instruction name
000015F2  2879 0000263E            618                      MOVE.L  opPtrNam,A4
000015F8  4EB9 000019E4            619                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015FE                           620  
000015FE                           621                      ** Instruciton size
000015FE                           622                      **
000015FE  0C39 0000 00002642       623                      CMP.B   #0,opValSiz
00001606  6700 001E                624                      BEQ     Fn_DSP_SizB             * Size is Byte
0000160A  0C39 0001 00002642       625                      CMP.B   #1,opValSiz
00001612  6700 0022                626                      BEQ     Fn_DSP_SizW             * Size is Word
00001616  0C39 0002 00002642       627                      CMP.B   #2,opValSiz
0000161E  6700 0026                628                      BEQ     Fn_DSP_SizL             * Size is Long
00001622  6000 003E                629                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001626                           630  
00001626  49F9 000026D2            631  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000162C  4EB9 000019E4            632                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001632  6000 0022                633                      BRA     Fn_DSP_OPR1
00001636                           634  
00001636  49F9 000026D5            635  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000163C  4EB9 000019E4            636                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001642  6000 0012                637                      BRA     Fn_DSP_OPR1
00001646                           638  
00001646  49F9 000026D8            639  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000164C  4EB9 000019E4            640                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001652  6000 0002                641                      BRA     Fn_DSP_OPR1
00001656                           642  
00001656                           643  Fn_DSP_OPR1         ** Display First Operand
00001656  49F9 00002A48            644                      LEA     opTab,A4                * Tab (or calculated spaces)
0000165C  4EB9 000019E4            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001662                           646  
00001662                           647  Fn_DSP_DTA1         ** Data 1 (source)
00001662                           648                      ** **************************************************
00001662                           649                      **
00001662                           650  
00001662                           651                      ** Check if source mode set (may not have a source)
00001662  0C39 00FF 00002648       652                      CMP.B   #$FF,opDta1
0000166A  6700 017C                653                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
0000166E                           654  
0000166E                           655                      ** Check source mode
0000166E                           656                      **
0000166E  0C39 0000 00002646       657                      CMP.B   #0,opSrcMod
00001676  6700 0042                658                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000167A  0C39 0001 00002646       659                      CMP.B   #1,opSrcMod
00001682  6700 004A                660                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
00001686  0C39 0002 00002646       661                      CMP.B   #2,opSrcMod
0000168E  6700 0052                662                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
00001692  0C39 0003 00002646       663                      CMP.B   #3,opSrcMod
0000169A  6700 0062                664                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
0000169E  0C39 0004 00002646       665                      CMP.B   #4,opSrcMod
000016A6  6700 0076                666                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016AA  0C39 0007 00002646       667                      CMP.B   #7,opSrcMod
000016B2  6700 008A                668                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016B6                           669  
000016B6  6000 0114                670                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016BA                           671  
000016BA                           672  Fn_DSP_DTA1_00      ** Handling data mode 0
000016BA  16FC 0044                673                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016BE  1639 00002645            674                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016C4  0603 0030                675                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016C8  16C3                     676                      MOVE.B  D3,(A3)+                * Insert Register value
000016CA  6000 0110                677                      BRA     Fn_DSP_OPR2             * Display data 2
000016CE                           678  
000016CE                           679  Fn_DSP_DTA1_01      ** Handling data mode 1
000016CE  16FC 0041                680                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016D2  1639 00002645            681                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016D8  0603 0030                682                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016DC  16C3                     683                      MOVE.B  D3,(A3)+                * Insert Register value
000016DE  6000 00FC                684                      BRA     Fn_DSP_OPR2             * Display data 2
000016E2                           685  
000016E2                           686  Fn_DSP_DTA1_02      ** Handling data mode 2
000016E2  16FC 0028                687                      MOVE.B  #$28,(A3)+              * Insert '(' character
000016E6  16FC 0041                688                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016EA  1639 00002645            689                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016F0  0603 0030                690                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016F4  16C3                     691                      MOVE.B  D3,(A3)+                * Insert Register value
000016F6  16FC 0029                692                      MOVE.B  #$29,(A3)+              * Insert ')' character
000016FA  6000 00E0                693                      BRA     Fn_DSP_OPR2             * Display data 2
000016FE                           694  
000016FE                           695  Fn_DSP_DTA1_03      ** Handling data mode 3
000016FE  16FC 0028                696                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001702  16FC 0041                697                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001706  1639 00002645            698                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000170C  0603 0030                699                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001710  16C3                     700                      MOVE.B  D3,(A3)+                * Insert Register value
00001712  16FC 0029                701                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001716  16FC 002B                702                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000171A  6000 00C0                703                      BRA     Fn_DSP_OPR2             * Display data 2
0000171E                           704  
0000171E                           705  Fn_DSP_DTA1_04      ** Handling data mode 4
0000171E  16FC 002D                706                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001722  16FC 0028                707                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001726  16FC 0041                708                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000172A  1639 00002645            709                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001730  0603 0030                710                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001734  16C3                     711                      MOVE.B  D3,(A3)+                * Insert Register value
00001736  16FC 0029                712                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000173A  6000 00A0                713                      BRA     Fn_DSP_OPR2             * Display data 2
0000173E                           714  
0000173E                           715  Fn_DSP_DTA1_07      ** Handling data mode 7
0000173E  0C39 0000 0000264C       716                      CMP.B   #0,opDta1T
00001746  6700 001E                717                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000174A  0C39 0001 0000264C       718                      CMP.B   #1,opDta1T
00001752  6700 0034                719                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001756  0C39 0002 0000264C       720                      CMP.B   #2,opDta1T
0000175E  6700 004A                721                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001762                           722  
00001762  6000 0068                723                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001766                           724  
00001766                           725  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001766  49F9 00002648            726                      LEA     opDta1,A4               * input hex
0000176C  4BF9 00002653            727                      LEA     opStrDtaWrd,A5          * output string
00001772  4EB9 000019B2            728                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001778  49F9 00002653            729                      LEA     opStrDtaWrd,A4
0000177E  4EB9 000019E4            730                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001784  6000 0056                731                      BRA     Fn_DSP_OPR2             * Display data 2
00001788                           732  
00001788                           733  Fn_DSP_DTA1_WRD     ** Display data Word
00001788  49F9 00002648            734                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002653            735                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019B2            736                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002653            737                      LEA     opStrDtaWrd,A4
000017A0  4EB9 000019E4            738                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0034                739                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           740  
000017AA                           741  Fn_DSP_DTA1_LNG     ** Display data Long
000017AA  49F9 00002648            742                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002658            743                      LEA     opStrDtaLng,A5          * output string
000017B6  4EB9 000019B2            744                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002658            745                      LEA     opStrDtaLng,A4
000017C2  4EB9 000019E4            746                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0012                747                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           748  
000017CC                           749  Fn_DSP_DTA1_ERR     ** Something is messed up
000017CC  49F9 0000272C            750                      LEA     msgErr,A4
000017D2  4EB9 000019E4            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017D8  6000 0002                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017DC                           753  
000017DC                           754  Fn_DSP_OPR2         ** Display Second Operand
000017DC  49F9 00002A41            755                      LEA     opComma,A4              * Comma
000017E2  4EB9 000019E4            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017E8                           757  
000017E8                           758  Fn_DSP_DTA2         ** Data 2 (destination)
000017E8                           759                      ** **************************************************
000017E8                           760                      **
000017E8                           761  
000017E8                           762                      ** Check if destination mode set (may not have a destination)
000017E8  0C39 00FF 00002644       763                      CMP.B   #$FF,opDstMod
000017F0  6700 0170                764                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
000017F4                           765  
000017F4  0C39 0000 00002644       766                      CMP.B   #0,opDstMod
000017FC  6700 0042                767                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001800  0C39 0001 00002644       768                      CMP.B   #1,opDstMod
00001808  6700 004A                769                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000180C  0C39 0002 00002644       770                      CMP.B   #2,opDstMod
00001814  6700 0052                771                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
00001818  0C39 0003 00002644       772                      CMP.B   #3,opDstMod
00001820  6700 0062                773                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001824  0C39 0004 00002644       774                      CMP.B   #4,opDstMod
0000182C  6700 0076                775                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001830  0C39 0007 00002644       776                      CMP.B   #7,opDstMod
00001838  6700 008A                777                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000183C                           778  
0000183C  6000 0114                779                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001840                           780  
00001840                           781  Fn_DSP_DTA2_00      ** Handling mode 0
00001840  16FC 0044                782                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001844  1639 00002643            783                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000184A  0603 0030                784                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000184E  16C3                     785                      MOVE.B  D3,(A3)+                * Insert Register value
00001850  6000 0110                786                      BRA     Fn_DSP_DONE             * Done with display
00001854                           787  
00001854                           788  Fn_DSP_DTA2_01      ** Handling mode 1
00001854  16FC 0041                789                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001858  1639 00002643            790                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000185E  0603 0030                791                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001862  16C3                     792                      MOVE.B  D3,(A3)+                * Insert Register value
00001864  6000 00FC                793                      BRA     Fn_DSP_DONE             * Done with display
00001868                           794  
00001868                           795  Fn_DSP_DTA2_02      ** Handling mode 2
00001868  16FC 0028                796                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000186C  16FC 0041                797                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001870  1639 00002643            798                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001876  0603 0030                799                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000187A  16C3                     800                      MOVE.B  D3,(A3)+                * Insert Register value
0000187C  16FC 0029                801                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001880  6000 00E0                802                      BRA     Fn_DSP_DONE             * Done with display
00001884                           803  
00001884                           804  Fn_DSP_DTA2_03      ** Handling mode 3
00001884  16FC 0028                805                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001888  16FC 0041                806                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000188C  1639 00002643            807                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001892  0603 0030                808                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001896  16C3                     809                      MOVE.B  D3,(A3)+                * Insert Register value
00001898  16FC 0029                810                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000189C  16FC 002B                811                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018A0  6000 00C0                812                      BRA     Fn_DSP_DONE             * Done with display
000018A4                           813  
000018A4                           814  Fn_DSP_DTA2_04      ** Handling mode 4
000018A4  16FC 002D                815                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018A8  16FC 0028                816                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AC  16FC 0041                817                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018B0  1639 00002645            818                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018B6  0603 0030                819                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018BA  16C3                     820                      MOVE.B  D3,(A3)+                * Insert Register value
000018BC  16FC 0029                821                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018C0  6000 00A0                822                      BRA     Fn_DSP_DONE             * Done with display
000018C4                           823  
000018C4                           824  Fn_DSP_DTA2_07      ** Handling mode 8
000018C4  0C39 0000 00002652       825                      CMP.B   #0,opDta2T
000018CC  6700 001E                826                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018D0  0C39 0001 00002652       827                      CMP.B   #1,opDta2T
000018D8  6700 0034                828                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018DC  0C39 0002 00002652       829                      CMP.B   #2,opDta2T
000018E4  6700 004A                830                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
000018E8                           831  
000018E8  6000 0068                832                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
000018EC                           833  
000018EC                           834  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
000018EC  49F9 0000264E            835                      LEA     opDta2,A4               * input hex
000018F2  4BF9 00002653            836                      LEA     opStrDtaWrd,A5          * output string
000018F8  4EB9 000019B2            837                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000018FE  49F9 00002653            838                      LEA     opStrDtaWrd,A4
00001904  4EB9 000019E4            839                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000190A  6000 0056                840                      BRA     Fn_DSP_DONE             * Display data 2
0000190E                           841  
0000190E                           842  Fn_DSP_DTA2_WRD     ** Display data Word
0000190E  49F9 0000264E            843                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002653            844                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019B2            845                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002653            846                      LEA     opStrDtaWrd,A4
00001926  4EB9 000019E4            847                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0034                848                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           849  
00001930                           850  Fn_DSP_DTA2_LNG     ** Display data Long
00001930  49F9 0000264E            851                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002658            852                      LEA     opStrDtaLng,A5          * output string
0000193C  4EB9 000019B2            853                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002658            854                      LEA     opStrDtaLng,A4
00001948  4EB9 000019E4            855                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0012                856                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           857  
00001952                           858  Fn_DSP_DTA2_ERR     ** Something is messed up
00001952  49F9 0000272C            859                      LEA     msgErr,A4
00001958  4EB9 000019E4            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000195E  6000 0002                861                      BRA     Fn_DSP_DONE             * Display data 2
00001962                           862  
00001962                           863  Fn_Dsp_Done         ** Done with instruction display
00001962  16BC 0000                864                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001966  43F9 000025EE            865                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000196C  103C 000D                866                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001970  4E4F                     867                      TRAP    #15
00001972                           868  
00001972                           869                      ** We're all done here - time to go
00001972                           870                      **
00001972  4E75                     871                      RTS                             * Return back to caller
00001974                           872  
00001974                           873  ** -----------------------------------------------------------
00001974                           874  ** Convert single ASCII value to hexadecimal
00001974                           875  **    ASCII values should be in range 0-9, A-F
00001974                           876  **
00001974                           877  ** Parameters
00001974                           878  **   D5 - Hex value to assess. Converted value returned in D5
00001974                           879  **
00001974                           880  ** Example:
00001974                           881  **   $30 -> $0
00001974                           882  **   $41 -> $A
00001974                           883  **   $61 -> $A
00001974                           884  ** -----------------------------------------------------------
00001974                           885  SR_ASCII_HEX
00001974  BA3C 0039                886                      CMP.B   #$39,D5
00001978  6F00 000E                887                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000197C  BA3C 0046                888                      CMP.B   #$46,D5
00001980  6F00 000C                889                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
00001984  6000 000E                890                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
00001988                           891  
00001988  0405 0030                892  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
0000198C  4E75                     893                      RTS
0000198E  0405 0037                894  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
00001992  4E75                     895                      RTS
00001994  0405 0057                896  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
00001998  4E75                     897                      RTS
0000199A                           898  
0000199A                           899  ** -----------------------------------------------------------
0000199A                           900  ** Convert single hexadecimal value to ASCII
0000199A                           901  **    hexadecimal values should be in range 0-9, A-F
0000199A                           902  **
0000199A                           903  ** Parameters
0000199A                           904  **   D5 - Hex value to assess. Converted value returned in D5
0000199A                           905  **
0000199A                           906  ** Example:
0000199A                           907  **   $0 -> $30
0000199A                           908  **   $A -> $41
0000199A                           909  **   $a -> $41
0000199A                           910  **
0000199A                           911  ** Note: this function is case insensitive an $a = $A = $41 etc.
0000199A                           912  ** -----------------------------------------------------------
0000199A                           913  SR_HEX_ASCII
0000199A  BA3C 0009                914                      CMP.B   #$9,D5
0000199E  6F00 0006                915                      BLE     Fn_HEX_Num              * Hex $0-$9
000019A2  6000 0008                916                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019A6                           917  
000019A6  0605 0030                918  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019AA  4E75                     919                      RTS
000019AC  0605 0037                920  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019B0  4E75                     921                      RTS
000019B2                           922  
000019B2                           923  ** -----------------------------------------------------------
000019B2                           924  ** Copy hexadecimal value to string
000019B2                           925  **
000019B2                           926  ** Parameters
000019B2                           927  **   A4 - Pointer to value copying from
000019B2                           928  **   A5 - Pointer to defined constant
000019B2                           929  **
000019B2                           930  ** Data registers
000019B2                           931  **   D4 - Current byte      (hex value A4)
000019B2                           932  **   D5 - Temp byte         (hex value or string)
000019B2                           933  **   D6 - Number to shift
000019B2                           934  **
000019B2                           935  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019B2                           936  **
000019B2                           937  ** -----------------------------------------------------------
000019B2                           938  SR_HEX_STR
000019B2                           939  
000019B2  181C                     940  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019B4                           941  
000019B4  1A15                     942                      MOVE.B  (A5),D5
000019B6  BA3C 0000                943                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019BA  6700 0022                944                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019BE                           945  
000019BE                           946                      ** First Hex value (high order value)
000019BE  1A04                     947                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019C0  1C3C 0004                948                      MOVE.B  #4,D6
000019C4  EC2D                     949                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019C6  4EB8 199A                950                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019CA  1AC5                     951                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019CC                           952  
000019CC                           953                      ** Second Hex value (low order value)
000019CC  1A04                     954                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019CE  1C3C 0004                955                      MOVE.B  #4,D6
000019D2  ED2D                     956                      LSL.B   D6,D5
000019D4  EC2D                     957                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019D6  4EB8 199A                958                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019DA  1AC5                     959                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019DC                           960  
000019DC  60D4                     961                      BRA     Fn_Hex_Str_Loop
000019DE                           962  Fn_Hex_Str_Done
000019DE  1AFC 0000                963                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
000019E2                           964  
000019E2  4E75                     965                      RTS
000019E4                           966  
000019E4                           967  ** -----------------------------------------------------------
000019E4                           968  ** Copy string to output buffer @ A3
000019E4                           969  **
000019E4                           970  ** Parameters
000019E4                           971  **   A4 - Pointer to string copying from
000019E4                           972  **
000019E4                           973  ** Data registers
000019E4                           974  **   D5 - Temp byte         (hex value or string)
000019E4                           975  ** -----------------------------------------------------------
000019E4                           976  SR_CPY_STR_BUF
000019E4                           977  
000019E4  1A14                     978  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
000019E6  BA3C 0000                979                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019EA  6700 0006                980                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
000019EE                           981  
000019EE  16DC                     982                      MOVE.B  (A4)+,(A3)+
000019F0  60F2                     983                      BRA     Fn_CPY_STR_Loop
000019F2                           984  
000019F2  4E75                     985  Fn_CPY_STR_Done     RTS
000019F4                           986  
000019F4                           987  ** -----------------------------------------------------------
000019F4                           988  ** Length of string output buffer
000019F4                           989  ** -----------------------------------------------------------
000019F4                           990  SR_CNT_STR_BUF
000019F4                           991  
000019F4  4E75                     992                      RTS
000019F6                           993  
000019F6                           994  ** -----------------------------------------------------------
000019F6                           995  ** Includes: Subroutines etc.
000019F6                           996  ** -----------------------------------------------------------
000019F6                           997                      INCLUDE 'SR_IDX.X68'
000019F6                           998  
000019F6                           999  
000019F6                          1000  SR_IDX
000019F6                          1001  
000019F6  4E75                    1002                RTS
000019F6  4E75                    1003  -------------------- end include --------------------
000019F8                          1004                      INCLUDE 'SR_ID3.X68'
000019F8                          1005  
000019F8                          1006  
000019F8                          1007  SR_ID3
000019F8                          1008  
000019F8                          1009                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
000019F8                          1010  
000019F8                          1011  
000019F8                          1012                      ** ***************************************
000019F8                          1013                      ** Read first 4 bits
000019F8                          1014                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
000019F8                          1015                      ** Note: most instructions will be in this format 3,3,3,3
000019F8                          1016                      **    I think there is only one instrction that is 4,8
000019F8                          1017                      **
000019F8                          1018                      ** ***************************************
000019F8  3639 000025D8           1019                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000019FE  183C 000C               1020                      MOVE.B  #12,D4
00001A02  E86B                    1021                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A04  13C3 000025DA           1022                      MOVE.B  D3, opID
00001A0A                          1023  
00001A0A                          1024                      ** Read next 3 bits
00001A0A                          1025                      **
00001A0A  3639 000025D8           1026                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A10  183C 0004               1027                      MOVE.B  #4, D4
00001A14  E96B                    1028                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A16  183C 000D               1029                      MOVE.B  #13,D4
00001A1A  E86B                    1030                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A1C  13C3 00002643           1031                      MOVE.B  D3, opDstReg
00001A22                          1032  
00001A22                          1033                      ** Read next 3 bits
00001A22                          1034                      **
00001A22  3639 000025D8           1035                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A28  183C 0007               1036                      MOVE.B  #7, D4
00001A2C  E96B                    1037                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A2E  183C 000D               1038                      MOVE.B  #13,D4
00001A32  E86B                    1039                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A34  13C3 00002644           1040                      MOVE.B  D3, opDstMod
00001A3A                          1041  
00001A3A                          1042                      ** Read next 3 bits
00001A3A                          1043                      **
00001A3A  3639 000025D8           1044                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A40  183C 000A               1045                      MOVE.B  #10, D4
00001A44  E96B                    1046                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A46  183C 000D               1047                      MOVE.B  #13,D4
00001A4A  E86B                    1048                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A4C  13C3 00002646           1049                      MOVE.B  D3, opSrcMod
00001A52                          1050  
00001A52                          1051                      ** Read next 3 bits
00001A52                          1052                      **
00001A52  3639 000025D8           1053                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A58  183C 000D               1054                      MOVE.B  #13, D4
00001A5C  E96B                    1055                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A5E  183C 000D               1056                      MOVE.B  #13,D4
00001A62  E86B                    1057                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A64  13C3 00002645           1058                      MOVE.B  D3, opSrcReg
00001A6A                          1059  
00001A6A                          1060                      ** ***************************************
00001A6A                          1061                      ** Verify this is MOVE or MOVEA
00001A6A                          1062                      **
00001A6A                          1063                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A6A                          1064                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A6A                          1065                      **
00001A6A                          1066                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A6A                          1067                      **
00001A6A                          1068                      ** ***************************************
00001A6A  0C39 0001 00002644      1069                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A72  6700 0016               1070                      BEQ     Fn_MOVE_Ins02               * Set as instruction 0 MOVEA
00001A76  6000 0002               1071                      BRA     Fn_MOVE_Ins01               * Set as instruction 1 MOVE
00001A7A                          1072  
00001A7A  47F9 00002666           1073  Fn_MOVE_Ins01       LEA     opNam_MOVE,A3
00001A80  23CB 0000263E           1074                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001A86  6000 001A               1075                      BRA     Fn_MOVE_Verify
00001A8A                          1076  
00001A8A  0C39 0001 000025DA      1077  Fn_MOVE_Ins02       CMP.B   #1, opID
00001A92  6700 01A4               1078                      BEQ     Fn_MOVE_Error               * MOVEA cannot have opID = 1 (byte)
00001A96  47F9 0000266B           1079                      LEA     opNam_MOVEA,A3
00001A9C  23CB 0000263E           1080                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA2                          1081  
00001AA2                          1082                      ** ***************************************
00001AA2                          1083                      ** Verify other instruction parameters are correct
00001AA2                          1084                      **
00001AA2                          1085                      **    DstMod = 0 to 7
00001AA2                          1086                      **    DstReg = 0 to 7
00001AA2                          1087                      **    SrcMod = 0 to 7
00001AA2                          1088                      **    SrcReg = 0 to 7
00001AA2                          1089                      **
00001AA2                          1090                      ** ***************************************
00001AA2  0C39 0000 00002644      1091  Fn_MOVE_Verify      CMP.B   #0, opDstMod                * Destination mode is >= 0
00001AAA  6D00 018C               1092                      BLT     Fn_MOVE_Error
00001AAE  0C39 0007 00002644      1093                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AB6  6E00 0180               1094                      BGT     Fn_MOVE_Error
00001ABA  0C39 0000 00002643      1095                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AC2  6D00 0174               1096                      BLT     Fn_MOVE_Error
00001AC6  0C39 0007 00002643      1097                      CMP.B   #7, opDstReg                * Destination register <= 7
00001ACE  6E00 0168               1098                      BGT     Fn_MOVE_Error
00001AD2                          1099  
00001AD2  0C39 0000 00002646      1100                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001ADA  6D00 015C               1101                      BLT     Fn_MOVE_Error
00001ADE  0C39 0007 00002646      1102                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001AE6  6E00 0150               1103                      BGT     Fn_MOVE_Error
00001AEA  0C39 0000 00002645      1104                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001AF2  6D00 0144               1105                      BLT     Fn_MOVE_Error
00001AF6  0C39 0007 00002645      1106                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001AFE  6E00 0138               1107                      BGT     Fn_MOVE_Error
00001B02                          1108  
00001B02                          1109                      ** ***************************************
00001B02                          1110                      ** Set instruction size - the .B,.W,.L part
00001B02                          1111                      ** Note: size set by opID only for MOVE, MOVEA
00001B02                          1112                      **       other instructions use 3 bits for size
00001B02                          1113                      ** ***************************************
00001B02  0C39 0001 000025DA      1114                      CMP.B   #1, opID                    * Instruction size is Byte
00001B0A  6700 001A               1115                      BEQ     Fn_MOVE_SizB
00001B0E  0C39 0003 000025DA      1116                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B16  6700 001A               1117                      BEQ     Fn_MOVE_SizW
00001B1A  0C39 0002 000025DA      1118                      CMP.B   #2, opID                    * Instruction size is Long
00001B22  6700 001A               1119                      BEQ     Fn_MOVE_SizL
00001B26  13FC 0000 00002642      1120  Fn_MOVE_SizB        MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B2E  6000 001A               1121                      BRA     Fn_MOVE_SrcMod
00001B32  13FC 0001 00002642      1122  Fn_MOVE_SizW        MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B3A  6000 000E               1123                      BRA     Fn_MOVE_SrcMod
00001B3E  13FC 0002 00002642      1124  Fn_MOVE_SizL        MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B46  6000 0002               1125                      BRA     Fn_MOVE_SrcMod
00001B4A                          1126  
00001B4A                          1127                      ** ***************************************
00001B4A                          1128                      ** Grab extra DATA if needed
00001B4A                          1129                      **
00001B4A                          1130                      **    If DstMod = 7
00001B4A                          1131                      **       DstReg = 0 (get Word)
00001B4A                          1132                      **       DstReg = 1 (get Long)
00001B4A                          1133                      **
00001B4A                          1134                      **    If SrcMod = 7
00001B4A                          1135                      **       SrcReg = 0 (get Word)
00001B4A                          1136                      **       SrcReg = 1 (get Long)
00001B4A                          1137                      **       SrcReg = 4
00001B4A                          1138                      **          MOVE.B, MOVE.W (get Word)
00001B4A                          1139                      **          MOVE.L         (get Long)
00001B4A                          1140                      **
00001B4A                          1141                      ** SOURCE
00001B4A                          1142                      **
00001B4A                          1143                      ** ***************************************
00001B4A  0C39 0007 00002646      1144  Fn_MOVE_SrcMod      CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B52  6700 0006               1145                      BEQ     Fn_MOVE_ChkSrcReg           * Check source register
00001B56  6000 0088               1146                      BRA     Fn_MOVE_ChkDstMod           * Source not 7, now check destination Mod
00001B5A  0C39 0000 00002645      1147  Fn_MOVE_ChkSrcReg   CMP.B   #0, opSrcReg                * Check is source register is 0
00001B62  6700 0058               1148                      BEQ     Fn_MOVE_DtaSrcWrd           * Load next word
00001B66  0C39 0001 00002645      1149                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B6E  6700 005E               1150                      BEQ     Fn_MOVE_DtaSrcLng           * Load next long
00001B72  0C39 0004 00002645      1151                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B7A  6700 0006               1152                      BEQ     Fn_MOVE_DtaSrcImd           * Load first word into word one
00001B7E  6000 00B8               1153                      BRA     FN_MOVE_Error               * Invalid register value
00001B82                          1154  
00001B82                          1155                      ** Note: Checking immediate value
00001B82                          1156                      **       opID as size is specific to MOVE, MOVEA
00001B82                          1157                      **       other instructions will use 3 bits to set size, not part of ID
00001B82                          1158                      **
00001B82  0C39 0001 000025DA      1159  Fn_MOVE_DtaSrcImd   CMP.B   #1, opID                    * opID = 0 - size is byte
00001B8A  6700 001E               1160                      BEQ     Fn_MOVE_DtaSrcByt           * Load next byte
00001B8E  0C39 0003 000025DA      1161                      CMP.B   #3, opID                    * opID = 3 - size is word
00001B96  6700 0024               1162                      BEQ     Fn_MOVE_DtaSrcWrd           * Load next word
00001B9A  0C39 0002 000025DA      1163                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BA2  6700 002A               1164                      BEQ     Fn_MOVE_DtaSrcLng           * Load next long
00001BA6  6000 0090               1165                      BRA     Fn_MOVE_Error               * Invalid opID (this should never happen)
00001BAA                          1166  
00001BAA  33DA 00002648           1167  Fn_MOVE_DtaSrcByt   MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BB0  13FC 0000 0000264C      1168                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BB8  6000 0026               1169                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BBC  33DA 00002648           1170  Fn_MOVE_DtaSrcWrd   MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BC2  13FC 0001 0000264C      1171                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BCA  6000 0014               1172                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BCE  23DA 00002648           1173  Fn_MOVE_DtaSrcLng   MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BD4  13FC 0002 0000264C      1174                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BDC  6000 0002               1175                      BRA     Fn_MOVE_ChkDstMod           * Check destination mode
00001BE0                          1176  
00001BE0                          1177                      ** DESTINATION
00001BE0                          1178                      **
00001BE0  0C39 0007 00002644      1179  Fn_MOVE_ChkDstMod   CMP.B   #7, opDstMod                * Check if destination mode is 7
00001BE8  6700 0006               1180                      BEQ     Fn_MOVE_ChkDstReg           * Check destination register
00001BEC  6000 0042               1181                      BRA     Fn_MOVE_Done                * Destination not 7, done with data
00001BF0  0C39 0000 00002643      1182  Fn_MOVE_ChkDstReg   CMP.B   #0, opDstReg                * Check if destination register is 0
00001BF8  6700 0012               1183                      BEQ     Fn_MOVE_DtaDstWrd           * Load next word
00001BFC  0C39 0001 00002643      1184                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C04  6700 0018               1185                      BEQ     Fn_MOVE_DtaDstLng           * Load next long
00001C08  6000 002E               1186                      BRA     fn_MOVE_Error               * Invalid registration Mode
00001C0C                          1187  
00001C0C  33DA 0000264E           1188  Fn_MOVE_DtaDstWrd   MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C12  13FC 0001 00002652      1189                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C1A  6000 0014               1190                      BRA     Fn_MOVE_Done
00001C1E  23DA 0000264E           1191  Fn_MOVE_DtaDstLng   MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C24  13FC 0002 00002652      1192                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C2C  6000 0002               1193                      BRA     Fn_MOVE_Done
00001C30                          1194  
00001C30  13FC 0000 000025DB      1195  Fn_MOVE_Done        MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C38                          1196  
00001C38                          1197  Fn_MOVE_Error                                           * Exit out if error - main subroutine will handle DATA
00001C38                          1198                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C38  4E75                    1199                      RTS                                 * Return to main
00001C38  4E75                    1200  -------------------- end include --------------------
00001C3A                          1201                      INCLUDE 'SR_ID4.X68'
00001C3A                          1202  
00001C3A                          1203  SR_ID4              * This is to grab the first four that are already set, ID4
00001C3A  3639 000025D8           1204                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C40  183C 000C               1205                      MOVE.B  #12,D4
00001C44  E86B                    1206                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C46  13C3 000025DA           1207                      MOVE.B  D3, opID        
00001C4C                          1208                      
00001C4C                          1209                      * Read next 3 bits into D3
00001C4C  3639 000025D8           1210                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C52  183C 0004               1211                      MOVE.B  #4, D4
00001C56  E96B                    1212                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C58  183C 000D               1213                      MOVE.B  #13,D4
00001C5C  E86B                    1214                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C5E  13C3 00002643           1215                      MOVE.B  D3, opDstReg
00001C64                          1216                      
00001C64                          1217                      * Read next 3 bits into D3
00001C64  3639 000025D8           1218                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C6A  183C 0007               1219                      MOVE.B  #7, D4
00001C6E  E96B                    1220                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C70  183C 000D               1221                      MOVE.B  #13,D4
00001C74  E86B                    1222                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C76  13C3 00002644           1223                      MOVE.B  D3, opDstMod
00001C7C                          1224  
00001C7C                          1225                      ** Read next 3 bits
00001C7C                          1226                      **
00001C7C  3639 000025D8           1227                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C82  183C 000A               1228                      MOVE.B  #10, D4
00001C86  E96B                    1229                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001C88  183C 000D               1230                      MOVE.B  #13,D4
00001C8C  E86B                    1231                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C8E  13C3 00002646           1232                      MOVE.B  D3, opSrcMod
00001C94                          1233  
00001C94                          1234                      ** Read next 3 bits
00001C94                          1235                      **
00001C94  3639 000025D8           1236                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C9A  183C 000D               1237                      MOVE.B  #13, D4
00001C9E  E96B                    1238                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CA0  183C 000D               1239                      MOVE.B  #13,D4
00001CA4  E86B                    1240                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CA6  13C3 00002645           1241                      MOVE.B  D3, opSrcReg
00001CAC                          1242                      
00001CAC                          1243                      ** ***************************************
00001CAC                          1244                      ** Verify instruction
00001CAC                          1245                      **
00001CAC                          1246                      ** JSR: If DstReg=7, DstMod=2 
00001CAC                          1247                      ** LEA: If DstReg=0-7, DstMod=7
00001CAC                          1248                      ** MOVEM:
00001CAC                          1249                      **    RegToMem: DestReg=4, DestMod=2,3
00001CAC                          1250                      **    MemToReg: DestReg=6, DestMod=2,3
00001CAC                          1251                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CAC                          1252                      ** NOT: If DstReg=3, DstMod=0-2
00001CAC                          1253                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CAC                          1254                      **
00001CAC                          1255                      ** ***************************************
00001CAC  0C39 0000 00002644      1256                      CMP.B   #0, opDstMod
00001CB4  6700 02EA               1257                      BEQ     Fn_ID4_NOT
00001CB8  0C39 0001 00002644      1258                      CMP.B   #1, opDstMod
00001CC0  6700 002A               1259                      BEQ     Fn_ID4_CheckD1
00001CC4  0C39 0002 00002644      1260                      CMP.B   #2, opDstMod
00001CCC  6700 0042               1261                      BEQ     Fn_ID4_CheckD2
00001CD0  0C39 0003 00002644      1262                      CMP.B   #3, opDstMod
00001CD8  6700 0066               1263                      BEQ     Fn_ID4_CheckD3
00001CDC  0C39 0007 00002644      1264                      CMP.B   #7, opDstMod
00001CE4  6700 011E               1265                      BEQ     Fn_ID4_LEA
00001CE8  6000 03D2               1266                      BRA     Fn_ID4_Error
00001CEC                          1267                      
00001CEC                          1268  Fn_ID4_CheckD1
00001CEC  0C39 0003 00002643      1269                      CMP.B   #3, opDstReg
00001CF4  6700 02AA               1270                      BEQ     Fn_ID4_NOT
00001CF8  0C39 0001 00002645      1271                      CMP.B   #1, opSrcReg
00001D00  6700 025E               1272                      BEQ     Fn_ID4_NOP
00001D04  0C39 0005 00002645      1273                      CMP.B   #5, opSrcReg
00001D0C  6700 02E8               1274                      BEQ     Fn_ID4_RTS
00001D10                          1275                      
00001D10                          1276  Fn_ID4_CheckD2
00001D10  0C39 0003 00002643      1277                      CMP.B   #3, opDstReg
00001D18  6700 0286               1278                      BEQ     Fn_ID4_NOT
00001D1C  0C39 0004 00002643      1279                      CMP.B   #4, opDstReg
00001D24  6700 014E               1280                      BEQ     Fn_ID4_MOVEMRTOM
00001D28  0C39 0006 00002643      1281                      CMP.B   #6, opDstReg
00001D30  6700 01B2               1282                      BEQ     Fn_ID4_MOVEMMTOR
00001D34  0C39 0007 00002643      1283                      CMP.B   #7, opDstReg
00001D3C  6700 001A               1284                      BEQ     Fn_ID4_JSR
00001D40                          1285  Fn_ID4_CheckD3
00001D40  0C39 0004 00002643      1286                      CMP.B   #4, opDstReg
00001D48  6700 012A               1287                      BEQ     Fn_ID4_MOVEMRTOM
00001D4C  0C39 0006 00002643      1288                      CMP.B   #6, opDstReg
00001D54  6700 018E               1289                      BEQ     Fn_ID4_MOVEMMTOR
00001D58                          1290  
00001D58  47F9 00002687           1291  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D5E  23CB 0000263E           1292                      MOVE.L  A3, opPtrNam
00001D64                          1293                      
00001D64  0C39 0007 00002643      1294  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D6C  6600 034E               1295                      BNE     Fn_ID4_Error
00001D70  0C39 0002 00002644      1296                      CMP.B   #2, opDstMod
00001D78  6600 0342               1297                      BNE     Fn_ID4_Error
00001D7C                          1298                      
00001D7C                          1299                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D7C  0C39 0000 00002643      1300                      CMP.B   #0, opDstReg
00001D84  6700 0336               1301                      BEQ     Fn_ID4_Error
00001D88  0C39 0001 00002643      1302                      CMP.B   #1, opDstReg
00001D90  6700 032A               1303                      BEQ     Fn_ID4_Error
00001D94  0C39 0003 00002643      1304                      CMP.B   #3, opDstReg
00001D9C  6700 031E               1305                      BEQ     Fn_ID4_Error
00001DA0  0C39 0004 00002643      1306                      CMP.B   #4, opDstReg
00001DA8  6700 0312               1307                      BEQ     Fn_ID4_Error
00001DAC                          1308                      
00001DAC                          1309                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DAC  0C39 0000 00002646      1310                      CMP.B   #0, opSrcMod
00001DB4  6700 0306               1311                      BEQ     Fn_ID4_Error
00001DB8  0C39 0001 00002646      1312                      CMP.B   #1, opSrcMod
00001DC0  6700 02FA               1313                      BEQ     Fn_ID4_Error
00001DC4  0C39 0003 00002646      1314                      CMP.B   #3, opSrcMod
00001DCC  6700 02EE               1315                      BEQ     Fn_ID4_Error
00001DD0  0C39 0004 00002646      1316                      CMP.B   #4, opSrcMod
00001DD8  6700 02E2               1317                      BEQ     Fn_ID4_Error
00001DDC                          1318                      
00001DDC                          1319                      * Make sure src reg is between 0-7
00001DDC  0C39 0000 00002645      1320                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001DE4  6D00 02D6               1321                      BLT     Fn_ID4_Error
00001DE8  0C39 0007 00002645      1322                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001DF0  6E00 02CA               1323                      BGT     Fn_ID4_Error
00001DF4                          1324                      
00001DF4  0C39 0007 00002646      1325  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001DFC  6700 0238               1326                      BEQ     Fn_ID4_Data
00001E00  6000 02BC               1327                      BRA     Fn_ID4_Done
00001E04                          1328  
00001E04  47F9 00002671           1329  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E0A  23CB 0000263E           1330                      MOVE.L  A3, opPtrNam
00001E10                          1331                      
00001E10  0C39 0007 00002644      1332  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E18  6600 02A2               1333                      BNE     Fn_ID4_Error
00001E1C                          1334                      
00001E1C                          1335                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E1C  0C39 0000 00002646      1336                      CMP.B   #0, opSrcMod
00001E24  6700 0296               1337                      BEQ     Fn_ID4_Error
00001E28  0C39 0001 00002646      1338                      CMP.B   #1, opSrcMod
00001E30  6700 028A               1339                      BEQ     Fn_ID4_Error
00001E34  0C39 0003 00002646      1340                      CMP.B   #3, opSrcMod
00001E3C  6700 027E               1341                      BEQ     Fn_ID4_Error
00001E40  0C39 0004 00002646      1342                      CMP.B   #4, opSrcMod
00001E48  6700 0272               1343                      BEQ     Fn_ID4_Error
00001E4C                          1344                      
00001E4C                          1345                      * Make sure src reg is between 0-7
00001E4C  0C39 0000 00002645      1346                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E54  6D00 0266               1347                      BLT     Fn_ID4_Error
00001E58  0C39 0007 00002645      1348                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E60  6E00 025A               1349                      BGT     Fn_ID4_Error
00001E64                          1350                      
00001E64  0C39 0007 00002646      1351  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E6C  6700 01C8               1352                      BEQ     Fn_ID4_Data
00001E70  6000 024C               1353                      BRA     Fn_ID4_Done
00001E74                          1354  
00001E74  47F9 00002679           1355  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E7A  23CB 0000263E           1356                      MOVE.L  A3, opPtrNam
00001E80                          1357                      
00001E80  0C39 0004 00002643      1358  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001E88  6600 0232               1359                      BNE     Fn_ID4_Error
00001E8C                          1360                      
00001E8C                          1361                      * Make sure dest mode is only 2 or 3
00001E8C  0C39 0003 00002645      1362                      CMP.B   #3, opSrcReg                * Destination register > 2
00001E94  6D00 0226               1363                      BLT     Fn_ID4_Error
00001E98  0C39 0003 00002645      1364                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EA0  6E00 021A               1365                      BGT     Fn_ID4_Error
00001EA4                          1366                      
00001EA4                          1367                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EA4  0C39 0000 00002646      1368                      CMP.B   #0, opSrcMod
00001EAC  6700 020E               1369                      BEQ     Fn_ID4_Error
00001EB0  0C39 0001 00002646      1370                      CMP.B   #1, opSrcMod
00001EB8  6700 0202               1371                      BEQ     Fn_ID4_Error
00001EBC  0C39 0003 00002646      1372                      CMP.B   #3, opSrcMod
00001EC4  6700 01F6               1373                      BEQ     Fn_ID4_Error
00001EC8                          1374                      
00001EC8                          1375                      * Make sure src reg is between 0-7
00001EC8  0C39 0000 00002645      1376                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001ED0  6D00 01EA               1377                      BLT     Fn_ID4_Error
00001ED4  0C39 0007 00002645      1378                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EDC  6E00 01DE               1379                      BGT     Fn_ID4_Error
00001EE0  6000 006E               1380                      BRA Fn_ID4_MOVEM_Src
00001EE4                          1381  
00001EE4  47F9 00002679           1382  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001EEA  23CB 0000263E           1383                      MOVE.L  A3, opPtrNam
00001EF0                          1384                      
00001EF0  0C39 0006 00002643      1385  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001EF8  6600 01C2               1386                      BNE     Fn_ID4_Error
00001EFC                          1387                      
00001EFC                          1388                      * Make sure dest mode is only 2 or 3
00001EFC  0C39 0003 00002645      1389                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F04  6D00 01B6               1390                      BLT     Fn_ID4_Error
00001F08  0C39 0003 00002645      1391                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F10  6E00 01AA               1392                      BGT     Fn_ID4_Error
00001F14                          1393                      
00001F14                          1394                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F14  0C39 0000 00002646      1395                      CMP.B   #0, opSrcMod
00001F1C  6700 019E               1396                      BEQ     Fn_ID4_Error
00001F20  0C39 0001 00002646      1397                      CMP.B   #1, opSrcMod
00001F28  6700 0192               1398                      BEQ     Fn_ID4_Error
00001F2C  0C39 0003 00002646      1399                      CMP.B   #3, opSrcMod
00001F34  6700 0186               1400                      BEQ     Fn_ID4_Error
00001F38                          1401                      
00001F38                          1402                      * Make sure src reg is between 0-7
00001F38  0C39 0000 00002645      1403                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F40  6D00 017A               1404                      BLT     Fn_ID4_Error
00001F44  0C39 0007 00002645      1405                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F4C  6E00 016E               1406                      BGT     Fn_ID4_Error
00001F50                          1407                      
00001F50  0C39 0007 00002646      1408  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F58  6700 00DC               1409                      BEQ     Fn_ID4_Data
00001F5C  6000 0160               1410                      BRA     Fn_ID4_Done
00001F60                          1411  
00001F60  47F9 0000267F           1412  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F66  23CB 0000263E           1413                      MOVE.L  A3, opPtrNam
00001F6C                          1414  
00001F6C  0C39 0007 00002643      1415  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F74  6600 0146               1416                      BNE     Fn_ID4_Error
00001F78  0C39 0001 00002644      1417                      CMP.B   #1, opDstMod
00001F80  6600 013A               1418                      BNE     Fn_ID4_Error
00001F84  0C39 0006 00002646      1419                      CMP.B   #6, opSrcMod
00001F8C  6600 012E               1420                      BNE     Fn_ID4_Error
00001F90  0C39 0001 00002645      1421                      CMP.B   #1, opSrcReg
00001F98  6600 0122               1422                      BNE     Fn_ID4_Error
00001F9C  6000 0120               1423                      BRA     Fn_ID4_Done
00001FA0                          1424  
00001FA0                          1425  
00001FA0  47F9 00002675           1426  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FA6  23CB 0000263E           1427                      MOVE.L  A3, opPtrNam
00001FAC                          1428                      
00001FAC  0C39 0003 00002643      1429  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FB4  6600 0106               1430                      BNE     Fn_ID4_Error
00001FB8                          1431                      
00001FB8                          1432                      * Make sure src mode is not 1
00001FB8  0C39 0001 00002646      1433                      CMP.B   #1, opSrcMod
00001FC0  6700 00FA               1434                      BEQ     Fn_ID4_Error
00001FC4                          1435                      
00001FC4                          1436                      * Make sure src reg is between 0-7
00001FC4  0C39 0000 00002645      1437                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FCC  6D00 00EE               1438                      BLT     Fn_ID4_Error
00001FD0  0C39 0007 00002645      1439                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FD8  6E00 00E2               1440                      BGT     Fn_ID4_Error
00001FDC                          1441                      
00001FDC  33F9 00002644 000025DA  1442  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00001FE6  0C39 0007 00002646      1443                      CMP.B   #7, opSrcMod
00001FEE  6700 0046               1444                      BEQ     Fn_ID4_Data
00001FF2  6000 00CA               1445                      BRA     Fn_ID4_Done
00001FF6                          1446  
00001FF6  47F9 00002683           1447  Fn_ID4_RTS          LEA    opNam_RTS,A3
00001FFC  23CB 0000263E           1448                      MOVE.L A3, opPtrNam
00002002                          1449                      
00002002  0C39 0007 00002643      1450  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000200A  6600 00B0               1451                      BNE     Fn_ID4_Error
0000200E  0C39 0001 00002644      1452                      CMP.B   #1, opDstMod
00002016  6600 00A4               1453                      BNE     Fn_ID4_Error
0000201A  0C39 0006 00002646      1454                      CMP.B   #6, opSrcMod
00002022  6600 0098               1455                      BNE     Fn_ID4_Error
00002026  0C39 0005 00002645      1456                      CMP.B   #5, opSrcReg
0000202E  6600 008C               1457                      BNE     Fn_ID4_Error
00002032  6000 008A               1458                      BRA     Fn_ID4_Done
00002036                          1459  
00002036  0C39 0000 00002645      1460  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
0000203E  6700 0058               1461                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002042  0C39 0001 00002645      1462                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000204A  6700 005E               1463                      BEQ     Fn_ID4_DtaLng               * Load next long
0000204E  0C39 0004 00002645      1464                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002056  6700 0006               1465                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000205A  6000 0060               1466                      BRA     FN_ID4_Error                * Invalid register value
0000205E                          1467                      
0000205E  0C39 0001 000025DA      1468  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002066  6700 001E               1469                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000206A  0C39 0003 000025DA      1470                      CMP.B   #3, opID                    * opID = 3 - size is word
00002072  6700 0024               1471                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002076  0C39 0002 000025DA      1472                      CMP.B   #2, opID                    * opID = 0 - size is long
0000207E  6700 002A               1473                      BEQ     Fn_ID4_DtaLng               * Load next
00002082  6000 0038               1474                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
00002086                          1475  
00002086  33DA 0000264E           1476  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000208C  13FC 0000 00002652      1477                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002094  6000 0028               1478                      BRA     Fn_ID4_Done
00002098  33DA 0000264E           1479  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
0000209E  13FC 0001 00002652      1480                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020A6  6000 0016               1481                      BRA     Fn_ID4_Done
000020AA  23DA 0000264E           1482  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020B0  13FC 0002 00002652      1483                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020B8  6000 0004               1484                      BRA     Fn_ID4_Done
000020BC                          1485  
000020BC                          1486  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
000020BC                          1487                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000020BC  4E75                    1488                      RTS                                  * Return to main
000020BE                          1489  
000020BE  4E75                    1490  Fn_ID4_Done         RTS
000020C0                          1491  
000020C0                          1492  
000020C0                          1493  
000020C0                          1494  -------------------- end include --------------------
000020C0                          1495                      INCLUDE 'SR_ID5.X68'
000020C0                          1496  
000020C0                          1497  
000020C0                          1498  SR_ID5              * This is to grab the first four that are already set, ID5
000020C0  3639 000025D8           1499                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020C6  183C 000C               1500                      MOVE.B  #12,D4
000020CA  E86B                    1501                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000020CC  13C3 000025DA           1502                      MOVE.B  D3, opID        
000020D2                          1503                      
000020D2                          1504                      * Read next 3 bits into D3
000020D2  3639 000025D8           1505                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020D8  183C 0004               1506                      MOVE.B  #4, D4
000020DC  E96B                    1507                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000020DE  183C 000D               1508                      MOVE.B  #13,D4
000020E2  E86B                    1509                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000020E4  13C3 00002646           1510                      MOVE.B  D3, opSrcMod
000020EA                          1511                      
000020EA                          1512                      * Read next 3 bits into D3
000020EA  3639 000025D8           1513                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020F0  183C 0007               1514                      MOVE.B  #7, D4
000020F4  E96B                    1515                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000020F6  183C 000D               1516                      MOVE.B  #13,D4
000020FA  E86B                    1517                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000020FC  13C3 000025DA           1518                      MOVE.B  D3, opID
00002102                          1519  
00002102                          1520                      ** Read next 3 bits
00002102                          1521                      **
00002102  3639 000025D8           1522                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002108  183C 000A               1523                      MOVE.B  #10, D4
0000210C  E96B                    1524                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000210E  183C 000D               1525                      MOVE.B  #13,D4
00002112  E86B                    1526                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002114  13C3 00002644           1527                      MOVE.B  D3, opDstMod
0000211A                          1528  
0000211A                          1529                      ** Read next 3 bits
0000211A                          1530                      **
0000211A  3639 000025D8           1531                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002120  183C 000D               1532                      MOVE.B  #13, D4
00002124  E96B                    1533                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002126  183C 000D               1534                      MOVE.B  #13,D4
0000212A  E86B                    1535                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000212C  13C3 00002643           1536                      MOVE.B  D3, opDstReg
00002132                          1537              
00002132                          1538              ** Set name
00002132  47F9 0000268B           1539              LEA     opNam_ADDQ,A3
00002138                          1540              
00002138                          1541  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
00002138  0C39 0000 00002646      1542                      CMP.B   #0, opSrcMod                * Destination register >= 0
00002140  6D00 00E4               1543                      BLT     Fn_ID5_Error
00002144  0C39 0007 00002643      1544                      CMP.B   #7, opDstReg                * Destination register <= 7
0000214C  6E00 00D8               1545                      BGT     Fn_ID5_Error
00002150                          1546              
00002150                          1547              * Make sure opId  is between 0-2
00002150  0C39 0000 000025DA      1548                      CMP.B   #0, opID                    * Destination register >= 0
00002158  6D00 00CC               1549                      BLT     Fn_ID5_Error
0000215C  0C39 0002 000025DA      1550                      CMP.B   #2, opID                    * Destination register <= 2
00002164  6E00 00C0               1551                      BGT     Fn_ID5_Error
00002168                          1552              
00002168                          1553              * Move data to  appropriate places for printing
00002168  13FC 0007 00002646      1554              MOVE.B  #7,opSrcMod
00002170  13FC 0004 00002645      1555              MOVE.B  #4,opSrcReg
00002178                          1556  
00002178                          1557                      ** Note: Checking immediate value
00002178                          1558                      **       opID as size is specific to MOVE, MOVEA
00002178                          1559                      **       other instructions will use 3 bits to set size, not part of ID
00002178                          1560                      **
00002178  0C39 0001 000025DA      1561  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002180  6700 001E               1562                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
00002184  0C39 0003 000025DA      1563                      CMP.B   #3, opID                    * opID = 3 - size is word
0000218C  6700 0024               1564                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
00002190  0C39 0002 000025DA      1565                      CMP.B   #2, opID                    * opID = 0 - size is long
00002198  6700 002A               1566                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
0000219C  6000 0088               1567                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
000021A0                          1568  
000021A0  33DA 00002648           1569  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000021A6  13FC 0000 0000264C      1570                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000021AE  6000 0026               1571                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021B2  33DA 00002648           1572  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000021B8  13FC 0001 0000264C      1573                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000021C0  6000 0014               1574                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021C4  23DA 00002648           1575  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000021CA  13FC 0002 0000264C      1576                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
000021D2  6000 0002               1577                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021D6                          1578              
000021D6  0C39 0007 00002644      1579  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
000021DE  6700 0006               1580                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
000021E2  6000 0044               1581                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
000021E6  0C39 0000 00002643      1582  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
000021EE  6700 0012               1583                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
000021F2  0C39 0001 00002643      1584                      CMP.B   #1, opDstReg                * Check if destination register is 1
000021FA  6700 0018               1585                      BEQ     Fn_ID5_DtaDstLng            * Load next long
000021FE  6000 0026               1586                      BRA     Fn_ID5_Error                * Invalid registration Mode
00002202                          1587  
00002202  33DA 0000264E           1588  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002208  13FC 0001 00002652      1589                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00002210  6000 0016               1590                      BRA     Fn_ID5_Done
00002214  23DA 0000264E           1591  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
0000221A  13FC 0002 00002652      1592                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00002222  6000 0004               1593                      BRA     Fn_ID5_Done
00002226                          1594  
00002226                          1595  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
00002226                          1596                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002226  4E75                    1597                      RTS   
00002228                          1598              
00002228  4E75                    1599  Fn_ID5_Done        RTS
00002228  4E75                    1600  -------------------- end include --------------------
0000222A                          1601                      INCLUDE 'SR_ID6.X68'
0000222A                          1602  
0000222A                          1603  
0000222A                          1604  SR_ID6              * This is to grab the first four that are already set, ID6
0000222A  3639 000025D8           1605                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002230  183C 000C               1606                      MOVE.B  #12,D4
00002234  E86B                    1607                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002236  13C3 000025DA           1608                      MOVE.B  D3, opID        
0000223C                          1609                      
0000223C                          1610                      * Read next 4 bits into D3
0000223C  3639 000025D8           1611                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002242  183C 0004               1612                      MOVE.B  #4, D4
00002246  E96B                    1613                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002248  183C 000C               1614                      MOVE.B  #12,D4
0000224C  E86B                    1615                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
0000224E  13C3 000025DA           1616                      MOVE.B  D3, opID
00002254                          1617                      
00002254                          1618                      * Read next 8 bits into D3
00002254  3639 000025D8           1619                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000225A  183C 0007               1620                      MOVE.B  #7, D4
0000225E  E96B                    1621                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
00002260  183C 0008               1622                      MOVE.B  #8,D4
00002264  E86B                    1623                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002266  13C3 00002644           1624                      MOVE.B  D3, opDstMod
0000226C                          1625              
0000226C                          1626              ** Condition is stored in opID - displacement is in DstMod
0000226C                          1627              ** All thats leftis to branch per condition and output name, check reg if needed more
0000226C                          1628              ** BRA - opID=0
0000226C                          1629              ** BEQ - opID=7
0000226C                          1630              ** BGT - opID=14
0000226C                          1631              ** BLE - opID=15
0000226C  0C39 0000 000025DA      1632              CMP.B   #0,opID
00002274  6700 002A               1633              BEQ     Fn_ID6_BRA
00002278  0C39 0007 000025DA      1634              CMP.B   #7,opID
00002280  6700 0028               1635              BEQ     Fn_ID6_BEQ
00002284  0C39 000E 000025DA      1636              CMP.B   #14,opID
0000228C  6700 0026               1637              BEQ     Fn_ID6_BGT
00002290  0C39 000F 000025DA      1638              CMP.B   #15,opID
00002298  6700 0024               1639              BEQ     Fn_ID6_BLE
0000229C  6000 0078               1640              BRA     Fn_ID6_ERROR
000022A0                          1641  
000022A0  47F9 00002690           1642  Fn_ID6_BRA  LEA     opNam_BRA,A3
000022A6  6000 001C               1643              BRA     Fn_ID6_Displacement
000022AA                          1644              
000022AA  47F9 00002694           1645  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
000022B0  6000 0012               1646              BRA     Fn_ID6_Displacement
000022B4                          1647              
000022B4  47F9 00002698           1648  Fn_ID6_BGT  LEA     opNam_BGT,A3
000022BA  6000 0008               1649              BRA     Fn_ID6_Displacement
000022BE                          1650              
000022BE  47F9 0000269C           1651  Fn_ID6_BLE  LEA     opNam_BLE,A3
000022C4                          1652              
000022C4  0C39 0000 00002644      1653  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
000022CC  6700 0024               1654              BEQ     Fn_ID6_Dsplcmnt16
000022D0  0C39 00FF 00002644      1655              CMP.B   #$FF,opDstMod
000022D8  6700 002A               1656              BEQ     Fn_ID6_Dsplcmnt32
000022DC                          1657              ** 8 bit is good
000022DC  33F9 00002644 0000264E  1658              MOVE.W  opDstMod,opDta2
000022E6  13FC 0000 00002652      1659              MOVE.B  #0,opDta2T
000022EE  6000 0028               1660              BRA     Fn_ID6_Done
000022F2                          1661              
000022F2  33DA 0000264E           1662  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
000022F8  13FC 0001 00002652      1663              MOVE.B  #1,opDta2T
00002300  6000 0016               1664              BRA     Fn_ID6_Done
00002304                          1665  
00002304  23DA 0000264E           1666  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
0000230A  13FC 0002 00002652      1667              MOVE.B  #2,opDta2T
00002312  6000 0004               1668              BRA     Fn_ID6_Done 
00002316                          1669  
00002316                          1670  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
00002316                          1671                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002316  4E75                    1672                      RTS 
00002318                          1673  
00002318  4E75                    1674  Fn_ID6_Done        RTS
00002318  4E75                    1675  -------------------- end include --------------------
0000231A                          1676                      INCLUDE 'SR_ID7.X68'
0000231A                          1677  
0000231A                          1678  
0000231A                          1679  SR_ID7              * This is to grab the first four that are already set, ID7
0000231A  3639 000025D8           1680                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002320  183C 000C               1681                      MOVE.B  #12,D4
00002324  E86B                    1682                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002326  13C3 000025DA           1683                      MOVE.B  D3, opID        
0000232C                          1684                      
0000232C                          1685                      * Read next 3 bits into D3
0000232C  3639 000025D8           1686                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002332  183C 0004               1687                      MOVE.B  #4, D4
00002336  E96B                    1688                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002338  183C 000D               1689                      MOVE.B  #13,D4
0000233C  E86B                    1690                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000233E  13C3 00002648           1691                      MOVE.B  D3, opDta1      
00002344                          1692              
00002344                          1693              * Read next 1 bits into D3
00002344  3639 000025D8           1694                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000234A  183C 0007               1695                      MOVE.B  #7, D4
0000234E  E96B                    1696                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002350  183C 000F               1697                      MOVE.B  #15,D4
00002354  E86B                    1698                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002356  13C3 00002644           1699                      MOVE.B  D3, opDstMod    
0000235C  0C39 0000 00002644      1700              CMP.B   #0,opDstMod
00002364  6600 0038               1701              BNE     Fn_ID7_Error
00002368                          1702              
00002368                          1703              * Read next 8 bits into D3
00002368  3639 000025D8           1704                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000236E  183C 0008               1705                      MOVE.B  #8, D4
00002372  E96B                    1706                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002374  183C 0008               1707                      MOVE.B  #8,D4
00002378  E86B                    1708                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
0000237A  13C3 0000264E           1709                      MOVE.B  D3, opDta2
00002380                          1710  
00002380  47F9 000026A0           1711              LEA     opNam_MOVEQ,A3
00002386                          1712              * Set appropriate data
00002386  13FC 0001 00002652      1713              MOVE.B  #1, opDta2T
0000238E  13FC 0007 00002646      1714              MOVE.B  #7, opSrcMod
00002396  13FC 0000 00002645      1715              MOVE.B  #0, opSrcReg
0000239E                          1716  
0000239E                          1717  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
0000239E                          1718                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000239E  4E75                    1719                      RTS                                  * Return to main
000023A0                          1720              
000023A0  4E75                    1721  Fn_ID7_Done        RTS
000023A0  4E75                    1722  -------------------- end include --------------------
000023A2                          1723                      INCLUDE 'SR_ID8.X68'
000023A2                          1724  
000023A2                          1725  
000023A2                          1726  SR_ID8              * This is to grab the first four that are already set, ID4
000023A2  3639 000025D8           1727                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023A8  183C 000C               1728                      MOVE.B  #12,D4
000023AC  E86B                    1729                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000023AE  13C3 000025DA           1730                      MOVE.B  D3, opID        
000023B4                          1731                      
000023B4                          1732                      * Read next 3 bits into D3
000023B4  3639 000025D8           1733                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023BA  183C 0004               1734                      MOVE.B  #4, D4
000023BE  E96B                    1735                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000023C0  183C 000D               1736                      MOVE.B  #13,D4
000023C4  E86B                    1737                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023C6  13C3 00002643           1738                      MOVE.B  D3, opDstReg
000023CC                          1739                      
000023CC                          1740                      * Read next 3 bits into D3
000023CC  3639 000025D8           1741                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023D2  183C 0007               1742                      MOVE.B  #7, D4
000023D6  E96B                    1743                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000023D8  183C 000D               1744                      MOVE.B  #13,D4
000023DC  E86B                    1745                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023DE  13C3 00002644           1746                      MOVE.B  D3, opDstMod
000023E4                          1747  
000023E4                          1748                      ** Read next 3 bits
000023E4                          1749                      **
000023E4  3639 000025D8           1750                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023EA  183C 000A               1751                      MOVE.B  #10, D4
000023EE  E96B                    1752                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000023F0  183C 000D               1753                      MOVE.B  #13,D4
000023F4  E86B                    1754                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023F6  13C3 00002646           1755                      MOVE.B  D3, opSrcMod
000023FC                          1756  
000023FC                          1757                      ** Read next 3 bits
000023FC                          1758                      **
000023FC  3639 000025D8           1759                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002402  183C 000D               1760                      MOVE.B  #13, D4
00002406  E96B                    1761                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002408  183C 000D               1762                      MOVE.B  #13,D4
0000240C  E86B                    1763                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000240E  13C3 00002645           1764                      MOVE.B  D3, opSrcReg
00002414                          1765              
00002414                          1766              ** Find out if its Dn, ea or ea, Dn
00002414                          1767              ** ea, Dn - 0,1,2
00002414                          1768              ** Dn, ea - 4,5,6
00002414  0C39 0003 00002644      1769              CMP.B   #3,opDstMod
0000241C  6D00 0012               1770              BLT     Fn_ID8_Case1
00002420  0C39 0007 00002644      1771              CMP.B   #7,opDstMod
00002428  6D00 0048               1772              BLT     Fn_ID8_Case2
0000242C  6000 0178               1773              BRA     Fn_ID8_Error
00002430                          1774  
00002430  13F9 00002644 000025DA  1775  Fn_ID8_Case1MOVE.B  opDstMod,opID
0000243A  13F9 00002646 00002644  1776              MOVE.B  opSrcMod,opDstMod
00002444  1C39 00002643           1777              MOVE.B  opDstReg,D6
0000244A  13F9 00002645 00002643  1778              MOVE.B  opSrcReg,opDstReg
00002454  13C6 00002645           1779              MOVE.B  D6,opSrcReg
0000245A  13FC 0000 00002646      1780              MOVE.B  #0,opSrcMod
00002462                          1781              ** Immediate data?
00002462  0C39 0007 00002644      1782              CMP.B   #7, opDstMod
0000246A  6700 002E               1783                      BEQ     Fn_ID8_DataDst
0000246E  6000 0138               1784                      BRA     Fn_ID8_Done
00002472                          1785  
00002472  13F9 00002644 000025DA  1786  Fn_ID8_Case2MOVE.B  opDstMod,opID
0000247C  5939 000025DA           1787              SUB.B   #4,opID
00002482  13FC 0000 00002644      1788              MOVE.B  #0,opDstMod
0000248A                          1789              ** Immediate data?
0000248A  0C39 0007 00002646      1790              CMP.B   #7, opSrcMod
00002492  6700 008C               1791                      BEQ     Fn_ID8_DataSrc
00002496  6000 0110               1792                      BRA     Fn_ID8_Done
0000249A                          1793              
0000249A  0C39 0000 00002643      1794  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000024A2  6700 0058               1795                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024A6  0C39 0001 00002643      1796                      CMP.B   #1, opDstReg                * Check if source register is 1
000024AE  6700 005E               1797                      BEQ     Fn_ID8_DtaDstLng            * Load next long
000024B2  0C39 0004 00002643      1798                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000024BA  6700 0006               1799                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
000024BE  6000 00E6               1800                      BRA     FN_ID8_Error                * Invalid register value
000024C2                          1801                      
000024C2  0C39 0001 000025DA      1802  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000024CA  6700 001E               1803                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
000024CE  0C39 0003 000025DA      1804                      CMP.B   #3, opID                    * opID = 3 - size is word
000024D6  6700 0024               1805                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024DA  0C39 0002 000025DA      1806                      CMP.B   #2, opID                    * opID = 0 - size is long
000024E2  6700 002A               1807                      BEQ     Fn_ID8_DtaDstLng            * Load next
000024E6  6000 00BE               1808                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000024EA                          1809  
000024EA  33DA 00002648           1810  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000024F0  13FC 0000 0000264C      1811                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000024F8  6000 00AE               1812                      BRA     Fn_ID8_Done
000024FC  33DA 00002648           1813  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002502  13FC 0001 0000264C      1814                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000250A  6000 009C               1815                      BRA     Fn_ID8_Done
0000250E  23DA 00002648           1816  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002514  13FC 0002 0000264C      1817                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000251C  6000 008A               1818                      BRA     Fn_ID8_Done
00002520                          1819              
00002520  0C39 0000 00002645      1820  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002528  6700 0058               1821                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
0000252C  0C39 0001 00002645      1822                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002534  6700 005E               1823                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
00002538  0C39 0004 00002645      1824                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002540  6700 0006               1825                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
00002544  6000 0060               1826                      BRA     FN_ID8_Error                * Invalid register value
00002548                          1827                      
00002548  0C39 0001 000025DA      1828  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002550  6700 001E               1829                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
00002554  0C39 0003 000025DA      1830                      CMP.B   #3, opID                    * opID = 3 - size is word
0000255C  6700 0024               1831                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002560  0C39 0002 000025DA      1832                      CMP.B   #2, opID                    * opID = 0 - size is long
00002568  6700 002A               1833                      BEQ     Fn_ID8_DtaSrcLng            * Load next
0000256C  6000 0038               1834                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
00002570                          1835  
00002570  33DA 0000264E           1836  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002576  13FC 0000 00002652      1837                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
0000257E  6000 0028               1838                      BRA     Fn_ID8_Done
00002582  33DA 0000264E           1839  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002588  13FC 0001 00002652      1840                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002590  6000 0016               1841                      BRA     Fn_ID8_Done
00002594  23DA 0000264E           1842  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
0000259A  13FC 0002 00002652      1843                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000025A2  6000 0004               1844                      BRA     Fn_ID8_Done
000025A6                          1845  
000025A6                          1846  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
000025A6                          1847                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025A6  4E75                    1848                      RTS   
000025A8                          1849              
000025A8  4E75                    1850  Fn_ID8_Done        RTS
000025A8  4E75                    1851  -------------------- end include --------------------
000025AA                          1852                      INCLUDE 'SR_ID9.X68'
000025AA                          1853  
000025AA                          1854  
000025AA                          1855  SR_ID9
000025AA                          1856  
000025AA                          1857  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
000025AA                          1858                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025AA  4E75                    1859                      RTS   
000025AC                          1860  
000025AC  4E75                    1861  Fn_ID9_Done        RTS
000025AC  4E75                    1862  -------------------- end include --------------------
000025AE                          1863                      INCLUDE 'SR_IDA.X68'
000025AE                          1864  
000025AE                          1865  
000025AE                          1866  SR_IDA
000025AE                          1867  
000025AE                          1868  
000025AE  4E75                    1869  Fn_IDA_Done        RTS
000025AE  4E75                    1870  -------------------- end include --------------------
000025B0                          1871                      INCLUDE 'SR_IDB.X68'
000025B0                          1872  
000025B0                          1873  
000025B0                          1874  SR_IDB
000025B0                          1875  
000025B0                          1876  
000025B0  4E75                    1877  Fn_IDB_Done        RTS
000025B0  4E75                    1878  -------------------- end include --------------------
000025B2                          1879                      INCLUDE 'SR_IDC.X68'
000025B2                          1880  
000025B2                          1881  
000025B2                          1882  SR_IDC
000025B2                          1883  
000025B2                          1884  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
000025B2                          1885                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025B2  4E75                    1886                      RTS   
000025B4                          1887  
000025B4  4E75                    1888  Fn_IDC_Done        RTS
000025B4  4E75                    1889  -------------------- end include --------------------
000025B6                          1890                      INCLUDE 'SR_IDD.X68'
000025B6                          1891  
000025B6                          1892  
000025B6                          1893  SR_IDD
000025B6                          1894  
000025B6                          1895  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
000025B6                          1896                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025B6  4E75                    1897                      RTS   
000025B8                          1898  
000025B8  4E75                    1899  Fn_IDD_Done        RTS
000025B8  4E75                    1900  -------------------- end include --------------------
000025BA                          1901                      INCLUDE 'SR_IDE.X68'
000025BA                          1902  
000025BA                          1903  SR_IDE
000025BA                          1904  
000025BA  4E75                    1905                RTS
000025BA  4E75                    1906  -------------------- end include --------------------
000025BC                          1907  
000025BC                          1908  ** -----------------------------------------------------------
000025BC                          1909  ** Variables and constants
000025BC                          1910  ** -----------------------------------------------------------
000025BC                          1911  
000025BC  =0000001A               1912  maxLines            EQU      26                      * Max lines to display
000025BC                          1913  
000025BC= 00000000                1914  adrValStart         DC.L     $00000000               * Value of starting address - set by user
000025C0= 38 39 41 42 43 44 ...   1915  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
000025C9= FF                      1916  adrStsStart         DC.B     $FF                     * Status of starting address
000025CA                          1917                                                       *   FF not set, 00 set, 01 length error, 02 hex error
000025CA= 00000000                1918  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
000025CE= 38 39 41 42 43 44 ...   1919  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
000025D7= FF                      1920  adrStsEnd           DC.B     $FF                     * Status of ending address
000025D8                          1921                                                       *   FF not set, 00 set, 01 length error, 02 hex error
000025D8                          1922  
000025D8= 0000                    1923  opWord              DC.W     $0000                   * 16 bit instruction Word
000025DA= 00                      1924  opID                DC.B     $00                     * First 4 bit value ID
000025DB= 01                      1925  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
000025DC                          1926  
000025DC= 00000000                1927  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
000025E0= 38 39 41 42 43 44 ...   1928  opStrAdr            DC.B     '89ABCDEF',0            * String address
000025EA= 00000000                1929  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
000025EE                          1930  
000025EE= 50 6C 61 63 65 68 ...   1931  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
0000263E= 00000000                1932  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002642                          1933  
00002642= FF                      1934  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002643                          1935  
00002643= FF                      1936  opDstReg            DC.B     $FF                     * Destination Register Value
00002644= FF                      1937  opDstMod            DC.B     $FF                     * Destination Mode Value
00002645= FF                      1938  opSrcReg            DC.B     $FF                     * Source Register Value
00002646= FF                      1939  opSrcMod            DC.B     $FF                     * Source Register Mode
00002647                          1940  
00002648= 00000000                1941  opDta1              DC.L     $00000000               * Data value one (most likely source)
0000264C= FF                      1942  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
0000264E= 00000000                1943  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002652= FF                      1944  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002653= 30 30 30 30 00          1945  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002658= 30 30 30 30 30 30 ...   1946  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002661                          1947  
00002661= 44 41 54 41 00          1948  opNam_DATA          DC.B     'DATA',0
00002666= 4D 4F 56 45 00          1949  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
0000266B= 4D 4F 56 45 41 00       1950  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002671= 4C 45 41 00             1951  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002675= 4E 4F 54 00             1952  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002679= 4D 4F 56 45 4D 00       1953  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
0000267F= 4E 4F 50 00             1954  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002683= 52 54 53 00             1955  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002687= 4A 53 52 00             1956  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
0000268B= 41 44 44 51 00          1957  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002690= 42 52 41 00             1958  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002694= 42 45 51 00             1959  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002698= 42 47 54 00             1960  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
0000269C= 42 4C 45 00             1961  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
000026A0= 4D 4F 56 45 51 00       1962  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
000026A6= 4F 52 00                1963  opNam_OR            DC.B     'OR',0                  * String value for instruction
000026A9= 53 55 42 00             1964  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
000026AD= 41 4E 44 00             1965  opNam_AND           DC.B     'AND',0                 * String value for instruction
000026B1= 41 44 44 00             1966  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
000026B5= 41 44 44 41 00          1967  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
000026BA= 41 53 4C 00             1968  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
000026BE= 41 53 52 00             1969  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
000026C2= 4C 53 4C 00             1970  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
000026C6= 4C 53 52 00             1971  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
000026CA= 52 4F 4C 00             1972  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
000026CE= 52 4F 52 00             1973  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
000026D2                          1974  
000026D2= 2E 42 00                1975  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
000026D5= 2E 57 00                1976  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
000026D8= 2E 4C 00                1977  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
000026DB                          1978  
000026DB= 50 6C 61 63 65 68 ...   1979  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
0000272C= 45 72 72 6F 72 00       1980  msgErr              DC.B     'Error',0               * Debug message
00002732                          1981  
00002732= 33 20 43 6F 72 65 ...   1982  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002749= 4D 65 6D 6F 72 79 ...   1983  msgHdr02a           DC.B     'Memory range:',0
00002757= 20 74 6F 20 00          1984  msgHdr02b           DC.B     ' to ',0
0000275C                          1985  
0000275C= 20 2D 20 41 6C 6C ...   1986  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
0000278B= 20 2D 20 56 61 6C ...   1987  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
000027BD= 20 2D 20 53 74 61 ...   1988  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
000027F2= 20 20 20 40 20 58 ...   1989  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002811= 20 2D 20 41 64 64 ...   1990  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002852= 20 20 20 28 61 75 ...   1991  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002867= 50 6C 65 61 73 65 ...   1992  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00002889= 49 6E 76 61 6C 69 ...   1993  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
000028AB= 49 6E 76 61 6C 69 ...   1994  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
000028D8= 53 74 61 72 74 69 ...   1995  msgStrAdr1Scc       DC.B     'Starting address: ',0
000028EB= 50 6C 65 61 73 65 ...   1996  msgStrAdr2          DC.B     'Please enter an ending address: ',0
0000290C= 49 6E 76 61 6C 69 ...   1997  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
0000292C= 49 6E 76 61 6C 69 ...   1998  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
00002957                          1999  
00002957= 48 69 74 20 45 6E ...   2000  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
0000297A= 59 6F 75 20 68 61 ...   2001  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
000029AD= 20 20 20 20 20 20 ...   2002  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
000029DF= 54 68 61 6E 6B 20 ...   2003  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
00002A09                          2004  
00002A09= 2A 2A 2A 2A 2A 2A ...   2005  msgLine             DC.B     '**************************************************',CR,LF,0
00002A3E= 0D 0A 00                2006  msgNewLine          DC.B     CR,LF,0
00002A41= 2C 00                   2007  opComma             DC.B     ',',0
00002A43= 2E 00                   2008  opPeriod            DC.B     '.',0
00002A45= 20 00                   2009  opSpace             DC.B     ' ',0
00002A48= 0900                    2010  opTab               DC.W     $0900                  * Tab - doesn't work as expected
00002A4A= 00                      2011  opBlank             DC.B     '',0
00002A4B  =0000000D               2012  CR                  EQU      $0D                     * ASCII code for Carriage Return
00002A4B  =0000000A               2013  LF                  EQU      $0A                     * ASCII code for Line Feed
00002A4B                          2014  
00002A4B                          2015                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           25CE
ADRSTRSTART         25C0
ADRSTSEND           25D7
ADRSTSSTART         25C9
ADRVALEND           25CA
ADRVALSTART         25BC
CR                  D
FN_ASCII_LCLTR      1994
FN_ASCII_NUM        1988
FN_ASCII_UCLTR      198E
FN_CPY_STR_DONE     19F2
FN_CPY_STR_LOOP     19E4
FN_DSP_DATA         15CA
FN_DSP_DONE         1962
FN_DSP_DTA1         1662
FN_DSP_DTA1_00      16BA
FN_DSP_DTA1_01      16CE
FN_DSP_DTA1_02      16E2
FN_DSP_DTA1_03      16FE
FN_DSP_DTA1_04      171E
FN_DSP_DTA1_07      173E
FN_DSP_DTA1_BYT     1766
FN_DSP_DTA1_ERR     17CC
FN_DSP_DTA1_LNG     17AA
FN_DSP_DTA1_WRD     1788
FN_DSP_DTA2         17E8
FN_DSP_DTA2_00      1840
FN_DSP_DTA2_01      1854
FN_DSP_DTA2_02      1868
FN_DSP_DTA2_03      1884
FN_DSP_DTA2_04      18A4
FN_DSP_DTA2_07      18C4
FN_DSP_DTA2_BYT     18EC
FN_DSP_DTA2_ERR     1952
FN_DSP_DTA2_LNG     1930
FN_DSP_DTA2_WRD     190E
FN_DSP_INSTR        15E6
FN_DSP_OPR1         1656
FN_DSP_OPR2         17DC
FN_DSP_SIZB         1626
FN_DSP_SIZL         1646
FN_DSP_SIZW         1636
FN_HEX_LTR          19AC
FN_HEX_NUM          19A6
FN_HEX_STR_DONE     19DE
FN_HEX_STR_LOOP     19B2
FN_ID4_CHECKD1      1CEC
FN_ID4_CHECKD2      1D10
FN_ID4_CHECKD3      1D40
FN_ID4_DATA         2036
FN_ID4_DONE         20BE
FN_ID4_DTABYT       2086
FN_ID4_DTAIMD       205E
FN_ID4_DTALNG       20AA
FN_ID4_DTAWRD       2098
FN_ID4_ERROR        20BC
FN_ID4_JSR          1D58
FN_ID4_JSR_SRC      1DF4
FN_ID4_LEA          1E04
FN_ID4_LEA_SRC      1E64
FN_ID4_MOVEMMTOR    1EE4
FN_ID4_MOVEMRTOM    1E74
FN_ID4_MOVEM_SRC    1F50
FN_ID4_NOP          1F60
FN_ID4_NOT          1FA0
FN_ID4_NOT_SRC      1FDC
FN_ID4_RTS          1FF6
FN_ID4_VERIFY_JSR   1D64
FN_ID4_VERIFY_LEA   1E10
FN_ID4_VERIFY_MMR   1EF0
FN_ID4_VERIFY_MRM   1E80
FN_ID4_VERIFY_NOP   1F6C
FN_ID4_VERIFY_NOT   1FAC
FN_ID4_VERIFY_RTS   2002
FN_ID5_CHKDSTMOD    21D6
FN_ID5_CHKDSTREG    21E6
FN_ID5_DONE         2228
FN_ID5_DTADSTLNG    2214
FN_ID5_DTADSTWRD    2202
FN_ID5_DTASRCBYT    21A0
FN_ID5_DTASRCIMD    2178
FN_ID5_DTASRCLNG    21C4
FN_ID5_DTASRCWRD    21B2
FN_ID5_ERROR        2226
FN_ID5_VERIFY       2138
FN_ID6_BEQ          22AA
FN_ID6_BGT          22B4
FN_ID6_BLE          22BE
FN_ID6_BRA          22A0
FN_ID6_DISPLACEMENT  22C4
FN_ID6_DONE         2318
FN_ID6_DSPLCMNT16   22F2
FN_ID6_DSPLCMNT32   2304
FN_ID6_ERROR        2316
FN_ID7_DONE         23A0
FN_ID7_ERROR        239E
FN_ID8_CASE1        2430
FN_ID8_CASE2        2472
FN_ID8_DATADST      249A
FN_ID8_DATASRC      2520
FN_ID8_DONE         25A8
FN_ID8_DTADSTBYT    24EA
FN_ID8_DTADSTIMD    24C2
FN_ID8_DTADSTLNG    250E
FN_ID8_DTADSTWRD    24FC
FN_ID8_DTASRCBYT    2570
FN_ID8_DTASRCIMD    2548
FN_ID8_DTASRCLNG    2594
FN_ID8_DTASRCWRD    2582
FN_ID8_ERROR        25A6
FN_ID9_DONE         25AC
FN_ID9_ERROR        25AA
FN_IDA_DONE         25AE
FN_IDB_DONE         25B0
FN_IDC_DONE         25B4
FN_IDC_ERROR        25B2
FN_IDD_DONE         25B8
FN_IDD_ERROR        25B6
FN_MAIN_CHKAGN      1140
FN_MAIN_CHKEND      1132
FN_MAIN_CHKLIN      10FA
FN_MAIN_CHKPAG      1110
FN_MAIN_CONTINUE    1178
FN_MAIN_DONE        117C
FN_MAIN_DSP         10F4
FN_MAIN_ERRINS      10EE
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_MOVE_CHKDSTMOD   1BE0
FN_MOVE_CHKDSTREG   1BF0
FN_MOVE_CHKSRCREG   1B5A
FN_MOVE_DONE        1C30
FN_MOVE_DTADSTLNG   1C1E
FN_MOVE_DTADSTWRD   1C0C
FN_MOVE_DTASRCBYT   1BAA
FN_MOVE_DTASRCIMD   1B82
FN_MOVE_DTASRCLNG   1BCE
FN_MOVE_DTASRCWRD   1BBC
FN_MOVE_ERROR       1C38
FN_MOVE_INS01       1A7A
FN_MOVE_INS02       1A8A
FN_MOVE_SIZB        1B26
FN_MOVE_SIZL        1B3E
FN_MOVE_SIZW        1B32
FN_MOVE_SRCMOD      1B4A
FN_MOVE_VERIFY      1AA2
FN_UI_CHKHEX        13DC
FN_UI_CHKHEXASL     1430
FN_UI_CHKHEXDONE    1418
FN_UI_CHKHEXLOOP    13E2
FN_UI_CHKHEXRDR     1432
FN_UI_CHKLEN        13A8
FN_UI_CHKVAL        14BC
FN_UI_CHKVALCMP     14F0
FN_UI_CHKVALEBIG    14EA
FN_UI_CHKVALEMAX    14DC
FN_UI_CHKVALSBIG    14D6
FN_UI_CHKVALSMAX    14C8
FN_UI_CHKVALSONE    1516
FN_UI_CHKVALSWP     14FA
FN_UI_CHKVALSWRD    1500
FN_UI_DONE          1518
FN_UI_DSPSTART      1258
FN_UI_END           1350
FN_UI_ENDE1         136C
FN_UI_ENDE2         137C
FN_UI_END_IN        138C
FN_UI_HDRNEXT       127C
FN_UI_LOOP          1226
FN_UI_SETEHEX       1494
FN_UI_SETEHEXI1     14A4
FN_UI_SETEHEXI2     14B0
FN_UI_SETELEN       13B4
FN_UI_SETELENI1     13C4
FN_UI_SETELENI2     13D0
FN_UI_SETVHEX       143C
FN_UI_SETVHEXI1     144C
FN_UI_SETVHEXI2     1470
FN_UI_START         12F8
FN_UI_STARTE1       1314
FN_UI_STARTE2       1324
FN_UI_START_IN      1334
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             29DF
MSGENDMEM01         297A
MSGENDMEM02         29AD
MSGERR              272C
MSGHDR01            2732
MSGHDR02A           2749
MSGHDR02B           2757
MSGINTEMP           26DB
MSGLINE             2A09
MSGNEWLINE          2A3E
MSGPAGE             2957
MSGSTRADR1          2867
MSGSTRADR1ERR1      2889
MSGSTRADR1ERR2      28AB
MSGSTRADR1SCC       28D8
MSGSTRADR2          28EB
MSGSTRADR2ERR1      290C
MSGSTRADR2ERR2      292C
MSGSTRINTRO         275C
MSGSTRNOTE          2811
MSGSTRNOTEMORE      2852
MSGSTRRANGE         278B
MSGSTRSIZE          27BD
MSGSTRSIZEEXMPL     27F2
OPBLANK             2A4A
OPCOMMA             2A41
OPDSTMOD            2644
OPDSTREG            2643
OPDTA1              2648
OPDTA1T             264C
OPDTA2              264E
OPDTA2T             2652
OPERR               25DB
OPID                25DA
OPNAM_ADD           26B1
OPNAM_ADDA          26B5
OPNAM_ADDQ          268B
OPNAM_AND           26AD
OPNAM_ASL           26BA
OPNAM_ASR           26BE
OPNAM_BEQ           2694
OPNAM_BGT           2698
OPNAM_BLE           269C
OPNAM_BRA           2690
OPNAM_DATA          2661
OPNAM_JSR           2687
OPNAM_LEA           2671
OPNAM_LSL           26C2
OPNAM_LSR           26C6
OPNAM_MOVE          2666
OPNAM_MOVEA         266B
OPNAM_MOVEM         2679
OPNAM_MOVEQ         26A0
OPNAM_NOP           267F
OPNAM_NOT           2675
OPNAM_OR            26A6
OPNAM_ROL           26CA
OPNAM_ROR           26CE
OPNAM_RTS           2683
OPNAM_SUB           26A9
OPNXTADR            25EA
OPOUTBUF            25EE
OPPERIOD            2A43
OPPTRNAM            263E
OPSIZB              26D2
OPSIZL              26D8
OPSIZW              26D5
OPSPACE             2A45
OPSRCMOD            2646
OPSRCREG            2645
OPSTRADR            25E0
OPSTRDTALNG         2658
OPSTRDTAWRD         2653
OPTAB               2A48
OPVALADR            25DC
OPVALSIZ            2642
OPWORD              25D8
SR_ASCII_HEX        1974
SR_CNT_STR_BUF      19F4
SR_CPY_STR_BUF      19E4
SR_DSP_DISPLAY      1592
SR_DSP_HEADER       1530
SR_HEX_ASCII        199A
SR_HEX_STR          19B2
SR_ID3              19F8
SR_ID4              1C3A
SR_ID5              20C0
SR_ID6              222A
SR_ID7              231A
SR_ID8              23A2
SR_ID9              25AA
SR_IDA              25AE
SR_IDB              25B0
SR_IDC              25B2
SR_IDD              25B6
SR_IDE              25BA
SR_IDX              19F6
SR_JUMP             1196
SR_UI_INPUT         1216
