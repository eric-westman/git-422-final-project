00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/7/2021 4:43:44 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 00002D1E    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 00002D2C    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 00002D1E             51                      LEA     adrValStart,A4
00001020  4BF9 00002D22             52                      LEA     adrStrStart,A5
00001026  4EB9 000019D4             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 00002D2C             54                      LEA     adrValEnd,A4
00001032  4BF9 00002D30             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019D4             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 000011B8             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 00002D1E             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001552             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 00002D3E             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 00002D3A             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 00002D4C             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 00002D3C        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 00002D3D        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002DA4        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002DA5        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002DA6        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002DA7        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002DA8        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002DAA    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 00002DAE        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 00002DB0    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002DB4        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA  23FC 00000000 00002DC4    96                      MOVE.L  #$00000000,opMask
000010D4  13FC 0000 00002DC8        97                      MOVE.B  #$00,opRotate
000010DC  13FC 0000 00002DC9        98                      MOVE.B  #$00,opSizDir
000010E4  13FC 0000 00002DCA        99                      MOVE.B  #$00,opIR
000010EC                           100  
000010EC                           101                      ** Jump table
000010EC                           102                      **
000010EC  3A39 00002D3A            103                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010F2  1C3C 000C                104                      MOVE.B  #12,D6
000010F6  EC6D                     105                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010F8  CAFC 0008                106                      MULU    #8,D5                   * offset is multiple of 8
000010FC  4EB0 5000                107                      JSR     0(A0,D5)                * Jump indirect with index
00001100                           108  
00001100                           109                      ** Invalid instruction
00001100                           110                      **
00001100  0C39 0001 00002D3D       111                      CMP.B   #1,opErr
00001108  6700 0006                112                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
0000110C  6000 0008                113                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
00001110  2479 00002D4C            114  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
00001116                           115  
00001116                           116                      ** Display result
00001116                           117                      **
00001116  4EB9 000015B4            118  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
0000111C                           119  
0000111C                           120                      ** Max lines display stop, wait for enter
0000111C                           121                      **
0000111C  5207                     122  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
0000111E                           123  
0000111E  2C07                     124                      MOVE.L  D7,D6                   * Line counter to D6 for division
00001120  8CFC 001A                125                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001124  4846                     126                      SWAP    D6                      * Swap for remainder (modulo)
00001126  BC3C 0000                127                      CMP.B   #0,D6                   * Check remainder for zero
0000112A  6700 0006                128                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000112E  6000 0024                129                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001132                           130  
00001132                           131                      ** Logic to check ENTER key to show next page
00001132                           132                      **
00001132  43F9 000030C1            133  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001138  103C 000E                134                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000113C  4E4F                     135                      TRAP    #15                     * Display to screen
0000113E  103C 0005                136                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001142  4E4F                     137                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001144                           138  
00001144                           139                      ** Clear screen
00001144  103C 000B                140                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001148  323C FF00                141                      MOVE.W  #$FF00,D1               * Clear the screen
0000114C  4E4F                     142                      TRAP    #15
0000114E                           143  
0000114E                           144                      ** Display header
0000114E  4EB9 00001552            145                      JSR     SR_DSP_HEADER
00001154                           146  
00001154                           147                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001154                           148                      **
00001154  B5F9 00002D2C            149  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
0000115A  6C00 0006                150                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000115E  6000 003A                151                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001162                           152  
00001162                           153                      ** Logic to check for for Y or N to check another region of memory
00001162                           154                      **
00001162  43F9 000030E4            155  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001168  103C 000E                156                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000116C  4E4F                     157                      TRAP    #15                     * Display to screen
0000116E  43F9 00003117            158                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001174  103C 000E                159                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001178  4E4F                     160                      TRAP    #15                     * Display to screen
0000117A                           161  
0000117A  43F9 00002E45            162                      LEA     msgInTemp,A1            * Load placeholder for input string
00001180  103C 0002                163                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001184  4E4F                     164                      TRAP    #15                     * Read string to (A1), length in D1.W
00001186  0C11 0059                165                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
0000118A  6700 FE7A                166                      BEQ     Fn_MAIN_Start           * Restart program
0000118E  0C11 0079                167                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001192  6700 FE72                168                      BEQ     Fn_MAIN_Start           * Restart program
00001196  6000 0006                169                      BRA     Fn_Main_Done            * Exit program
0000119A                           170  
0000119A  6000 FEC0                171  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000119E                           172  
0000119E                           173  Fn_MAIN_Done        ** That's all folks
0000119E  103C 000B                174                      MOVE.B  #11,D0                  * Trap task 2 does the following:
000011A2  323C FF00                175                      MOVE.W  #$FF00,D1               * Clear the screen
000011A6  4E4F                     176                      TRAP    #15
000011A8                           177  
000011A8                           178                      ** Thank you message
000011A8  43F9 00003149            179                      LEA     msgDone,A1              * Loads MESSAGE into A1
000011AE  103C 000E                180                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000011B2  4E4F                     181                      TRAP    #15                     * Display to screen
000011B4                           182  
000011B4                           183  
000011B4  4E72 2700                184                      STOP   #$2700                   * Stop execution
000011B8                           185  
000011B8                           186  ** -----------------------------------------------------------
000011B8                           187  ** JUMP TABLE: First 4 bits of instruction
000011B8                           188  **
000011B8                           189  ** Jump instruction: pointing to label (xxx).L
000011B8                           190  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
000011B8                           191  **                          label address (Long)
000011B8                           192  **
000011B8                           193  ** RTS instruction:
000011B8                           194  **  |4    E    |7    5     |               - Offset 2 bytes
000011B8                           195  **
000011B8                           196  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
000011B8                           197  **
000011B8                           198  ** Note: should find a value since 4 bits is 0 to F
000011B8                           199  ** Note: There aren't any instructions that start with F
000011B8                           200  **
000011B8                           201  ** -----------------------------------------------------------
000011B8  4EB9 00001A18            202  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
000011BE  4E75                     203                      RTS
000011C0  4EB9 00001A1A            204                      JSR     SR_ID3
000011C6  4E75                     205                      RTS
000011C8  4EB9 00001A1A            206                      JSR     SR_ID3
000011CE  4E75                     207                      RTS
000011D0  4EB9 00001A1A            208                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011D6  4E75                     209                      RTS
000011D8  4EB9 00001C5C            210                      JSR     SR_ID4
000011DE  4E75                     211                      RTS
000011E0  4EB9 0000217A            212                      JSR     SR_ID5
000011E6  4E75                     213                      RTS
000011E8  4EB9 000022EC            214                      JSR     SR_ID6
000011EE  4E75                     215                      RTS
000011F0  4EB9 000023E4            216                      JSR     SR_ID7
000011F6  4E75                     217                      RTS
000011F8  4EB9 00002474            218                      JSR     SR_ID8
000011FE  4E75                     219                      RTS
00001200  4EB9 0000268A            220                      JSR     SR_ID9
00001206  4E75                     221                      RTS
00001208  4EB9 000028A0            222                      JSR     SR_IDA
0000120E  4E75                     223                      RTS
00001210  4EB9 000028A2            224                      JSR     SR_IDB
00001216  4E75                     225                      RTS
00001218  4EB9 000028A4            226                      JSR     SR_IDC
0000121E  4E75                     227                      RTS
00001220  4EB9 00002ABA            228                      JSR     SR_IDD
00001226  4E75                     229                      RTS
00001228  4EB9 00002D1C            230                      JSR     SR_IDE
0000122E  4E75                     231                      RTS
00001230  4EB9 00001A18            232                      JSR     SR_IDX                   * No instructions @ ID=15
00001236  4E75                     233                      RTS
00001238                           234  
00001238                           235  ** -----------------------------------------------------------
00001238                           236  ** UI: User mem input
00001238                           237  ** -----------------------------------------------------------
00001238                           238  SR_UI_INPUT
00001238  13F8 00FF 00002D2B       239                      MOVE.B  $FF,adrStsStart         * Reset starting address status
00001240  13F8 00FF 00002D39       240                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001248                           241  
00001248                           242  Fn_UI_Loop          ** Clear screen
00001248  103C 000B                243                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000124C  323C FF00                244                      MOVE.W  #$FF00,D1               * Clear the screen
00001250  4E4F                     245                      TRAP    #15
00001252                           246  
00001252                           247                      ** Header
00001252                           248                      ** ***************************************
00001252                           249  
00001252  43F9 00003173            250                      LEA     msgLine,A1              * '********************'
00001258  103C 000E                251                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000125C  4E4F                     252                      TRAP    #15                     * Display to screen
0000125E                           253  
0000125E  43F9 00002E9C            254                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001264  103C 000E                255                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001268  4E4F                     256                      TRAP    #15                     * Display to screen
0000126A                           257  
0000126A  0C39 0000 00002D2B       258                      CMP.B   #0,adrStsStart          * Starting address is set
00001272  6700 0006                259                      BEQ     Fn_UI_DspStart          * Display starting address
00001276  6000 0026                260                      BRA     Fn_UI_HdrNext           * Display the rest of the header
0000127A                           261  
0000127A  43F9 00003042            262  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
00001280  103C 000E                263                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001284  4E4F                     264                      TRAP    #15                     * Display to screen
00001286                           265  
00001286  43F9 00002D22            266                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000128C  103C 000E                267                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001290  4E4F                     268                      TRAP    #15                     * Display to screen
00001292                           269  
00001292  43F9 000031A8            270                      LEA     msgNewLine,A1           * CR,LF
00001298  103C 000E                271                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129C  4E4F                     272                      TRAP    #15                     * Display to screen
0000129E                           273  
0000129E  43F9 00003173            274  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
000012A4  103C 000E                275                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012A8  4E4F                     276                      TRAP    #15                     * Display to screen
000012AA                           277  
000012AA  43F9 00002EC6            278                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
000012B0  103C 000E                279                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B4  4E4F                     280                      TRAP    #15                     * Display to screen
000012B6                           281  
000012B6  43F9 00002EF5            282                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
000012BC  103C 000E                283                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C0  4E4F                     284                      TRAP    #15                     * Display to screen
000012C2                           285  
000012C2  43F9 00002F27            286                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012C8  103C 000E                287                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CC  4E4F                     288                      TRAP    #15                     * Display to screen
000012CE                           289  
000012CE  43F9 00002F5C            290                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012D4  103C 000E                291                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012D8  4E4F                     292                      TRAP    #15                     * Display to screen
000012DA                           293  
000012DA  43F9 00002F7B            294                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012E0  103C 000E                295                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012E4  4E4F                     296                      TRAP    #15                     * Display to screen
000012E6                           297  
000012E6  43F9 00002FBC            298                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012EC  103C 000E                299                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012F0  4E4F                     300                      TRAP    #15                     * Display to screen
000012F2                           301  
000012F2  43F9 000031A8            302                      LEA     msgNewLine,A1           * CR,LF
000012F8  103C 000E                303                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012FC  4E4F                     304                      TRAP    #15                     * Display to screen
000012FE                           305  
000012FE                           306                      ** Input check
000012FE                           307                      ** ***************************************
000012FE                           308  
000012FE  0C39 0000 00002D2B       309                      CMP.B #0,adrStsStart            * Check status of address 0 = success
00001306  6600 0012                310                      BNE   Fn_UI_Start               * Input starting address
0000130A                           311  
0000130A  0C39 0000 00002D39       312                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
00001312  6600 005E                313                      BNE   Fn_UI_End                 * Input ending address
00001316                           314  
00001316                           315                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
00001316  6000 01C6                316                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
0000131A                           317  
0000131A                           318  Fn_UI_Start         ** Input Start Address
0000131A                           319                      ** ***************************************
0000131A                           320  
0000131A                           321                      ** Check errors
0000131A  0C39 0001 00002D2B       322                      CMP.B   #1,adrStsStart
00001322  6700 0012                323                      BEQ     Fn_UI_StartE1           * Error: length
00001326  0C39 0002 00002D2B       324                      CMP.B   #2,adrStsStart
0000132E  6700 0016                325                      BEQ     Fn_UI_StartE2           * Error: hex value
00001332  6000 0022                326                      BRA     Fn_UI_Start_In          * No error: ask for input
00001336                           327  
00001336  43F9 00002FF3            328  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000133C  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001340  4E4F                     330                      TRAP    #15
00001342  6000 0012                331                      BRA     Fn_UI_Start_In          * User input
00001346                           332  
00001346  43F9 00003015            333  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000134C  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001350  4E4F                     335                      TRAP    #15
00001352  6000 0002                336                      BRA     Fn_UI_Start_In          * User input
00001356                           337  
00001356  43F9 00002FD1            338  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000135C  103C 000E                339                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001360  4E4F                     340                      TRAP    #15                     * Display to screen
00001362                           341  
00001362  43F9 00002E45            342                      LEA     msgInTemp,A1            * Load placeholder for input string
00001368  103C 0002                343                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000136C  4E4F                     344                      TRAP    #15                     * Read string to (A1), length in D1.W
0000136E                           345  
0000136E  6000 005A                346                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001372                           347  
00001372                           348  Fn_UI_End           ** Input End Address
00001372                           349                      ** ***************************************
00001372                           350  
00001372                           351                      ** Check errors
00001372  0C39 0001 00002D39       352                      CMP.B   #1,adrStsEnd
0000137A  6700 0012                353                      BEQ     Fn_UI_EndE1             * Error: length
0000137E  0C39 0002 00002D39       354                      CMP.B   #2,adrStsEnd
00001386  6700 0016                355                      BEQ     Fn_UI_EndE2             * Error: hex value
0000138A  6000 0022                356                      BRA     Fn_UI_End_In            * No error: ask for input
0000138E                           357  
0000138E  43F9 00003076            358  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001394  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001398  4E4F                     360                      TRAP    #15
0000139A  6000 0012                361                      BRA     Fn_UI_End_In            * User input
0000139E                           362  
0000139E  43F9 00003096            363  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
000013A4  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013A8  4E4F                     365                      TRAP    #15
000013AA  6000 0002                366                      BRA     Fn_UI_End_In            * User input
000013AE                           367  
000013AE  43F9 00003055            368  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
000013B4  103C 000E                369                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013B8  4E4F                     370                      TRAP    #15                     * Display to screen
000013BA                           371  
000013BA  43F9 00002E45            372                      LEA     msgInTemp,A1            * Load placeholder for input string
000013C0  103C 0002                373                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013C4  4E4F                     374                      TRAP    #15                     * Read string to (A1), length in D1.W
000013C6                           375  
000013C6  6000 0002                376                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013CA                           377  
000013CA                           378  Fn_UI_ChkLen        ** Check length
000013CA                           379                      **   length should be 8 ascii characters
000013CA                           380                      **   value stored in D1.W from input
000013CA                           381                      ** ***************************************
000013CA                           382  
000013CA  B27C 0008                383                      CMP.W   #8,D1                   * Address should be 8 chars long
000013CE  6600 0006                384                      BNE     Fn_UI_SetELen           * Invalid address length
000013D2  6000 002A                385                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013D6                           386  
000013D6                           387  Fn_UI_SetELen       ** Error: length
000013D6  0C39 0000 00002D2B       388                      CMP.B #0,adrStsStart
000013DE  6600 0006                389                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013E2  6000 000E                390                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013E6                           391  Fn_UI_SetELenI1     ** Set error on input 1
000013E6  13FC 0001 00002D2B       392                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013EE  6000 FE58                393                      BRA     Fn_UI_Loop
000013F2                           394  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013F2  13FC 0001 00002D39       395                      MOVE.B  #1,adrStsEnd
000013FA  6000 FE4C                396                      BRA     Fn_UI_Loop
000013FE                           397  
000013FE                           398  Fn_UI_ChkHex        ** Check hex values
000013FE                           399                      **   30 - 39 (0-9)
000013FE                           400                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013FE                           401                      ** ***************************************
000013FE                           402  
000013FE  163C 0000                403                      MOVE.B  #0,D3                   * Loop counter
00001402  4286                     404                      CLR.L   D6                      * Temporary address storage
00001404                           405  
00001404                           406  Fn_UI_ChkHexLoop    ** Check hex values one at a time
00001404  1819                     407                      MOVE.B  (A1)+,D4                * Unload byte and increment input
00001406                           408  
00001406  B83C 0030                409                      CMP.B   #$30,D4
0000140A  6D00 00AA                410                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140E                           411  
0000140E  B83C 0039                412                      CMP.B   #$39,D4
00001412  6F00 0026                413                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001416                           414  
00001416  B83C 0041                415                      CMP.B   #$41,D4
0000141A  6D00 009A                416                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000141E                           417  
0000141E  B83C 0046                418                      CMP.B   #$46,D4
00001422  6F00 0016                419                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001426                           420  
00001426  B83C 0061                421                      CMP.B   #$61,D4
0000142A  6D00 008A                422                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000142E                           423  
0000142E  B83C 0066                424                      CMP.B   #$66,D4
00001432  6F00 0006                425                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001436                           426  
00001436  6000 007E                427                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
0000143A                           428  
0000143A                           429  Fn_UI_ChkHexDone    ** Check if at end of loop
0000143A                           430  
0000143A  5203                     431                      ADDI.B  #1,D3                   * Increment loop counter
0000143C                           432  
0000143C                           433                      ** Insert ascii value into temp address
0000143C  1A04                     434                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000143E  4EB9 00001996            435                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001444  DC05                     436                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001446  B63C 0008                437                      CMP.B   #8,D3                   * To shift or not to shift
0000144A  6D00 0006                438                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000144E  6000 0004                439                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001452  E986                     440  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001454                           441  
00001454                           442  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001454  B63C 0008                443                      CMP.B   #8,D3                   * Loop 8 times
00001458  66AA                     444                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
0000145A  6000 0002                445                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000145E                           446  
0000145E                           447  Fn_UI_SetVHex       ** Valid: hex values
0000145E  0C39 0000 00002D2B       448                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001466  6600 0006                449                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
0000146A  6000 0026                450                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000146E                           451  
0000146E                           452  Fn_UI_SetVHexI1     ** Set valid on input 1
0000146E  13FC 0000 00002D2B       453                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001476  23C6 00002D1E            454                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000147C  49F9 00002D1E            455                      LEA     adrValStart,A4
00001482  4BF9 00002D22            456                      LEA     adrStrStart,A5
00001488  4EB9 000019D4            457                      JSR     SR_HEX_STR              * Copy address value to string for display
0000148E  6000 FDB8                458                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001492                           459  
00001492                           460  Fn_UI_SetVHexI2     ** Set valid on input 2
00001492  13FC 0000 00002D39       461                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
0000149A  23C6 00002D2C            462                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
000014A0  49F9 00002D2C            463                      LEA     adrValEnd,A4
000014A6  4BF9 00002D30            464                      LEA     adrStrEnd,A5
000014AC  4EB9 000019D4            465                      JSR     SR_HEX_STR              * Copy address value to string for display
000014B2  6000 FD94                466                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
000014B6                           467  
000014B6                           468  Fn_UI_SetEHex       ** Error: hex values
000014B6  0C39 0000 00002D2B       469                      CMP.B   #0,adrStsStart
000014BE  6600 0006                470                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014C2  6000 000E                471                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014C6                           472  
000014C6                           473  Fn_UI_SetEHexI1     ** Set error on input 1
000014C6  13FC 0002 00002D2B       474                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014CE  6000 FD78                475                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014D2                           476  
000014D2                           477  Fn_UI_SetEHexI2     ** Set error on input 2
000014D2  13FC 0002 00002D39       478                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014DA  6000 FD6C                479                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014DE                           480  
000014DE                           481  Fn_UI_ChkVal        ** Check address range, order
000014DE                           482                      **   Address automagic - will fix addresses if invalid input
000014DE                           483                      ** Note: addresses are unsigned; should not be less than zero
000014DE                           484                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014DE                           485                      ** Note: subtracting one from Start address if not even
000014DE                           486                      **       doesn't really matter if end address is even or odd
000014DE                           487                      ** ***************************************
000014DE                           488  
000014DE  2A39 00002D1E            489                      MOVE.L  adrValStart,D5
000014E4  2C39 00002D2C            490                      MOVE.L  adrValEnd,D6
000014EA                           491  
000014EA  BABC 00FFFFEC            492  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014F0  6200 0006                493                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014F4  6000 0008                494                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014F8                           495  
000014F8  2A3C 00FFFFEC            496  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014FE                           497  
000014FE  BCBC 00FFFFED            498  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
00001504  6200 0006                499                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
00001508  6000 0008                500                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
0000150C                           501  
0000150C  2C3C 00FFFFED            502  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
00001512                           503  
00001512  BA86                     504  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
00001514  6200 0006                505                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
00001518  6000 0008                506                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
0000151C                           507  
0000151C  2805                     508  Fn_UI_ChkValSwp     MOVE.L  D5,D4
0000151E  2A06                     509                      MOVE.L  D6,D5
00001520  2C04                     510                      MOVE.L  D4,D6
00001522                           511  
00001522                           512  FN_UI_ChkValSWrd    ** Check start for word boundry
00001522  1605                     513                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001524  183C 0002                514                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001528  86C4                     515                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
0000152A  4843                     516                      SWAP    D3                       * Swap for remainder (the modulo part)
0000152C  B63C 0000                517                      CMP.B   #0,D3                    * If zero, then even
00001530  6600 0006                518                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001534  6000 0004                519                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001538                           520  
00001538  5385                     521  Fn_UI_ChkValSOne    SUBI.L  #1,D5
0000153A                           522  
0000153A                           523  Fn_UI_Done          ** All done with input, time to go
0000153A                           524                      ** ***************************************
0000153A                           525  
0000153A  23C5 00002D1E            526                      MOVE.L  D5,adrValStart          * Move final address to Start
00001540  23C6 00002D2C            527                      MOVE.L  D6,adrValEnd            * Move final address to End
00001546                           528  
00001546                           529                      ** Clear screen
00001546  103C 000B                530                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000154A  323C FF00                531                      MOVE.W  #$FF00,D1               * Clear the screen
0000154E  4E4F                     532                      TRAP    #15
00001550                           533  
00001550  4E75                     534                      RTS
00001552                           535  
00001552                           536  ** -----------------------------------------------------------
00001552                           537  ** UI: Display Header
00001552                           538  ** -----------------------------------------------------------
00001552                           539  SR_DSP_HEADER
00001552                           540  
00001552                           541                      ** Header line 03
00001552  43F9 00003173            542                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001558  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155C  4E4F                     544                      TRAP    #15                     * Display to screen
0000155E                           545  
0000155E                           546                      ** Header line 01
0000155E  43F9 00002E9C            547                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001564  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001568  4E4F                     549                      TRAP    #15                     * Display to screen
0000156A                           550  
0000156A                           551                      ** Header line 02
0000156A  43F9 00002EB3            552                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
00001570  103C 000E                553                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001574  4E4F                     554                      TRAP    #15                     * Display to screen
00001576                           555  
00001576  43F9 00002D22            556                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000157C  103C 000E                557                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001580  4E4F                     558                      TRAP    #15                     * Display to screen
00001582                           559  
00001582  43F9 00002EC1            560                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001588  103C 000E                561                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158C  4E4F                     562                      TRAP    #15
0000158E                           563  
0000158E  43F9 00002D30            564                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001594  103C 000E                565                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001598  4E4F                     566                      TRAP    #15                     * Display to screen
0000159A                           567  
0000159A  43F9 000031A8            568                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
000015A0  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015A4  4E4F                     570                      TRAP    #15                     * Display to screen
000015A6                           571  
000015A6                           572                      ** Header line 03
000015A6  43F9 00003173            573                      LEA     msgLine,A1              * Loads MESSAGE into A1
000015AC  103C 000E                574                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015B0  4E4F                     575                      TRAP    #15                     * Display to screen
000015B2                           576  
000015B2  4E75                     577                      RTS
000015B4                           578  
000015B4                           579  ** -----------------------------------------------------------
000015B4                           580  ** UI: Display item
000015B4                           581  ** -----------------------------------------------------------
000015B4                           582  SR_DSP_DISPLAY
000015B4                           583                      ** Output buffer
000015B4                           584                      **   Need buffer for spacing issues
000015B4                           585                      **
000015B4  47F9 00002D50            586                      LEA     opOutBuf,A3             * Reset pointer to output buffer
000015BA  16BC 0000                587                      MOVE.B  #$00,(A3)               * Insert NULL
000015BE                           588  
000015BE                           589                      ** Push opValAdr to opStrAdr
000015BE  49F9 00002D3E            590                      LEA     opValAdr,A4             * input hex
000015C4  4BF9 00002D42            591                      LEA     opStrAdr,A5             * output string
000015CA  4EB9 000019D4            592                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015D0  49F9 00002D42            593                      LEA     opStrAdr,A4
000015D6  4EB9 00001A06            594                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015DC                           595  
000015DC                           596                      ** Instruction or DATA redirector
000015DC                           597                      **
000015DC  0C39 0001 00002D3D       598                      CMP.B   #1, opErr               * Check instruction type
000015E4  6700 0006                599                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015E8  6000 001E                600                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015EC                           601  
000015EC                           602  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015EC                           603                      **
000015EC                           604  
000015EC                           605                      ** Space
000015EC  49F9 000031AF            606                      LEA     opSpace,A4
000015F2  4EB9 00001A06            607                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F8                           608  
000015F8                           609                      ** Instruction name
000015F8  49F9 00002DCB            610                      LEA     opNam_DATA,A4
000015FE  4EB9 00001A06            611                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001604                           612  
00001604  6000 037E                613                      BRA     Fn_Dsp_Done
00001608                           614  
00001608                           615  Fn_Dsp_Instr        ** Process instruction
00001608                           616                      **
00001608                           617  
00001608                           618                      ** Space
00001608  49F9 000031AF            619                      LEA     opSpace,A4
0000160E  4EB9 00001A06            620                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001614                           621  
00001614                           622                      ** Instruction name
00001614  2879 00002DA0            623                      MOVE.L  opPtrNam,A4
0000161A  4EB9 00001A06            624                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001620                           625  
00001620                           626                      ** Instruciton size
00001620                           627                      **
00001620  0C39 0000 00002DA4       628                      CMP.B   #0,opValSiz
00001628  6700 001E                629                      BEQ     Fn_DSP_SizB             * Size is Byte
0000162C  0C39 0001 00002DA4       630                      CMP.B   #1,opValSiz
00001634  6700 0022                631                      BEQ     Fn_DSP_SizW             * Size is Word
00001638  0C39 0002 00002DA4       632                      CMP.B   #2,opValSiz
00001640  6700 0026                633                      BEQ     Fn_DSP_SizL             * Size is Long
00001644  6000 003E                634                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001648                           635  
00001648  49F9 00002E3C            636  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000164E  4EB9 00001A06            637                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001654  6000 0022                638                      BRA     Fn_DSP_OPR1
00001658                           639  
00001658  49F9 00002E3F            640  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000165E  4EB9 00001A06            641                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001664  6000 0012                642                      BRA     Fn_DSP_OPR1
00001668                           643  
00001668  49F9 00002E42            644  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000166E  4EB9 00001A06            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001674  6000 0002                646                      BRA     Fn_DSP_OPR1
00001678                           647  
00001678                           648  Fn_DSP_OPR1         ** Display First Operand
00001678  49F9 000031B2            649                      LEA     opTab,A4                * Tab (or calculated spaces)
0000167E  4EB9 00001A06            650                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001684                           651  
00001684                           652  Fn_DSP_DTA1         ** Data 1 (source)
00001684                           653                      ** **************************************************
00001684                           654                      **
00001684                           655  
00001684                           656                      ** Check if source mode set (may not have a source)
00001684  0C39 00FF 00002DAA       657                      CMP.B   #$FF,opDta1
0000168C  6700 017C                658                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
00001690                           659  
00001690                           660                      ** Check source mode
00001690                           661                      **
00001690  0C39 0000 00002DA8       662                      CMP.B   #0,opSrcMod
00001698  6700 0042                663                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000169C  0C39 0001 00002DA8       664                      CMP.B   #1,opSrcMod
000016A4  6700 004A                665                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
000016A8  0C39 0002 00002DA8       666                      CMP.B   #2,opSrcMod
000016B0  6700 0052                667                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
000016B4  0C39 0003 00002DA8       668                      CMP.B   #3,opSrcMod
000016BC  6700 0062                669                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
000016C0  0C39 0004 00002DA8       670                      CMP.B   #4,opSrcMod
000016C8  6700 0076                671                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016CC  0C39 0007 00002DA8       672                      CMP.B   #7,opSrcMod
000016D4  6700 008A                673                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016D8                           674  
000016D8  6000 0114                675                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016DC                           676  
000016DC                           677  Fn_DSP_DTA1_00      ** Handling data mode 0
000016DC  16FC 0044                678                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016E0  1639 00002DA7            679                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016E6  0603 0030                680                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016EA  16C3                     681                      MOVE.B  D3,(A3)+                * Insert Register value
000016EC  6000 0110                682                      BRA     Fn_DSP_OPR2             * Display data 2
000016F0                           683  
000016F0                           684  Fn_DSP_DTA1_01      ** Handling data mode 1
000016F0  16FC 0041                685                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016F4  1639 00002DA7            686                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016FA  0603 0030                687                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016FE  16C3                     688                      MOVE.B  D3,(A3)+                * Insert Register value
00001700  6000 00FC                689                      BRA     Fn_DSP_OPR2             * Display data 2
00001704                           690  
00001704                           691  Fn_DSP_DTA1_02      ** Handling data mode 2
00001704  16FC 0028                692                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001708  16FC 0041                693                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000170C  1639 00002DA7            694                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001712  0603 0030                695                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001716  16C3                     696                      MOVE.B  D3,(A3)+                * Insert Register value
00001718  16FC 0029                697                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000171C  6000 00E0                698                      BRA     Fn_DSP_OPR2             * Display data 2
00001720                           699  
00001720                           700  Fn_DSP_DTA1_03      ** Handling data mode 3
00001720  16FC 0028                701                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001724  16FC 0041                702                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001728  1639 00002DA7            703                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000172E  0603 0030                704                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001732  16C3                     705                      MOVE.B  D3,(A3)+                * Insert Register value
00001734  16FC 0029                706                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001738  16FC 002B                707                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000173C  6000 00C0                708                      BRA     Fn_DSP_OPR2             * Display data 2
00001740                           709  
00001740                           710  Fn_DSP_DTA1_04      ** Handling data mode 4
00001740  16FC 002D                711                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001744  16FC 0028                712                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001748  16FC 0041                713                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000174C  1639 00002DA7            714                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001752  0603 0030                715                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001756  16C3                     716                      MOVE.B  D3,(A3)+                * Insert Register value
00001758  16FC 0029                717                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000175C  6000 00A0                718                      BRA     Fn_DSP_OPR2             * Display data 2
00001760                           719  
00001760                           720  Fn_DSP_DTA1_07      ** Handling data mode 7
00001760  0C39 0000 00002DAE       721                      CMP.B   #0,opDta1T
00001768  6700 001E                722                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000176C  0C39 0001 00002DAE       723                      CMP.B   #1,opDta1T
00001774  6700 0034                724                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001778  0C39 0002 00002DAE       725                      CMP.B   #2,opDta1T
00001780  6700 004A                726                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001784                           727  
00001784  6000 0068                728                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001788                           729  
00001788                           730  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001788  49F9 00002DAA            731                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002DB5            732                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019D4            733                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002DB5            734                      LEA     opStrDtaWrd,A4
000017A0  4EB9 00001A06            735                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0056                736                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           737  
000017AA                           738  Fn_DSP_DTA1_WRD     ** Display data Word
000017AA  49F9 00002DAA            739                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002DB5            740                      LEA     opStrDtaWrd,A5          * output string
000017B6  4EB9 000019D4            741                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002DB5            742                      LEA     opStrDtaWrd,A4
000017C2  4EB9 00001A06            743                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0034                744                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           745  
000017CC                           746  Fn_DSP_DTA1_LNG     ** Display data Long
000017CC  49F9 00002DAA            747                      LEA     opDta1,A4               * input hex
000017D2  4BF9 00002DBA            748                      LEA     opStrDtaLng,A5          * output string
000017D8  4EB9 000019D4            749                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017DE  49F9 00002DBA            750                      LEA     opStrDtaLng,A4
000017E4  4EB9 00001A06            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017EA  6000 0012                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017EE                           753  
000017EE                           754  Fn_DSP_DTA1_ERR     ** Something is messed up
000017EE  49F9 00002E96            755                      LEA     msgErr,A4
000017F4  4EB9 00001A06            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017FA  6000 0002                757                      BRA     Fn_DSP_OPR2             * Display data 2
000017FE                           758  
000017FE                           759  Fn_DSP_OPR2         ** Display Second Operand
000017FE  49F9 000031AB            760                      LEA     opComma,A4              * Comma
00001804  4EB9 00001A06            761                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000180A                           762  
0000180A                           763  Fn_DSP_DTA2         ** Data 2 (destination)
0000180A                           764                      ** **************************************************
0000180A                           765                      **
0000180A                           766  
0000180A                           767                      ** Check if destination mode set (may not have a destination)
0000180A  0C39 00FF 00002DA6       768                      CMP.B   #$FF,opDstMod
00001812  6700 0170                769                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
00001816                           770  
00001816  0C39 0000 00002DA6       771                      CMP.B   #0,opDstMod
0000181E  6700 0042                772                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001822  0C39 0001 00002DA6       773                      CMP.B   #1,opDstMod
0000182A  6700 004A                774                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000182E  0C39 0002 00002DA6       775                      CMP.B   #2,opDstMod
00001836  6700 0052                776                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
0000183A  0C39 0003 00002DA6       777                      CMP.B   #3,opDstMod
00001842  6700 0062                778                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001846  0C39 0004 00002DA6       779                      CMP.B   #4,opDstMod
0000184E  6700 0076                780                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001852  0C39 0007 00002DA6       781                      CMP.B   #7,opDstMod
0000185A  6700 008A                782                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000185E                           783  
0000185E  6000 0114                784                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001862                           785  
00001862                           786  Fn_DSP_DTA2_00      ** Handling mode 0
00001862  16FC 0044                787                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001866  1639 00002DA5            788                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000186C  0603 0030                789                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001870  16C3                     790                      MOVE.B  D3,(A3)+                * Insert Register value
00001872  6000 0110                791                      BRA     Fn_DSP_DONE             * Done with display
00001876                           792  
00001876                           793  Fn_DSP_DTA2_01      ** Handling mode 1
00001876  16FC 0041                794                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000187A  1639 00002DA5            795                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001880  0603 0030                796                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001884  16C3                     797                      MOVE.B  D3,(A3)+                * Insert Register value
00001886  6000 00FC                798                      BRA     Fn_DSP_DONE             * Done with display
0000188A                           799  
0000188A                           800  Fn_DSP_DTA2_02      ** Handling mode 2
0000188A  16FC 0028                801                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000188E  16FC 0041                802                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001892  1639 00002DA5            803                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001898  0603 0030                804                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000189C  16C3                     805                      MOVE.B  D3,(A3)+                * Insert Register value
0000189E  16FC 0029                806                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018A2  6000 00E0                807                      BRA     Fn_DSP_DONE             * Done with display
000018A6                           808  
000018A6                           809  Fn_DSP_DTA2_03      ** Handling mode 3
000018A6  16FC 0028                810                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AA  16FC 0041                811                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018AE  1639 00002DA5            812                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
000018B4  0603 0030                813                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018B8  16C3                     814                      MOVE.B  D3,(A3)+                * Insert Register value
000018BA  16FC 0029                815                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018BE  16FC 002B                816                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018C2  6000 00C0                817                      BRA     Fn_DSP_DONE             * Done with display
000018C6                           818  
000018C6                           819  Fn_DSP_DTA2_04      ** Handling mode 4
000018C6  16FC 002D                820                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018CA  16FC 0028                821                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018CE  16FC 0041                822                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018D2  1639 00002DA7            823                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018D8  0603 0030                824                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018DC  16C3                     825                      MOVE.B  D3,(A3)+                * Insert Register value
000018DE  16FC 0029                826                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018E2  6000 00A0                827                      BRA     Fn_DSP_DONE             * Done with display
000018E6                           828  
000018E6                           829  Fn_DSP_DTA2_07      ** Handling mode 8
000018E6  0C39 0000 00002DB4       830                      CMP.B   #0,opDta2T
000018EE  6700 001E                831                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018F2  0C39 0001 00002DB4       832                      CMP.B   #1,opDta2T
000018FA  6700 0034                833                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018FE  0C39 0002 00002DB4       834                      CMP.B   #2,opDta2T
00001906  6700 004A                835                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
0000190A                           836  
0000190A  6000 0068                837                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
0000190E                           838  
0000190E                           839  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
0000190E  49F9 00002DB0            840                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002DB5            841                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019D4            842                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002DB5            843                      LEA     opStrDtaWrd,A4
00001926  4EB9 00001A06            844                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0056                845                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           846  
00001930                           847  Fn_DSP_DTA2_WRD     ** Display data Word
00001930  49F9 00002DB0            848                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002DB5            849                      LEA     opStrDtaWrd,A5          * output string
0000193C  4EB9 000019D4            850                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002DB5            851                      LEA     opStrDtaWrd,A4
00001948  4EB9 00001A06            852                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0034                853                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           854  
00001952                           855  Fn_DSP_DTA2_LNG     ** Display data Long
00001952  49F9 00002DB0            856                      LEA     opDta2,A4               * input hex
00001958  4BF9 00002DBA            857                      LEA     opStrDtaLng,A5          * output string
0000195E  4EB9 000019D4            858                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001964  49F9 00002DBA            859                      LEA     opStrDtaLng,A4
0000196A  4EB9 00001A06            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001970  6000 0012                861                      BRA     Fn_DSP_DONE             * Display data 2
00001974                           862  
00001974                           863  Fn_DSP_DTA2_ERR     ** Something is messed up
00001974  49F9 00002E96            864                      LEA     msgErr,A4
0000197A  4EB9 00001A06            865                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001980  6000 0002                866                      BRA     Fn_DSP_DONE             * Display data 2
00001984                           867  
00001984                           868  Fn_Dsp_Done         ** Done with instruction display
00001984  16BC 0000                869                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001988  43F9 00002D50            870                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000198E  103C 000D                871                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001992  4E4F                     872                      TRAP    #15
00001994                           873  
00001994                           874                      ** We're all done here - time to go
00001994                           875                      **
00001994  4E75                     876                      RTS                             * Return back to caller
00001996                           877  
00001996                           878  ** -----------------------------------------------------------
00001996                           879  ** Convert single ASCII value to hexadecimal
00001996                           880  **    ASCII values should be in range 0-9, A-F
00001996                           881  **
00001996                           882  ** Parameters
00001996                           883  **   D5 - Hex value to assess. Converted value returned in D5
00001996                           884  **
00001996                           885  ** Example:
00001996                           886  **   $30 -> $0
00001996                           887  **   $41 -> $A
00001996                           888  **   $61 -> $A
00001996                           889  ** -----------------------------------------------------------
00001996                           890  SR_ASCII_HEX
00001996  BA3C 0039                891                      CMP.B   #$39,D5
0000199A  6F00 000E                892                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000199E  BA3C 0046                893                      CMP.B   #$46,D5
000019A2  6F00 000C                894                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
000019A6  6000 000E                895                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
000019AA                           896  
000019AA  0405 0030                897  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
000019AE  4E75                     898                      RTS
000019B0  0405 0037                899  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
000019B4  4E75                     900                      RTS
000019B6  0405 0057                901  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
000019BA  4E75                     902                      RTS
000019BC                           903  
000019BC                           904  ** -----------------------------------------------------------
000019BC                           905  ** Convert single hexadecimal value to ASCII
000019BC                           906  **    hexadecimal values should be in range 0-9, A-F
000019BC                           907  **
000019BC                           908  ** Parameters
000019BC                           909  **   D5 - Hex value to assess. Converted value returned in D5
000019BC                           910  **
000019BC                           911  ** Example:
000019BC                           912  **   $0 -> $30
000019BC                           913  **   $A -> $41
000019BC                           914  **   $a -> $41
000019BC                           915  **
000019BC                           916  ** Note: this function is case insensitive an $a = $A = $41 etc.
000019BC                           917  ** -----------------------------------------------------------
000019BC                           918  SR_HEX_ASCII
000019BC  BA3C 0009                919                      CMP.B   #$9,D5
000019C0  6F00 0006                920                      BLE     Fn_HEX_Num              * Hex $0-$9
000019C4  6000 0008                921                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019C8                           922  
000019C8  0605 0030                923  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019CC  4E75                     924                      RTS
000019CE  0605 0037                925  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019D2  4E75                     926                      RTS
000019D4                           927  
000019D4                           928  ** -----------------------------------------------------------
000019D4                           929  ** Copy hexadecimal value to string
000019D4                           930  **
000019D4                           931  ** Parameters
000019D4                           932  **   A4 - Pointer to value copying from
000019D4                           933  **   A5 - Pointer to defined constant
000019D4                           934  **
000019D4                           935  ** Data registers
000019D4                           936  **   D4 - Current byte      (hex value A4)
000019D4                           937  **   D5 - Temp byte         (hex value or string)
000019D4                           938  **   D6 - Number to shift
000019D4                           939  **
000019D4                           940  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019D4                           941  **
000019D4                           942  ** -----------------------------------------------------------
000019D4                           943  SR_HEX_STR
000019D4                           944  
000019D4  181C                     945  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019D6                           946  
000019D6  1A15                     947                      MOVE.B  (A5),D5
000019D8  BA3C 0000                948                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019DC  6700 0022                949                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019E0                           950  
000019E0                           951                      ** First Hex value (high order value)
000019E0  1A04                     952                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019E2  1C3C 0004                953                      MOVE.B  #4,D6
000019E6  EC2D                     954                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019E8  4EB8 19BC                955                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019EC  1AC5                     956                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019EE                           957  
000019EE                           958                      ** Second Hex value (low order value)
000019EE  1A04                     959                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019F0  1C3C 0004                960                      MOVE.B  #4,D6
000019F4  ED2D                     961                      LSL.B   D6,D5
000019F6  EC2D                     962                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019F8  4EB8 19BC                963                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019FC  1AC5                     964                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019FE                           965  
000019FE  60D4                     966                      BRA     Fn_Hex_Str_Loop
00001A00                           967  Fn_Hex_Str_Done
00001A00  1AFC 0000                968                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
00001A04                           969  
00001A04  4E75                     970                      RTS
00001A06                           971  
00001A06                           972  ** -----------------------------------------------------------
00001A06                           973  ** Copy string to output buffer @ A3
00001A06                           974  **
00001A06                           975  ** Parameters
00001A06                           976  **   A4 - Pointer to string copying from
00001A06                           977  **
00001A06                           978  ** Data registers
00001A06                           979  **   D5 - Temp byte         (hex value or string)
00001A06                           980  ** -----------------------------------------------------------
00001A06                           981  SR_CPY_STR_BUF
00001A06                           982  
00001A06  1A14                     983  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
00001A08  BA3C 0000                984                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
00001A0C  6700 0006                985                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
00001A10                           986  
00001A10  16DC                     987                      MOVE.B  (A4)+,(A3)+
00001A12  60F2                     988                      BRA     Fn_CPY_STR_Loop
00001A14                           989  
00001A14  4E75                     990  Fn_CPY_STR_Done     RTS
00001A16                           991  
00001A16                           992  ** -----------------------------------------------------------
00001A16                           993  ** Length of string output buffer
00001A16                           994  ** -----------------------------------------------------------
00001A16                           995  SR_CNT_STR_BUF
00001A16                           996  
00001A16  4E75                     997                      RTS
00001A18                           998  
00001A18                           999  ** -----------------------------------------------------------
00001A18                          1000  ** Includes: Subroutines etc.
00001A18                          1001  ** -----------------------------------------------------------
00001A18                          1002                      INCLUDE 'SR_IDX.X68'
00001A18                          1003  
00001A18                          1004  
00001A18                          1005  SR_IDX
00001A18                          1006  
00001A18  4E75                    1007                RTS
00001A18  4E75                    1008  -------------------- end include --------------------
00001A1A                          1009                      INCLUDE 'SR_ID3.X68'
00001A1A                          1010  
00001A1A                          1011  
00001A1A                          1012  SR_ID3
00001A1A                          1013  
00001A1A                          1014                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
00001A1A                          1015  
00001A1A                          1016  
00001A1A                          1017                      ** ***************************************
00001A1A                          1018                      ** Read first 4 bits
00001A1A                          1019                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
00001A1A                          1020                      ** Note: most instructions will be in this format 3,3,3,3
00001A1A                          1021                      **    I think there is only one instrction that is 4,8
00001A1A                          1022                      **
00001A1A                          1023                      ** ***************************************
00001A1A  3639 00002D3A           1024                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A20  183C 000C               1025                      MOVE.B  #12,D4
00001A24  E86B                    1026                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A26  13C3 00002D3C           1027                      MOVE.B  D3, opID
00001A2C                          1028  
00001A2C                          1029                      ** Read next 3 bits
00001A2C                          1030                      **
00001A2C  3639 00002D3A           1031                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A32  183C 0004               1032                      MOVE.B  #4, D4
00001A36  E96B                    1033                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A38  183C 000D               1034                      MOVE.B  #13,D4
00001A3C  E86B                    1035                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A3E  13C3 00002DA5           1036                      MOVE.B  D3, opDstReg
00001A44                          1037  
00001A44                          1038                      ** Read next 3 bits
00001A44                          1039                      **
00001A44  3639 00002D3A           1040                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A4A  183C 0007               1041                      MOVE.B  #7, D4
00001A4E  E96B                    1042                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A50  183C 000D               1043                      MOVE.B  #13,D4
00001A54  E86B                    1044                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A56  13C3 00002DA6           1045                      MOVE.B  D3, opDstMod
00001A5C                          1046  
00001A5C                          1047                      ** Read next 3 bits
00001A5C                          1048                      **
00001A5C  3639 00002D3A           1049                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A62  183C 000A               1050                      MOVE.B  #10, D4
00001A66  E96B                    1051                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A68  183C 000D               1052                      MOVE.B  #13,D4
00001A6C  E86B                    1053                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A6E  13C3 00002DA8           1054                      MOVE.B  D3, opSrcMod
00001A74                          1055  
00001A74                          1056                      ** Read next 3 bits
00001A74                          1057                      **
00001A74  3639 00002D3A           1058                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A7A  183C 000D               1059                      MOVE.B  #13, D4
00001A7E  E96B                    1060                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A80  183C 000D               1061                      MOVE.B  #13,D4
00001A84  E86B                    1062                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A86  13C3 00002DA7           1063                      MOVE.B  D3, opSrcReg
00001A8C                          1064  
00001A8C                          1065                      ** ***************************************
00001A8C                          1066                      ** Verify this is MOVE or MOVEA
00001A8C                          1067                      **
00001A8C                          1068                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A8C                          1069                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A8C                          1070                      **
00001A8C                          1071                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A8C                          1072                      **
00001A8C                          1073                      ** ***************************************
00001A8C  0C39 0001 00002DA6      1074                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A94  6700 0016               1075                      BEQ     Fn_ID3_Ins02                * Set as instruction 0 MOVEA
00001A98  6000 0002               1076                      BRA     Fn_ID3_Ins01                * Set as instruction 1 MOVE
00001A9C                          1077  
00001A9C  47F9 00002DD0           1078  Fn_ID3_Ins01        LEA     opNam_MOVE,A3
00001AA2  23CB 00002DA0           1079                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA8  6000 001A               1080                      BRA     Fn_ID3_Verify
00001AAC                          1081  
00001AAC  0C39 0001 00002D3C      1082  Fn_ID3_Ins02        CMP.B   #1, opID
00001AB4  6700 01A4               1083                      BEQ     Fn_ID3_Error               * MOVEA cannot have opID = 1 (byte)
00001AB8  47F9 00002DD5           1084                      LEA     opNam_MOVEA,A3
00001ABE  23CB 00002DA0           1085                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AC4                          1086  
00001AC4                          1087                      ** ***************************************
00001AC4                          1088                      ** Verify other instruction parameters are correct
00001AC4                          1089                      **
00001AC4                          1090                      **    DstMod = 0 to 7
00001AC4                          1091                      **    DstReg = 0 to 7
00001AC4                          1092                      **    SrcMod = 0 to 7
00001AC4                          1093                      **    SrcReg = 0 to 7
00001AC4                          1094                      **
00001AC4                          1095                      ** ***************************************
00001AC4  0C39 0000 00002DA6      1096  Fn_ID3_Verify       CMP.B   #0, opDstMod                * Destination mode is >= 0
00001ACC  6D00 018C               1097                      BLT     Fn_ID3_Error
00001AD0  0C39 0007 00002DA6      1098                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AD8  6E00 0180               1099                      BGT     Fn_ID3_Error
00001ADC  0C39 0000 00002DA5      1100                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AE4  6D00 0174               1101                      BLT     Fn_ID3_Error
00001AE8  0C39 0007 00002DA5      1102                      CMP.B   #7, opDstReg                * Destination register <= 7
00001AF0  6E00 0168               1103                      BGT     Fn_ID3_Error
00001AF4                          1104  
00001AF4  0C39 0000 00002DA8      1105                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001AFC  6D00 015C               1106                      BLT     Fn_ID3_Error
00001B00  0C39 0007 00002DA8      1107                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001B08  6E00 0150               1108                      BGT     Fn_ID3_Error
00001B0C  0C39 0000 00002DA7      1109                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001B14  6D00 0144               1110                      BLT     Fn_ID3_Error
00001B18  0C39 0007 00002DA7      1111                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001B20  6E00 0138               1112                      BGT     Fn_ID3_Error
00001B24                          1113  
00001B24                          1114                      ** ***************************************
00001B24                          1115                      ** Set instruction size - the .B,.W,.L part
00001B24                          1116                      ** Note: size set by opID only for MOVE, MOVEA
00001B24                          1117                      **       other instructions use 3 bits for size
00001B24                          1118                      ** ***************************************
00001B24  0C39 0001 00002D3C      1119                      CMP.B   #1, opID                    * Instruction size is Byte
00001B2C  6700 001A               1120                      BEQ     Fn_ID3_SizB
00001B30  0C39 0003 00002D3C      1121                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B38  6700 001A               1122                      BEQ     Fn_ID3_SizW
00001B3C  0C39 0002 00002D3C      1123                      CMP.B   #2, opID                    * Instruction size is Long
00001B44  6700 001A               1124                      BEQ     Fn_ID3_SizL
00001B48  13FC 0000 00002DA4      1125  Fn_ID3_SizB         MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B50  6000 001A               1126                      BRA     Fn_ID3_SrcMod
00001B54  13FC 0001 00002DA4      1127  Fn_ID3_SizW         MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B5C  6000 000E               1128                      BRA     Fn_ID3_SrcMod
00001B60  13FC 0002 00002DA4      1129  Fn_ID3_SizL         MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B68  6000 0002               1130                      BRA     Fn_ID3_SrcMod
00001B6C                          1131  
00001B6C                          1132                      ** ***************************************
00001B6C                          1133                      ** Grab extra DATA if needed
00001B6C                          1134                      **
00001B6C                          1135                      **    If DstMod = 7
00001B6C                          1136                      **       DstReg = 0 (get Word)
00001B6C                          1137                      **       DstReg = 1 (get Long)
00001B6C                          1138                      **
00001B6C                          1139                      **    If SrcMod = 7
00001B6C                          1140                      **       SrcReg = 0 (get Word)
00001B6C                          1141                      **       SrcReg = 1 (get Long)
00001B6C                          1142                      **       SrcReg = 4
00001B6C                          1143                      **          MOVE.B, MOVE.W (get Word)
00001B6C                          1144                      **          MOVE.L         (get Long)
00001B6C                          1145                      **
00001B6C                          1146                      ** SOURCE
00001B6C                          1147                      **
00001B6C                          1148                      ** ***************************************
00001B6C  0C39 0007 00002DA8      1149  Fn_ID3_SrcMod       CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B74  6700 0006               1150                      BEQ     Fn_ID3_ChkSrcReg            * Check source register
00001B78  6000 0088               1151                      BRA     Fn_ID3_ChkDstMod           * Source not 7, now check destination Mod
00001B7C  0C39 0000 00002DA7      1152  Fn_ID3_ChkSrcReg    CMP.B   #0, opSrcReg                 * Check is source register is 0
00001B84  6700 0058               1153                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001B88  0C39 0001 00002DA7      1154                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B90  6700 005E               1155                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001B94  0C39 0004 00002DA7      1156                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B9C  6700 0006               1157                      BEQ     Fn_ID3_DtaSrcImd            * Load first word into word one
00001BA0  6000 00B8               1158                      BRA     FN_ID3_Error                * Invalid register value
00001BA4                          1159  
00001BA4                          1160                      ** Note: Checking immediate value
00001BA4                          1161                      **       opID as size is specific to MOVE, MOVEA
00001BA4                          1162                      **       other instructions will use 3 bits to set size, not part of ID
00001BA4                          1163                      **
00001BA4  0C39 0001 00002D3C      1164  Fn_ID3_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00001BAC  6700 001E               1165                      BEQ     Fn_ID3_DtaSrcByt            * Load next byte
00001BB0  0C39 0003 00002D3C      1166                      CMP.B   #3, opID                    * opID = 3 - size is word
00001BB8  6700 0024               1167                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001BBC  0C39 0002 00002D3C      1168                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BC4  6700 002A               1169                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001BC8  6000 0090               1170                      BRA     Fn_ID3_Error                * Invalid opID (this should never happen)
00001BCC                          1171  
00001BCC  33DA 00002DAA           1172  Fn_ID3_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BD2  13FC 0000 00002DAE      1173                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BDA  6000 0026               1174                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BDE  33DA 00002DAA           1175  Fn_ID3_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BE4  13FC 0001 00002DAE      1176                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BEC  6000 0014               1177                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BF0  23DA 00002DAA           1178  Fn_ID3_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BF6  13FC 0002 00002DAE      1179                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BFE  6000 0002               1180                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001C02                          1181  
00001C02                          1182                      ** DESTINATION
00001C02                          1183                      **
00001C02  0C39 0007 00002DA6      1184  Fn_ID3_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00001C0A  6700 0006               1185                      BEQ     Fn_ID3_ChkDstReg            * Check destination register
00001C0E  6000 0042               1186                      BRA     Fn_ID3_Done                 * Destination not 7, done with data
00001C12  0C39 0000 00002DA5      1187  Fn_ID3_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00001C1A  6700 0012               1188                      BEQ     Fn_ID3_DtaDstWrd            * Load next word
00001C1E  0C39 0001 00002DA5      1189                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C26  6700 0018               1190                      BEQ     Fn_ID3_DtaDstLng            * Load next long
00001C2A  6000 002E               1191                      BRA     fn_ID3_Error                * Invalid registration Mode
00001C2E                          1192  
00001C2E  33DA 00002DB0           1193  Fn_ID3_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C34  13FC 0001 00002DB4      1194                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C3C  6000 0014               1195                      BRA     Fn_ID3_Done
00001C40  23DA 00002DB0           1196  Fn_ID3_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C46  13FC 0002 00002DB4      1197                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C4E  6000 0002               1198                      BRA     Fn_ID3_Done
00001C52                          1199  
00001C52  13FC 0000 00002D3D      1200  Fn_ID3_Done         MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C5A                          1201  
00001C5A                          1202  Fn_ID3_Error                                           * Exit out if error - main subroutine will handle DATA
00001C5A                          1203                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C5A  4E75                    1204                      RTS                                 * Return to main
00001C5A  4E75                    1205  -------------------- end include --------------------
00001C5C                          1206                      INCLUDE 'SR_ID4.X68'
00001C5C                          1207  
00001C5C                          1208  SR_ID4              * This is to grab the first four that are already set, ID4
00001C5C  3639 00002D3A           1209                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C62  183C 000C               1210                      MOVE.B  #12,D4
00001C66  E86B                    1211                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C68  13C3 00002D3C           1212                      MOVE.B  D3, opID        
00001C6E                          1213                      
00001C6E                          1214                      * Read next 3 bits into D3
00001C6E  3639 00002D3A           1215                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C74  183C 0004               1216                      MOVE.B  #4, D4
00001C78  E96B                    1217                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C7A  183C 000D               1218                      MOVE.B  #13,D4
00001C7E  E86B                    1219                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C80  13C3 00002DA5           1220                      MOVE.B  D3, opDstReg
00001C86                          1221                      
00001C86                          1222                      * Read next 3 bits into D3
00001C86  3639 00002D3A           1223                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C8C  183C 0007               1224                      MOVE.B  #7, D4
00001C90  E96B                    1225                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C92  183C 000D               1226                      MOVE.B  #13,D4
00001C96  E86B                    1227                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C98  13C3 00002DA6           1228                      MOVE.B  D3, opDstMod
00001C9E                          1229  
00001C9E                          1230                      ** Read next 3 bits
00001C9E                          1231                      **
00001C9E  3639 00002D3A           1232                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CA4  183C 000A               1233                      MOVE.B  #10, D4
00001CA8  E96B                    1234                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CAA  183C 000D               1235                      MOVE.B  #13,D4
00001CAE  E86B                    1236                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CB0  13C3 00002DA8           1237                      MOVE.B  D3, opSrcMod
00001CB6                          1238  
00001CB6                          1239                      ** Read next 3 bits
00001CB6                          1240                      **
00001CB6  3639 00002D3A           1241                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CBC  183C 000D               1242                      MOVE.B  #13, D4
00001CC0  E96B                    1243                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CC2  183C 000D               1244                      MOVE.B  #13,D4
00001CC6  E86B                    1245                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CC8  13C3 00002DA7           1246                      MOVE.B  D3, opSrcReg
00001CCE                          1247                      
00001CCE                          1248                      ** ***************************************
00001CCE                          1249                      ** Verify instruction
00001CCE                          1250                      **
00001CCE                          1251                      ** JSR: If DstReg=7, DstMod=2 
00001CCE                          1252                      ** LEA: If DstReg=0-7, DstMod=7
00001CCE                          1253                      ** MOVEM:
00001CCE                          1254                      **    RegToMem: DestReg=4, DestMod=2,3
00001CCE                          1255                      **    MemToReg: DestReg=6, DestMod=2,3
00001CCE                          1256                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CCE                          1257                      ** NOT: If DstReg=3, DstMod=0-2
00001CCE                          1258                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CCE                          1259                      **
00001CCE                          1260                      ** ***************************************
00001CCE  0C39 0000 00002DA6      1261                      CMP.B   #0, opDstMod
00001CD6  6700 02EA               1262                      BEQ     Fn_ID4_NOT
00001CDA  0C39 0001 00002DA6      1263                      CMP.B   #1, opDstMod
00001CE2  6700 002A               1264                      BEQ     Fn_ID4_CheckD1
00001CE6  0C39 0002 00002DA6      1265                      CMP.B   #2, opDstMod
00001CEE  6700 0042               1266                      BEQ     Fn_ID4_CheckD2
00001CF2  0C39 0003 00002DA6      1267                      CMP.B   #3, opDstMod
00001CFA  6700 0066               1268                      BEQ     Fn_ID4_CheckD3
00001CFE  0C39 0007 00002DA6      1269                      CMP.B   #7, opDstMod
00001D06  6700 011E               1270                      BEQ     Fn_ID4_LEA
00001D0A  6000 0462               1271                      BRA     Fn_ID4_Error
00001D0E                          1272                      
00001D0E                          1273  Fn_ID4_CheckD1
00001D0E  0C39 0003 00002DA5      1274                      CMP.B   #3, opDstReg
00001D16  6700 02AA               1275                      BEQ     Fn_ID4_NOT
00001D1A  0C39 0001 00002DA7      1276                      CMP.B   #1, opSrcReg
00001D22  6700 025E               1277                      BEQ     Fn_ID4_NOP
00001D26  0C39 0005 00002DA7      1278                      CMP.B   #5, opSrcReg
00001D2E  6700 02E8               1279                      BEQ     Fn_ID4_RTS
00001D32                          1280                      
00001D32                          1281  Fn_ID4_CheckD2
00001D32  0C39 0003 00002DA5      1282                      CMP.B   #3, opDstReg
00001D3A  6700 0286               1283                      BEQ     Fn_ID4_NOT
00001D3E  0C39 0004 00002DA5      1284                      CMP.B   #4, opDstReg
00001D46  6700 014E               1285                      BEQ     Fn_ID4_MOVEMRTOM
00001D4A  0C39 0006 00002DA5      1286                      CMP.B   #6, opDstReg
00001D52  6700 01B2               1287                      BEQ     Fn_ID4_MOVEMMTOR
00001D56  0C39 0007 00002DA5      1288                      CMP.B   #7, opDstReg
00001D5E  6700 001A               1289                      BEQ     Fn_ID4_JSR
00001D62                          1290  Fn_ID4_CheckD3
00001D62  0C39 0004 00002DA5      1291                      CMP.B   #4, opDstReg
00001D6A  6700 012A               1292                      BEQ     Fn_ID4_MOVEMRTOM
00001D6E  0C39 0006 00002DA5      1293                      CMP.B   #6, opDstReg
00001D76  6700 018E               1294                      BEQ     Fn_ID4_MOVEMMTOR
00001D7A                          1295  
00001D7A  47F9 00002DF1           1296  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D80  23CB 00002DA0           1297                      MOVE.L  A3, opPtrNam
00001D86                          1298                      
00001D86  0C39 0007 00002DA5      1299  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D8E  6600 03DE               1300                      BNE     Fn_ID4_Error
00001D92  0C39 0002 00002DA6      1301                      CMP.B   #2, opDstMod
00001D9A  6600 03D2               1302                      BNE     Fn_ID4_Error
00001D9E                          1303                      
00001D9E                          1304                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D9E  0C39 0000 00002DA5      1305                      CMP.B   #0, opDstReg
00001DA6  6700 03C6               1306                      BEQ     Fn_ID4_Error
00001DAA  0C39 0001 00002DA5      1307                      CMP.B   #1, opDstReg
00001DB2  6700 03BA               1308                      BEQ     Fn_ID4_Error
00001DB6  0C39 0003 00002DA5      1309                      CMP.B   #3, opDstReg
00001DBE  6700 03AE               1310                      BEQ     Fn_ID4_Error
00001DC2  0C39 0004 00002DA5      1311                      CMP.B   #4, opDstReg
00001DCA  6700 03A2               1312                      BEQ     Fn_ID4_Error
00001DCE                          1313                      
00001DCE                          1314                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DCE  0C39 0000 00002DA8      1315                      CMP.B   #0, opSrcMod
00001DD6  6700 0396               1316                      BEQ     Fn_ID4_Error
00001DDA  0C39 0001 00002DA8      1317                      CMP.B   #1, opSrcMod
00001DE2  6700 038A               1318                      BEQ     Fn_ID4_Error
00001DE6  0C39 0003 00002DA8      1319                      CMP.B   #3, opSrcMod
00001DEE  6700 037E               1320                      BEQ     Fn_ID4_Error
00001DF2  0C39 0004 00002DA8      1321                      CMP.B   #4, opSrcMod
00001DFA  6700 0372               1322                      BEQ     Fn_ID4_Error
00001DFE                          1323                      
00001DFE                          1324                      * Make sure src reg is between 0-7
00001DFE  0C39 0000 00002DA7      1325                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E06  6D00 0366               1326                      BLT     Fn_ID4_Error
00001E0A  0C39 0007 00002DA7      1327                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E12  6E00 035A               1328                      BGT     Fn_ID4_Error
00001E16                          1329                      
00001E16  0C39 0007 00002DA8      1330  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001E1E  6700 0238               1331                      BEQ     Fn_ID4_Data
00001E22  6000 034C               1332                      BRA     Fn_ID4_Done
00001E26                          1333  
00001E26  47F9 00002DDB           1334  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E2C  23CB 00002DA0           1335                      MOVE.L  A3, opPtrNam
00001E32                          1336                      
00001E32  0C39 0007 00002DA6      1337  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E3A  6600 0332               1338                      BNE     Fn_ID4_Error
00001E3E                          1339                      
00001E3E                          1340                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E3E  0C39 0000 00002DA8      1341                      CMP.B   #0, opSrcMod
00001E46  6700 0326               1342                      BEQ     Fn_ID4_Error
00001E4A  0C39 0001 00002DA8      1343                      CMP.B   #1, opSrcMod
00001E52  6700 031A               1344                      BEQ     Fn_ID4_Error
00001E56  0C39 0003 00002DA8      1345                      CMP.B   #3, opSrcMod
00001E5E  6700 030E               1346                      BEQ     Fn_ID4_Error
00001E62  0C39 0004 00002DA8      1347                      CMP.B   #4, opSrcMod
00001E6A  6700 0302               1348                      BEQ     Fn_ID4_Error
00001E6E                          1349                      
00001E6E                          1350                      * Make sure src reg is between 0-7
00001E6E  0C39 0000 00002DA7      1351                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E76  6D00 02F6               1352                      BLT     Fn_ID4_Error
00001E7A  0C39 0007 00002DA7      1353                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E82  6E00 02EA               1354                      BGT     Fn_ID4_Error
00001E86                          1355                      
00001E86  0C39 0007 00002DA8      1356  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E8E  6700 01C8               1357                      BEQ     Fn_ID4_Data
00001E92  6000 02DC               1358                      BRA     Fn_ID4_Done
00001E96                          1359  
00001E96  47F9 00002DE3           1360  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E9C  23CB 00002DA0           1361                      MOVE.L  A3, opPtrNam
00001EA2                          1362                      
00001EA2  0C39 0004 00002DA5      1363  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001EAA  6600 02C2               1364                      BNE     Fn_ID4_Error
00001EAE                          1365                      
00001EAE                          1366                      * Make sure dest mode is only 2 or 3
00001EAE  0C39 0003 00002DA7      1367                      CMP.B   #3, opSrcReg                * Destination register > 2
00001EB6  6D00 02B6               1368                      BLT     Fn_ID4_Error
00001EBA  0C39 0003 00002DA7      1369                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EC2  6E00 02AA               1370                      BGT     Fn_ID4_Error
00001EC6                          1371                      
00001EC6                          1372                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EC6  0C39 0000 00002DA8      1373                      CMP.B   #0, opSrcMod
00001ECE  6700 029E               1374                      BEQ     Fn_ID4_Error
00001ED2  0C39 0001 00002DA8      1375                      CMP.B   #1, opSrcMod
00001EDA  6700 0292               1376                      BEQ     Fn_ID4_Error
00001EDE  0C39 0003 00002DA8      1377                      CMP.B   #3, opSrcMod
00001EE6  6700 0286               1378                      BEQ     Fn_ID4_Error
00001EEA                          1379                      
00001EEA                          1380                      * Make sure src reg is between 0-7
00001EEA  0C39 0000 00002DA7      1381                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001EF2  6D00 027A               1382                      BLT     Fn_ID4_Error
00001EF6  0C39 0007 00002DA7      1383                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EFE  6E00 026E               1384                      BGT     Fn_ID4_Error
00001F02  6000 006E               1385                      BRA Fn_ID4_MOVEM_Src
00001F06                          1386  
00001F06  47F9 00002DE3           1387  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001F0C  23CB 00002DA0           1388                      MOVE.L  A3, opPtrNam
00001F12                          1389                      
00001F12  0C39 0006 00002DA5      1390  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001F1A  6600 0252               1391                      BNE     Fn_ID4_Error
00001F1E                          1392                      
00001F1E                          1393                      * Make sure dest mode is only 2 or 3
00001F1E  0C39 0003 00002DA7      1394                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F26  6D00 0246               1395                      BLT     Fn_ID4_Error
00001F2A  0C39 0003 00002DA7      1396                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F32  6E00 023A               1397                      BGT     Fn_ID4_Error
00001F36                          1398                      
00001F36                          1399                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F36  0C39 0000 00002DA8      1400                      CMP.B   #0, opSrcMod
00001F3E  6700 022E               1401                      BEQ     Fn_ID4_Error
00001F42  0C39 0001 00002DA8      1402                      CMP.B   #1, opSrcMod
00001F4A  6700 0222               1403                      BEQ     Fn_ID4_Error
00001F4E  0C39 0003 00002DA8      1404                      CMP.B   #3, opSrcMod
00001F56  6700 0216               1405                      BEQ     Fn_ID4_Error
00001F5A                          1406                      
00001F5A                          1407                      * Make sure src reg is between 0-7
00001F5A  0C39 0000 00002DA7      1408                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F62  6D00 020A               1409                      BLT     Fn_ID4_Error
00001F66  0C39 0007 00002DA7      1410                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F6E  6E00 01FE               1411                      BGT     Fn_ID4_Error
00001F72                          1412                      
00001F72  0C39 0007 00002DA8      1413  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F7A  6700 00DC               1414                      BEQ     Fn_ID4_Data
00001F7E  6000 01E4               1415                      BRA     Fn_ID4_GrabMask
00001F82                          1416  
00001F82  47F9 00002DE9           1417  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F88  23CB 00002DA0           1418                      MOVE.L  A3, opPtrNam
00001F8E                          1419  
00001F8E  0C39 0007 00002DA5      1420  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F96  6600 01D6               1421                      BNE     Fn_ID4_Error
00001F9A  0C39 0001 00002DA6      1422                      CMP.B   #1, opDstMod
00001FA2  6600 01CA               1423                      BNE     Fn_ID4_Error
00001FA6  0C39 0006 00002DA8      1424                      CMP.B   #6, opSrcMod
00001FAE  6600 01BE               1425                      BNE     Fn_ID4_Error
00001FB2  0C39 0001 00002DA7      1426                      CMP.B   #1, opSrcReg
00001FBA  6600 01B2               1427                      BNE     Fn_ID4_Error
00001FBE  6000 01B0               1428                      BRA     Fn_ID4_Done
00001FC2                          1429  
00001FC2                          1430  
00001FC2  47F9 00002DDF           1431  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FC8  23CB 00002DA0           1432                      MOVE.L  A3, opPtrNam
00001FCE                          1433                      
00001FCE  0C39 0003 00002DA5      1434  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FD6  6600 0196               1435                      BNE     Fn_ID4_Error
00001FDA                          1436                      
00001FDA                          1437                      * Make sure src mode is not 1
00001FDA  0C39 0001 00002DA8      1438                      CMP.B   #1, opSrcMod
00001FE2  6700 018A               1439                      BEQ     Fn_ID4_Error
00001FE6                          1440                      
00001FE6                          1441                      * Make sure src reg is between 0-7
00001FE6  0C39 0000 00002DA7      1442                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FEE  6D00 017E               1443                      BLT     Fn_ID4_Error
00001FF2  0C39 0007 00002DA7      1444                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FFA  6E00 0172               1445                      BGT     Fn_ID4_Error
00001FFE                          1446                      
00001FFE  33F9 00002DA6 00002D3C  1447  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00002008  0C39 0007 00002DA8      1448                      CMP.B   #7, opSrcMod
00002010  6700 0046               1449                      BEQ     Fn_ID4_Data
00002014  6000 015A               1450                      BRA     Fn_ID4_Done
00002018                          1451  
00002018  47F9 00002DED           1452  Fn_ID4_RTS          LEA    opNam_RTS,A3
0000201E  23CB 00002DA0           1453                      MOVE.L A3, opPtrNam
00002024                          1454                      
00002024  0C39 0007 00002DA5      1455  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000202C  6600 0140               1456                      BNE     Fn_ID4_Error
00002030  0C39 0001 00002DA6      1457                      CMP.B   #1, opDstMod
00002038  6600 0134               1458                      BNE     Fn_ID4_Error
0000203C  0C39 0006 00002DA8      1459                      CMP.B   #6, opSrcMod
00002044  6600 0128               1460                      BNE     Fn_ID4_Error
00002048  0C39 0005 00002DA7      1461                      CMP.B   #5, opSrcReg
00002050  6600 011C               1462                      BNE     Fn_ID4_Error
00002054  6000 011A               1463                      BRA     Fn_ID4_Done
00002058                          1464  
00002058  0C39 0000 00002DA7      1465  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
00002060  6700 0058               1466                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002064  0C39 0001 00002DA7      1467                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000206C  6700 005E               1468                      BEQ     Fn_ID4_DtaLng               * Load next long
00002070  0C39 0004 00002DA7      1469                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002078  6700 0006               1470                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000207C  6000 00F0               1471                      BRA     FN_ID4_Error                * Invalid register value
00002080                          1472                      
00002080  0C39 0001 00002D3C      1473  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002088  6700 001E               1474                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000208C  0C39 0003 00002D3C      1475                      CMP.B   #3, opID                    * opID = 3 - size is word
00002094  6700 0024               1476                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002098  0C39 0002 00002D3C      1477                      CMP.B   #2, opID                    * opID = 0 - size is long
000020A0  6700 002A               1478                      BEQ     Fn_ID4_DtaLng               * Load next
000020A4  6000 00C8               1479                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
000020A8                          1480  
000020A8  33DA 00002DB0           1481  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000020AE  13FC 0000 00002DB4      1482                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000020B6  6000 00B8               1483                      BRA     Fn_ID4_Done
000020BA  33DA 00002DB0           1484  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
000020C0  13FC 0001 00002DB4      1485                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020C8  6000 00A6               1486                      BRA     Fn_ID4_Done
000020CC  23DA 00002DB0           1487  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020D2  13FC 0002 00002DB4      1488                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020DA  6000 0094               1489                      BRA     Fn_ID4_Done
000020DE  0C39 0000 00002DA7      1490  Fn_ID4_Data_MVM     CMP.B   #0, opSrcReg                * Check is source register is 0
000020E6  6700 0058               1491                      BEQ     Fn_ID4_DtaWrd_MVM           * Load next word
000020EA  0C39 0001 00002DA7      1492                      CMP.B   #1, opSrcReg                * Check if source register is 1
000020F2  6700 005E               1493                      BEQ     Fn_ID4_DtaLng_MVM           * Load next long
000020F6  0C39 0004 00002DA7      1494                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
000020FE  6700 0006               1495                      BEQ     Fn_ID4_DtaImd_MVM           * Load first word into word one
00002102  6000 006A               1496                      BRA     FN_ID4_Error                * Invalid register value
00002106                          1497                      
00002106  0C39 0001 00002D3C      1498  Fn_ID4_DtaImd_MVM    CMP.B   #1, opID                    * opID = 0 - size is byte
0000210E  6700 001E               1499                      BEQ     Fn_ID4_DtaByt_MVM            * Load next byte
00002112  0C39 0003 00002D3C      1500                      CMP.B   #3, opID                     * opID = 3 - size is word
0000211A  6700 0024               1501                      BEQ     Fn_ID4_DtaWrd_MVM            * Load next word
0000211E  0C39 0002 00002D3C      1502                      CMP.B   #2, opID                     * opID = 0 - size is long
00002126  6700 002A               1503                      BEQ     Fn_ID4_DtaLng_MVM            * Load next
0000212A  6000 0042               1504                      BRA     Fn_ID4_Error                 * Invalid opID (this should never happen) long
0000212E                          1505  
0000212E  33DA 00002DB0           1506  Fn_ID4_DtaByt_MVM   MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002134  13FC 0000 00002DB4      1507                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
0000213C  6000 0026               1508                      BRA     Fn_ID4_GrabMask
00002140  33DA 00002DB0           1509  Fn_ID4_DtaWrd_MVM   MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002146  13FC 0001 00002DB4      1510                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
0000214E  6000 0014               1511                      BRA     Fn_ID4_GrabMask
00002152  23DA 00002DB0           1512  Fn_ID4_DtaLng_MVM   MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002158  13FC 0002 00002DB4      1513                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002160  6000 0002               1514                      BRA     Fn_ID4_GrabMask
00002164                          1515              
00002164  23DA 00002DC4           1516  Fn_ID4_GrabMask     MOVE.L  (A2)+, opMask
0000216A  6000 0004               1517              BRA     Fn_ID4_Done
0000216E                          1518  
0000216E                          1519  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
0000216E                          1520                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000216E  4E75                    1521                      RTS                                  * Return to main
00002170                          1522  
00002170  13FC 0000 00002D3D      1523  Fn_ID4_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002178  4E75                    1524              RTS
0000217A                          1525  
0000217A                          1526  
0000217A                          1527  
0000217A                          1528  -------------------- end include --------------------
0000217A                          1529                      INCLUDE 'SR_ID5.X68'
0000217A                          1530  
0000217A                          1531  
0000217A                          1532  SR_ID5              * This is to grab the first four that are already set, ID5
0000217A  3639 00002D3A           1533                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002180  183C 000C               1534                      MOVE.B  #12,D4
00002184  E86B                    1535                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002186  13C3 00002D3C           1536                      MOVE.B  D3, opID        
0000218C                          1537                      
0000218C                          1538                      * Read next 3 bits into D3
0000218C  3639 00002D3A           1539                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002192  183C 0004               1540                      MOVE.B  #4, D4
00002196  E96B                    1541                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002198  183C 000D               1542                      MOVE.B  #13,D4
0000219C  E86B                    1543                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000219E  13C3 00002DA8           1544                      MOVE.B  D3, opSrcMod
000021A4                          1545                      
000021A4                          1546                      * Read next 3 bits into D3
000021A4  3639 00002D3A           1547                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021AA  183C 0007               1548                      MOVE.B  #7, D4
000021AE  E96B                    1549                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000021B0  183C 000D               1550                      MOVE.B  #13,D4
000021B4  E86B                    1551                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021B6  13C3 00002D3C           1552                      MOVE.B  D3, opID
000021BC                          1553  
000021BC                          1554                      ** Read next 3 bits
000021BC                          1555                      **
000021BC  3639 00002D3A           1556                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021C2  183C 000A               1557                      MOVE.B  #10, D4
000021C6  E96B                    1558                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000021C8  183C 000D               1559                      MOVE.B  #13,D4
000021CC  E86B                    1560                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021CE  13C3 00002DA6           1561                      MOVE.B  D3, opDstMod
000021D4                          1562  
000021D4                          1563                      ** Read next 3 bits
000021D4                          1564                      **
000021D4  3639 00002D3A           1565                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021DA  183C 000D               1566                      MOVE.B  #13, D4
000021DE  E96B                    1567                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000021E0  183C 000D               1568                      MOVE.B  #13,D4
000021E4  E86B                    1569                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021E6  13C3 00002DA5           1570                      MOVE.B  D3, opDstReg
000021EC                          1571              
000021EC                          1572              ** Set name
000021EC  47F9 00002DF5           1573              LEA     opNam_ADDQ,A3
000021F2                          1574              
000021F2                          1575  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
000021F2  0C39 0000 00002DA8      1576                      CMP.B   #0, opSrcMod                * Destination register >= 0
000021FA  6D00 00E4               1577                      BLT     Fn_ID5_Error
000021FE  0C39 0007 00002DA5      1578                      CMP.B   #7, opDstReg                * Destination register <= 7
00002206  6E00 00D8               1579                      BGT     Fn_ID5_Error
0000220A                          1580              
0000220A                          1581              * Make sure opId  is between 0-2
0000220A  0C39 0000 00002D3C      1582                      CMP.B   #0, opID                    * Destination register >= 0
00002212  6D00 00CC               1583                      BLT     Fn_ID5_Error
00002216  0C39 0002 00002D3C      1584                      CMP.B   #2, opID                    * Destination register <= 2
0000221E  6E00 00C0               1585                      BGT     Fn_ID5_Error
00002222                          1586              
00002222                          1587              * Move data to  appropriate places for printing
00002222  13FC 0007 00002DA8      1588              MOVE.B  #7,opSrcMod
0000222A  13FC 0004 00002DA7      1589              MOVE.B  #4,opSrcReg
00002232                          1590  
00002232                          1591                      ** Note: Checking immediate value
00002232                          1592                      **       opID as size is specific to MOVE, MOVEA
00002232                          1593                      **       other instructions will use 3 bits to set size, not part of ID
00002232                          1594                      **
00002232  0C39 0001 00002D3C      1595  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000223A  6700 001E               1596                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
0000223E  0C39 0003 00002D3C      1597                      CMP.B   #3, opID                    * opID = 3 - size is word
00002246  6700 0024               1598                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
0000224A  0C39 0002 00002D3C      1599                      CMP.B   #2, opID                    * opID = 0 - size is long
00002252  6700 002A               1600                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
00002256  6000 0088               1601                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
0000225A                          1602  
0000225A  33DA 00002DAA           1603  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002260  13FC 0000 00002DAE      1604                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002268  6000 0026               1605                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
0000226C  33DA 00002DAA           1606  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002272  13FC 0001 00002DAE      1607                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000227A  6000 0014               1608                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
0000227E  23DA 00002DAA           1609  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002284  13FC 0002 00002DAE      1610                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000228C  6000 0002               1611                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
00002290                          1612              
00002290  0C39 0007 00002DA6      1613  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00002298  6700 0006               1614                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
0000229C  6000 0044               1615                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
000022A0  0C39 0000 00002DA5      1616  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
000022A8  6700 0012               1617                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
000022AC  0C39 0001 00002DA5      1618                      CMP.B   #1, opDstReg                * Check if destination register is 1
000022B4  6700 0018               1619                      BEQ     Fn_ID5_DtaDstLng            * Load next long
000022B8  6000 0026               1620                      BRA     Fn_ID5_Error                * Invalid registration Mode
000022BC                          1621  
000022BC  33DA 00002DB0           1622  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000022C2  13FC 0001 00002DB4      1623                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
000022CA  6000 0016               1624                      BRA     Fn_ID5_Done
000022CE  23DA 00002DB0           1625  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000022D4  13FC 0002 00002DB4      1626                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
000022DC  6000 0004               1627                      BRA     Fn_ID5_Done
000022E0                          1628  
000022E0                          1629  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
000022E0                          1630                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000022E0  4E75                    1631                      RTS   
000022E2                          1632              
000022E2  13FC 0000 00002D3D      1633  Fn_ID5_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000022EA  4E75                    1634              RTS
000022EA  4E75                    1635  -------------------- end include --------------------
000022EC                          1636                      INCLUDE 'SR_ID6.X68'
000022EC                          1637  
000022EC                          1638  
000022EC                          1639  SR_ID6              * This is to grab the first four that are already set, ID6
000022EC  3639 00002D3A           1640                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000022F2  183C 000C               1641                      MOVE.B  #12,D4
000022F6  E86B                    1642                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000022F8  13C3 00002D3C           1643                      MOVE.B  D3, opID        
000022FE                          1644                      
000022FE                          1645                      * Read next 4 bits into D3
000022FE  3639 00002D3A           1646                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002304  183C 0004               1647                      MOVE.B  #4, D4
00002308  E96B                    1648                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
0000230A  183C 000C               1649                      MOVE.B  #12,D4
0000230E  E86B                    1650                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
00002310  13C3 00002D3C           1651                      MOVE.B  D3, opID
00002316                          1652                      
00002316                          1653                      * Read next 8 bits into D3
00002316  3639 00002D3A           1654                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000231C  183C 0007               1655                      MOVE.B  #7, D4
00002320  E96B                    1656                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
00002322  183C 0008               1657                      MOVE.B  #8,D4
00002326  E86B                    1658                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002328  13C3 00002DA6           1659                      MOVE.B  D3, opDstMod
0000232E                          1660              
0000232E                          1661              ** Condition is stored in opID - displacement is in DstMod
0000232E                          1662              ** All thats leftis to branch per condition and output name, check reg if needed more
0000232E                          1663              ** BRA - opID=0
0000232E                          1664              ** BEQ - opID=7
0000232E                          1665              ** BGT - opID=14
0000232E                          1666              ** BLE - opID=15
0000232E  0C39 0000 00002D3C      1667              CMP.B   #0,opID
00002336  6700 002A               1668              BEQ     Fn_ID6_BRA
0000233A  0C39 0007 00002D3C      1669              CMP.B   #7,opID
00002342  6700 0028               1670              BEQ     Fn_ID6_BEQ
00002346  0C39 000E 00002D3C      1671              CMP.B   #14,opID
0000234E  6700 0026               1672              BEQ     Fn_ID6_BGT
00002352  0C39 000F 00002D3C      1673              CMP.B   #15,opID
0000235A  6700 0024               1674              BEQ     Fn_ID6_BLE
0000235E  6000 0078               1675              BRA     Fn_ID6_ERROR
00002362                          1676  
00002362  47F9 00002DFA           1677  Fn_ID6_BRA  LEA     opNam_BRA,A3
00002368  6000 001C               1678              BRA     Fn_ID6_Displacement
0000236C                          1679              
0000236C  47F9 00002DFE           1680  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
00002372  6000 0012               1681              BRA     Fn_ID6_Displacement
00002376                          1682              
00002376  47F9 00002E02           1683  Fn_ID6_BGT  LEA     opNam_BGT,A3
0000237C  6000 0008               1684              BRA     Fn_ID6_Displacement
00002380                          1685              
00002380  47F9 00002E06           1686  Fn_ID6_BLE  LEA     opNam_BLE,A3
00002386                          1687              
00002386  0C39 0000 00002DA6      1688  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
0000238E  6700 0024               1689              BEQ     Fn_ID6_Dsplcmnt16
00002392  0C39 00FF 00002DA6      1690              CMP.B   #$FF,opDstMod
0000239A  6700 002A               1691              BEQ     Fn_ID6_Dsplcmnt32
0000239E                          1692              ** 8 bit is good
0000239E  33F9 00002DA6 00002DB0  1693              MOVE.W  opDstMod,opDta2
000023A8  13FC 0000 00002DB4      1694              MOVE.B  #0,opDta2T
000023B0  6000 0028               1695              BRA     Fn_ID6_Done
000023B4                          1696              
000023B4  33DA 00002DB0           1697  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
000023BA  13FC 0001 00002DB4      1698              MOVE.B  #1,opDta2T
000023C2  6000 0016               1699              BRA     Fn_ID6_Done
000023C6                          1700  
000023C6  23DA 00002DB0           1701  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
000023CC  13FC 0002 00002DB4      1702              MOVE.B  #2,opDta2T
000023D4  6000 0004               1703              BRA     Fn_ID6_Done 
000023D8                          1704  
000023D8                          1705  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
000023D8                          1706                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000023D8  4E75                    1707                      RTS 
000023DA                          1708  
000023DA  13FC 0000 00002D3D      1709  Fn_ID6_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000023E2  4E75                    1710              RTS
000023E2  4E75                    1711  -------------------- end include --------------------
000023E4                          1712                      INCLUDE 'SR_ID7.X68'
000023E4                          1713  
000023E4                          1714  
000023E4                          1715  SR_ID7              * This is to grab the first four that are already set, ID7
000023E4  3639 00002D3A           1716                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023EA  183C 000C               1717                      MOVE.B  #12,D4
000023EE  E86B                    1718                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000023F0  13C3 00002D3C           1719                      MOVE.B  D3, opID        
000023F6                          1720                      
000023F6                          1721                      * Read next 3 bits into D3
000023F6  3639 00002D3A           1722                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023FC  183C 0004               1723                      MOVE.B  #4, D4
00002400  E96B                    1724                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002402  183C 000D               1725                      MOVE.B  #13,D4
00002406  E86B                    1726                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002408  13C3 00002DAA           1727                      MOVE.B  D3, opDta1      
0000240E                          1728              
0000240E                          1729              * Read next 1 bits into D3
0000240E  3639 00002D3A           1730                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002414  183C 0007               1731                      MOVE.B  #7, D4
00002418  E96B                    1732                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000241A  183C 000F               1733                      MOVE.B  #15,D4
0000241E  E86B                    1734                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002420  13C3 00002DA6           1735                      MOVE.B  D3, opDstMod    
00002426  0C39 0000 00002DA6      1736              CMP.B   #0,opDstMod
0000242E  6600 0038               1737              BNE     Fn_ID7_Error
00002432                          1738              
00002432                          1739              * Read next 8 bits into D3
00002432  3639 00002D3A           1740                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002438  183C 0008               1741                      MOVE.B  #8, D4
0000243C  E96B                    1742                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000243E  183C 0008               1743                      MOVE.B  #8,D4
00002442  E86B                    1744                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002444  13C3 00002DB0           1745                      MOVE.B  D3, opDta2
0000244A                          1746  
0000244A  47F9 00002E0A           1747              LEA     opNam_MOVEQ,A3
00002450                          1748              * Set appropriate data
00002450  13FC 0001 00002DB4      1749              MOVE.B  #1, opDta2T
00002458  13FC 0007 00002DA8      1750              MOVE.B  #7, opSrcMod
00002460  13FC 0000 00002DA7      1751              MOVE.B  #0, opSrcReg
00002468                          1752  
00002468                          1753  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
00002468                          1754                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002468  4E75                    1755                      RTS                                  * Return to main
0000246A                          1756              
0000246A  13FC 0000 00002D3D      1757  Fn_ID7_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002472  4E75                    1758              RTS
00002472  4E75                    1759  -------------------- end include --------------------
00002474                          1760                      INCLUDE 'SR_ID8.X68'
00002474                          1761  
00002474                          1762  
00002474                          1763  SR_ID8              * This is to grab the first four that are already set, ID4
00002474  3639 00002D3A           1764                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000247A  183C 000C               1765                      MOVE.B  #12,D4
0000247E  E86B                    1766                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002480  13C3 00002D3C           1767                      MOVE.B  D3, opID        
00002486                          1768                      
00002486                          1769                      * Read next 3 bits into D3
00002486  3639 00002D3A           1770                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000248C  183C 0004               1771                      MOVE.B  #4, D4
00002490  E96B                    1772                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002492  183C 000D               1773                      MOVE.B  #13,D4
00002496  E86B                    1774                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002498  13C3 00002DA5           1775                      MOVE.B  D3, opDstReg
0000249E                          1776                      
0000249E                          1777                      * Read next 3 bits into D3
0000249E  3639 00002D3A           1778                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024A4  183C 0007               1779                      MOVE.B  #7, D4
000024A8  E96B                    1780                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000024AA  183C 000D               1781                      MOVE.B  #13,D4
000024AE  E86B                    1782                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024B0  13C3 00002DA6           1783                      MOVE.B  D3, opDstMod
000024B6                          1784  
000024B6                          1785                      ** Read next 3 bits
000024B6                          1786                      **
000024B6  3639 00002D3A           1787                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024BC  183C 000A               1788                      MOVE.B  #10, D4
000024C0  E96B                    1789                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000024C2  183C 000D               1790                      MOVE.B  #13,D4
000024C6  E86B                    1791                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024C8  13C3 00002DA8           1792                      MOVE.B  D3, opSrcMod
000024CE                          1793  
000024CE                          1794                      ** Read next 3 bits
000024CE                          1795                      **
000024CE  3639 00002D3A           1796                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024D4  183C 000D               1797                      MOVE.B  #13, D4
000024D8  E96B                    1798                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000024DA  183C 000D               1799                      MOVE.B  #13,D4
000024DE  E86B                    1800                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024E0  13C3 00002DA7           1801                      MOVE.B  D3, opSrcReg
000024E6                          1802              
000024E6                          1803              ** Find out if its Dn, ea or ea, Dn
000024E6                          1804              ** ea, Dn - 0,1,2
000024E6                          1805              ** Dn, ea - 4,5,6
000024E6  47F9 00002E10           1806              LEA     opNam_OR,A3
000024EC  0C39 0003 00002DA6      1807              CMP.B   #3,opDstMod
000024F4  6D00 0012               1808              BLT     Fn_ID8_Case1
000024F8  0C39 0007 00002DA6      1809              CMP.B   #7,opDstMod
00002500  6D00 0048               1810              BLT     Fn_ID8_Case2
00002504  6000 0178               1811              BRA     Fn_ID8_Error
00002508                          1812  
00002508  13F9 00002DA6 00002D3C  1813  Fn_ID8_Case1MOVE.B  opDstMod,opID
00002512  13F9 00002DA8 00002DA6  1814              MOVE.B  opSrcMod,opDstMod
0000251C  1C39 00002DA5           1815              MOVE.B  opDstReg,D6
00002522  13F9 00002DA7 00002DA5  1816              MOVE.B  opSrcReg,opDstReg
0000252C  13C6 00002DA7           1817              MOVE.B  D6,opSrcReg
00002532  13FC 0000 00002DA8      1818              MOVE.B  #0,opSrcMod
0000253A                          1819              ** Immediate data?
0000253A  0C39 0007 00002DA6      1820              CMP.B   #7, opDstMod
00002542  6700 002E               1821                      BEQ     Fn_ID8_DataDst
00002546  6000 0138               1822                      BRA     Fn_ID8_Done
0000254A                          1823  
0000254A  13F9 00002DA6 00002D3C  1824  Fn_ID8_Case2MOVE.B  opDstMod,opID
00002554  5939 00002D3C           1825              SUB.B   #4,opID
0000255A  13FC 0000 00002DA6      1826              MOVE.B  #0,opDstMod
00002562                          1827              ** Immediate data?
00002562  0C39 0007 00002DA8      1828              CMP.B   #7, opSrcMod
0000256A  6700 008C               1829                      BEQ     Fn_ID8_DataSrc
0000256E  6000 0110               1830                      BRA     Fn_ID8_Done
00002572                          1831              
00002572  0C39 0000 00002DA5      1832  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
0000257A  6700 0058               1833                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
0000257E  0C39 0001 00002DA5      1834                      CMP.B   #1, opDstReg                * Check if source register is 1
00002586  6700 005E               1835                      BEQ     Fn_ID8_DtaDstLng            * Load next long
0000258A  0C39 0004 00002DA5      1836                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002592  6700 0006               1837                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
00002596  6000 00E6               1838                      BRA     FN_ID8_Error                * Invalid register value
0000259A                          1839                      
0000259A  0C39 0001 00002D3C      1840  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000025A2  6700 001E               1841                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
000025A6  0C39 0003 00002D3C      1842                      CMP.B   #3, opID                    * opID = 3 - size is word
000025AE  6700 0024               1843                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000025B2  0C39 0002 00002D3C      1844                      CMP.B   #2, opID                    * opID = 0 - size is long
000025BA  6700 002A               1845                      BEQ     Fn_ID8_DtaDstLng            * Load next
000025BE  6000 00BE               1846                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000025C2                          1847  
000025C2  33DA 00002DAA           1848  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000025C8  13FC 0000 00002DAE      1849                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000025D0  6000 00AE               1850                      BRA     Fn_ID8_Done
000025D4  33DA 00002DAA           1851  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000025DA  13FC 0001 00002DAE      1852                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000025E2  6000 009C               1853                      BRA     Fn_ID8_Done
000025E6  23DA 00002DAA           1854  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000025EC  13FC 0002 00002DAE      1855                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
000025F4  6000 008A               1856                      BRA     Fn_ID8_Done
000025F8                          1857              
000025F8  0C39 0000 00002DA7      1858  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002600  6700 0058               1859                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002604  0C39 0001 00002DA7      1860                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000260C  6700 005E               1861                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
00002610  0C39 0004 00002DA7      1862                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002618  6700 0006               1863                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
0000261C  6000 0060               1864                      BRA     FN_ID8_Error                * Invalid register value
00002620                          1865                      
00002620  0C39 0001 00002D3C      1866  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002628  6700 001E               1867                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
0000262C  0C39 0003 00002D3C      1868                      CMP.B   #3, opID                    * opID = 3 - size is word
00002634  6700 0024               1869                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002638  0C39 0002 00002D3C      1870                      CMP.B   #2, opID                    * opID = 0 - size is long
00002640  6700 002A               1871                      BEQ     Fn_ID8_DtaSrcLng            * Load next
00002644  6000 0038               1872                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
00002648                          1873  
00002648  33DA 00002DB0           1874  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000264E  13FC 0000 00002DB4      1875                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002656  6000 0028               1876                      BRA     Fn_ID8_Done
0000265A  33DA 00002DB0           1877  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002660  13FC 0001 00002DB4      1878                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002668  6000 0016               1879                      BRA     Fn_ID8_Done
0000266C  23DA 00002DB0           1880  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002672  13FC 0002 00002DB4      1881                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
0000267A  6000 0004               1882                      BRA     Fn_ID8_Done
0000267E                          1883  
0000267E                          1884  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
0000267E                          1885                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000267E  4E75                    1886                      RTS   
00002680                          1887              
00002680  13FC 0000 00002D3D      1888  Fn_ID8_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002688  4E75                    1889              RTS
00002688  4E75                    1890  -------------------- end include --------------------
0000268A                          1891                      INCLUDE 'SR_ID9.X68'
0000268A                          1892  
0000268A                          1893  
0000268A                          1894  SR_ID9      * This is to grab the first four that are already set, ID4
0000268A  3639 00002D3A           1895                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002690  183C 000C               1896                      MOVE.B  #12,D4
00002694  E86B                    1897                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002696  13C3 00002D3C           1898                      MOVE.B  D3, opID        
0000269C                          1899                      
0000269C                          1900                      * Read next 3 bits into D3
0000269C  3639 00002D3A           1901                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026A2  183C 0004               1902                      MOVE.B  #4, D4
000026A6  E96B                    1903                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000026A8  183C 000D               1904                      MOVE.B  #13,D4
000026AC  E86B                    1905                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026AE  13C3 00002DA5           1906                      MOVE.B  D3, opDstReg
000026B4                          1907                      
000026B4                          1908                      * Read next 3 bits into D3
000026B4  3639 00002D3A           1909                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026BA  183C 0007               1910                      MOVE.B  #7, D4
000026BE  E96B                    1911                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000026C0  183C 000D               1912                      MOVE.B  #13,D4
000026C4  E86B                    1913                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026C6  13C3 00002DA6           1914                      MOVE.B  D3, opDstMod
000026CC                          1915  
000026CC                          1916                      ** Read next 3 bits
000026CC                          1917                      **
000026CC  3639 00002D3A           1918                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026D2  183C 000A               1919                      MOVE.B  #10, D4
000026D6  E96B                    1920                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000026D8  183C 000D               1921                      MOVE.B  #13,D4
000026DC  E86B                    1922                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026DE  13C3 00002DA8           1923                      MOVE.B  D3, opSrcMod
000026E4                          1924  
000026E4                          1925                      ** Read next 3 bits
000026E4                          1926                      **
000026E4  3639 00002D3A           1927                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026EA  183C 000D               1928                      MOVE.B  #13, D4
000026EE  E96B                    1929                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000026F0  183C 000D               1930                      MOVE.B  #13,D4
000026F4  E86B                    1931                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026F6  13C3 00002DA7           1932                      MOVE.B  D3, opSrcReg
000026FC                          1933              
000026FC                          1934              ** Find out if its Dn, ea or ea, Dn
000026FC                          1935              ** ea, Dn - 0,1,2
000026FC                          1936              ** Dn, ea - 4,5,6
000026FC  47F9 00002E13           1937              LEA     opNam_SUB,A3
00002702  0C39 0003 00002DA6      1938              CMP.B   #3,opDstMod
0000270A  6D00 0012               1939              BLT     Fn_ID9_Case1
0000270E  0C39 0007 00002DA6      1940              CMP.B   #7,opDstMod
00002716  6D00 0048               1941              BLT     Fn_ID9_Case2
0000271A  6000 0178               1942              BRA     Fn_ID9_Error
0000271E                          1943  
0000271E  13F9 00002DA6 00002D3C  1944  Fn_ID9_Case1MOVE.B  opDstMod,opID
00002728  13F9 00002DA8 00002DA6  1945              MOVE.B  opSrcMod,opDstMod
00002732  1C39 00002DA5           1946              MOVE.B  opDstReg,D6
00002738  13F9 00002DA7 00002DA5  1947              MOVE.B  opSrcReg,opDstReg
00002742  13C6 00002DA7           1948              MOVE.B  D6,opSrcReg
00002748  13FC 0000 00002DA8      1949              MOVE.B  #0,opSrcMod
00002750                          1950              ** Immediate data?
00002750  0C39 0007 00002DA6      1951              CMP.B   #7, opDstMod
00002758  6700 002E               1952                      BEQ     Fn_ID9_DataDst
0000275C  6000 0138               1953                      BRA     Fn_ID9_Done
00002760                          1954  
00002760  13F9 00002DA6 00002D3C  1955  Fn_ID9_Case2MOVE.B  opDstMod,opID
0000276A  5939 00002D3C           1956              SUB.B   #4,opID
00002770  13FC 0000 00002DA6      1957              MOVE.B  #0,opDstMod
00002778                          1958              ** Immediate data?
00002778  0C39 0007 00002DA8      1959              CMP.B   #7, opSrcMod
00002780  6700 008C               1960                      BEQ     Fn_ID9_DataSrc
00002784  6000 0110               1961                      BRA     Fn_ID9_Done
00002788                          1962              
00002788  0C39 0000 00002DA5      1963  Fn_ID9_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002790  6700 0058               1964                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
00002794  0C39 0001 00002DA5      1965                      CMP.B   #1, opDstReg                * Check if source register is 1
0000279C  6700 005E               1966                      BEQ     Fn_ID9_DtaDstLng            * Load next long
000027A0  0C39 0004 00002DA5      1967                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000027A8  6700 0006               1968                      BEQ     Fn_ID9_DtaDstImd            * Load first word into word one
000027AC  6000 00E6               1969                      BRA     FN_ID9_Error                * Invalid register value
000027B0                          1970                      
000027B0  0C39 0001 00002D3C      1971  Fn_ID9_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000027B8  6700 001E               1972                      BEQ     Fn_ID9_DtaDstByt            * Load next byte
000027BC  0C39 0003 00002D3C      1973                      CMP.B   #3, opID                    * opID = 3 - size is word
000027C4  6700 0024               1974                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000027C8  0C39 0002 00002D3C      1975                      CMP.B   #2, opID                    * opID = 0 - size is long
000027D0  6700 002A               1976                      BEQ     Fn_ID9_DtaDstLng            * Load next
000027D4  6000 00BE               1977                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
000027D8                          1978  
000027D8  33DA 00002DAA           1979  Fn_ID9_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000027DE  13FC 0000 00002DAE      1980                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000027E6  6000 00AE               1981                      BRA     Fn_ID9_Done
000027EA  33DA 00002DAA           1982  Fn_ID9_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000027F0  13FC 0001 00002DAE      1983                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000027F8  6000 009C               1984                      BRA     Fn_ID9_Done
000027FC  23DA 00002DAA           1985  Fn_ID9_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002802  13FC 0002 00002DAE      1986                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000280A  6000 008A               1987                      BRA     Fn_ID9_Done
0000280E                          1988              
0000280E  0C39 0000 00002DA7      1989  Fn_ID9_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002816  6700 0058               1990                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000281A  0C39 0001 00002DA7      1991                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002822  6700 005E               1992                      BEQ     Fn_ID9_DtaSrcLng            * Load next long
00002826  0C39 0004 00002DA7      1993                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
0000282E  6700 0006               1994                      BEQ     Fn_ID9_DtaSrcImd            * Load first word into word one
00002832  6000 0060               1995                      BRA     FN_ID9_Error                * Invalid register value
00002836                          1996                      
00002836  0C39 0001 00002D3C      1997  Fn_ID9_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000283E  6700 001E               1998                      BEQ     Fn_ID9_DtaSrcByt            * Load next byte
00002842  0C39 0003 00002D3C      1999                      CMP.B   #3, opID                    * opID = 3 - size is word
0000284A  6700 0024               2000                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000284E  0C39 0002 00002D3C      2001                      CMP.B   #2, opID                    * opID = 0 - size is long
00002856  6700 002A               2002                      BEQ     Fn_ID9_DtaSrcLng            * Load next
0000285A  6000 0038               2003                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
0000285E                          2004  
0000285E  33DA 00002DB0           2005  Fn_ID9_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002864  13FC 0000 00002DB4      2006                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
0000286C  6000 0028               2007                      BRA     Fn_ID9_Done
00002870  33DA 00002DB0           2008  Fn_ID9_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002876  13FC 0001 00002DB4      2009                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
0000287E  6000 0016               2010                      BRA     Fn_ID9_Done
00002882  23DA 00002DB0           2011  Fn_ID9_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002888  13FC 0002 00002DB4      2012                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002890  6000 0004               2013                      BRA     Fn_ID9_Done
00002894                          2014  
00002894                          2015  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
00002894                          2016                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002894  4E75                    2017                      RTS   
00002896                          2018  
00002896  13FC 0000 00002D3D      2019  Fn_ID9_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
0000289E  4E75                    2020              RTS
0000289E  4E75                    2021  -------------------- end include --------------------
000028A0                          2022                      INCLUDE 'SR_IDA.X68'
000028A0                          2023  
000028A0                          2024  
000028A0                          2025  SR_IDA
000028A0                          2026  
000028A0                          2027  
000028A0  4E75                    2028  Fn_IDA_Done        RTS
000028A0  4E75                    2029  -------------------- end include --------------------
000028A2                          2030                      INCLUDE 'SR_IDB.X68'
000028A2                          2031  
000028A2                          2032  
000028A2                          2033  SR_IDB
000028A2                          2034  
000028A2                          2035  
000028A2  4E75                    2036  Fn_IDB_Done        RTS
000028A2  4E75                    2037  -------------------- end include --------------------
000028A4                          2038                      INCLUDE 'SR_IDC.X68'
000028A4                          2039  
000028A4                          2040  
000028A4                          2041  SR_IDC      * This is to grab the first four that are already set, ID4
000028A4  3639 00002D3A           2042                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028AA  183C 000C               2043                      MOVE.B  #12,D4
000028AE  E86B                    2044                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000028B0  13C3 00002D3C           2045                      MOVE.B  D3, opID        
000028B6                          2046                      
000028B6                          2047                      * Read next 3 bits into D3
000028B6  3639 00002D3A           2048                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028BC  183C 0004               2049                      MOVE.B  #4, D4
000028C0  E96B                    2050                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000028C2  183C 000D               2051                      MOVE.B  #13,D4
000028C6  E86B                    2052                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000028C8  13C3 00002DA5           2053                      MOVE.B  D3, opDstReg
000028CE                          2054                      
000028CE                          2055                      * Read next 3 bits into D3
000028CE  3639 00002D3A           2056                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028D4  183C 0007               2057                      MOVE.B  #7, D4
000028D8  E96B                    2058                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000028DA  183C 000D               2059                      MOVE.B  #13,D4
000028DE  E86B                    2060                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000028E0  13C3 00002DA6           2061                      MOVE.B  D3, opDstMod
000028E6                          2062  
000028E6                          2063                      ** Read next 3 bits
000028E6                          2064                      **
000028E6  3639 00002D3A           2065                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028EC  183C 000A               2066                      MOVE.B  #10, D4
000028F0  E96B                    2067                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000028F2  183C 000D               2068                      MOVE.B  #13,D4
000028F6  E86B                    2069                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000028F8  13C3 00002DA8           2070                      MOVE.B  D3, opSrcMod
000028FE                          2071  
000028FE                          2072                      ** Read next 3 bits
000028FE                          2073                      **
000028FE  3639 00002D3A           2074                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002904  183C 000D               2075                      MOVE.B  #13, D4
00002908  E96B                    2076                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000290A  183C 000D               2077                      MOVE.B  #13,D4
0000290E  E86B                    2078                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002910  13C3 00002DA7           2079                      MOVE.B  D3, opSrcReg
00002916                          2080              
00002916                          2081              ** Find out if its Dn, ea or ea, Dn
00002916                          2082              ** ea, Dn - 0,1,2
00002916                          2083              ** Dn, ea - 4,5,6
00002916  47F9 00002E17           2084              LEA     opNam_AND,A3
0000291C  0C39 0003 00002DA6      2085              CMP.B   #3,opDstMod
00002924  6D00 0012               2086              BLT     Fn_IDC_Case1
00002928  0C39 0007 00002DA6      2087              CMP.B   #7,opDstMod
00002930  6D00 0048               2088              BLT     Fn_IDC_Case2
00002934  6000 0178               2089              BRA     Fn_IDC_Error
00002938                          2090  
00002938  13F9 00002DA6 00002D3C  2091  Fn_IDC_Case1MOVE.B  opDstMod,opID
00002942  13F9 00002DA8 00002DA6  2092              MOVE.B  opSrcMod,opDstMod
0000294C  1C39 00002DA5           2093              MOVE.B  opDstReg,D6
00002952  13F9 00002DA7 00002DA5  2094              MOVE.B  opSrcReg,opDstReg
0000295C  13C6 00002DA7           2095              MOVE.B  D6,opSrcReg
00002962  13FC 0000 00002DA8      2096              MOVE.B  #0,opSrcMod
0000296A                          2097              ** Immediate data?
0000296A  0C39 0007 00002DA6      2098              CMP.B   #7, opDstMod
00002972  6700 002E               2099                      BEQ     Fn_IDC_DataDst
00002976  6000 0138               2100                      BRA     Fn_IDC_Done
0000297A                          2101  
0000297A  13F9 00002DA6 00002D3C  2102  Fn_IDC_Case2MOVE.B  opDstMod,opID
00002984  5939 00002D3C           2103              SUB.B   #4,opID
0000298A  13FC 0000 00002DA6      2104              MOVE.B  #0,opDstMod
00002992                          2105              ** Immediate data?
00002992  0C39 0007 00002DA8      2106              CMP.B   #7, opSrcMod
0000299A  6700 008C               2107                      BEQ     Fn_IDC_DataSrc
0000299E  6000 0110               2108                      BRA     Fn_IDC_Done
000029A2                          2109              
000029A2  0C39 0000 00002DA5      2110  Fn_IDC_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000029AA  6700 0058               2111                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000029AE  0C39 0001 00002DA5      2112                      CMP.B   #1, opDstReg                * Check if source register is 1
000029B6  6700 005E               2113                      BEQ     Fn_IDC_DtaDstLng            * Load next long
000029BA  0C39 0004 00002DA5      2114                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000029C2  6700 0006               2115                      BEQ     Fn_IDC_DtaDstImd            * Load first word into word one
000029C6  6000 00E6               2116                      BRA     FN_IDC_Error                * Invalid register value
000029CA                          2117                      
000029CA  0C39 0001 00002D3C      2118  Fn_IDC_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000029D2  6700 001E               2119                      BEQ     Fn_IDC_DtaDstByt            * Load next byte
000029D6  0C39 0003 00002D3C      2120                      CMP.B   #3, opID                    * opID = 3 - size is word
000029DE  6700 0024               2121                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000029E2  0C39 0002 00002D3C      2122                      CMP.B   #2, opID                    * opID = 0 - size is long
000029EA  6700 002A               2123                      BEQ     Fn_IDC_DtaDstLng            * Load next
000029EE  6000 00BE               2124                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
000029F2                          2125  
000029F2  33DA 00002DAA           2126  Fn_IDC_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000029F8  13FC 0000 00002DAE      2127                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002A00  6000 00AE               2128                      BRA     Fn_IDC_Done
00002A04  33DA 00002DAA           2129  Fn_IDC_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002A0A  13FC 0001 00002DAE      2130                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002A12  6000 009C               2131                      BRA     Fn_IDC_Done
00002A16  23DA 00002DAA           2132  Fn_IDC_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002A1C  13FC 0002 00002DAE      2133                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002A24  6000 008A               2134                      BRA     Fn_IDC_Done
00002A28                          2135              
00002A28  0C39 0000 00002DA7      2136  Fn_IDC_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002A30  6700 0058               2137                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002A34  0C39 0001 00002DA7      2138                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002A3C  6700 005E               2139                      BEQ     Fn_IDC_DtaSrcLng            * Load next long
00002A40  0C39 0004 00002DA7      2140                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002A48  6700 0006               2141                      BEQ     Fn_IDC_DtaSrcImd            * Load first word into word one
00002A4C  6000 0060               2142                      BRA     FN_IDC_Error                * Invalid register value
00002A50                          2143                      
00002A50  0C39 0001 00002D3C      2144  Fn_IDC_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002A58  6700 001E               2145                      BEQ     Fn_IDC_DtaSrcByt            * Load next byte
00002A5C  0C39 0003 00002D3C      2146                      CMP.B   #3, opID                    * opID = 3 - size is word
00002A64  6700 0024               2147                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002A68  0C39 0002 00002D3C      2148                      CMP.B   #2, opID                    * opID = 0 - size is long
00002A70  6700 002A               2149                      BEQ     Fn_IDC_DtaSrcLng            * Load next
00002A74  6000 0038               2150                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002A78                          2151  
00002A78  33DA 00002DB0           2152  Fn_IDC_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002A7E  13FC 0000 00002DB4      2153                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002A86  6000 0028               2154                      BRA     Fn_IDC_Done
00002A8A  33DA 00002DB0           2155  Fn_IDC_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002A90  13FC 0001 00002DB4      2156                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002A98  6000 0016               2157                      BRA     Fn_IDC_Done
00002A9C  23DA 00002DB0           2158  Fn_IDC_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002AA2  13FC 0002 00002DB4      2159                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002AAA  6000 0004               2160                      BRA     Fn_IDC_Done
00002AAE                          2161  
00002AAE                          2162  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
00002AAE                          2163                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002AAE  4E75                    2164                      RTS   
00002AB0                          2165  
00002AB0  13FC 0000 00002D3D      2166  Fn_IDC_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002AB8  4E75                    2167              RTS
00002AB8  4E75                    2168  -------------------- end include --------------------
00002ABA                          2169                      INCLUDE 'SR_IDD.X68'
00002ABA                          2170  
00002ABA                          2171  
00002ABA                          2172  SR_IDD      * This is to grab the first four that are already set, ID4
00002ABA  3639 00002D3A           2173                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AC0  183C 000C               2174                      MOVE.B  #12,D4
00002AC4  E86B                    2175                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002AC6  13C3 00002D3C           2176                      MOVE.B  D3, opID        
00002ACC                          2177                      
00002ACC                          2178                      * Read next 3 bits into D3
00002ACC  3639 00002D3A           2179                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AD2  183C 0004               2180                      MOVE.B  #4, D4
00002AD6  E96B                    2181                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002AD8  183C 000D               2182                      MOVE.B  #13,D4
00002ADC  E86B                    2183                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002ADE  13C3 00002DA5           2184                      MOVE.B  D3, opDstReg
00002AE4                          2185                      
00002AE4                          2186                      * Read next 3 bits into D3
00002AE4  3639 00002D3A           2187                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AEA  183C 0007               2188                      MOVE.B  #7, D4
00002AEE  E96B                    2189                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002AF0  183C 000D               2190                      MOVE.B  #13,D4
00002AF4  E86B                    2191                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002AF6  13C3 00002DA6           2192                      MOVE.B  D3, opDstMod
00002AFC                          2193  
00002AFC                          2194                      ** Read next 3 bits
00002AFC                          2195                      **
00002AFC  3639 00002D3A           2196                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002B02  183C 000A               2197                      MOVE.B  #10, D4
00002B06  E96B                    2198                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002B08  183C 000D               2199                      MOVE.B  #13,D4
00002B0C  E86B                    2200                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002B0E  13C3 00002DA8           2201                      MOVE.B  D3, opSrcMod
00002B14                          2202  
00002B14                          2203                      ** Read next 3 bits
00002B14                          2204                      **
00002B14  3639 00002D3A           2205                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002B1A  183C 000D               2206                      MOVE.B  #13, D4
00002B1E  E96B                    2207                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002B20  183C 000D               2208                      MOVE.B  #13,D4
00002B24  E86B                    2209                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002B26  13C3 00002DA7           2210                      MOVE.B  D3, opSrcReg
00002B2C                          2211              
00002B2C                          2212              ** Find out if its Dn, ea or ea, Dn
00002B2C                          2213              ** ea, Dn - 0,1,2
00002B2C                          2214              ** Dn, ea - 4,5,6
00002B2C  0C39 0003 00002DA6      2215              CMP.B   #3,opDstMod
00002B34  6D00 002A               2216              BLT     Fn_IDD_Case1
00002B38  0C39 0003 00002DA6      2217              CMP.B   #3,opDstMod
00002B40  6700 0094               2218              BEQ     Fn_IDD_Case3
00002B44  0C39 0007 00002DA6      2219              CMP.B   #7,opDstMod
00002B4C  6D00 005A               2220              BLT     Fn_IDD_Case2
00002B50  0C39 0007 00002DA6      2221              CMP.B   #7,opDstMod
00002B58  6700 007C               2222              BEQ     Fn_IDD_Case3
00002B5C  6000 01B2               2223              BRA     Fn_IDD_Error
00002B60                          2224  
00002B60  47F9 00002E1B           2225  Fn_IDD_Case1LEA     opNam_ADD,A3
00002B66  13F9 00002DA6 00002D3C  2226              MOVE.B  opDstMod,opID
00002B70  13F9 00002DA8 00002DA6  2227              MOVE.B  opSrcMod,opDstMod
00002B7A  1C39 00002DA5           2228              MOVE.B  opDstReg,D6
00002B80  13F9 00002DA7 00002DA5  2229              MOVE.B  opSrcReg,opDstReg
00002B8A  13C6 00002DA7           2230              MOVE.B  D6,opSrcReg
00002B90  13FC 0000 00002DA8      2231              MOVE.B  #0,opSrcMod
00002B98                          2232              ** Immediate data?
00002B98  0C39 0007 00002DA6      2233              CMP.B   #7, opDstMod
00002BA0  6700 0062               2234                      BEQ     Fn_IDD_DataDst
00002BA4  6000 016C               2235                      BRA     Fn_IDD_Done
00002BA8                          2236  
00002BA8  47F9 00002E1B           2237  Fn_IDD_Case2LEA     opNam_ADD,A3
00002BAE  13F9 00002DA6 00002D3C  2238              MOVE.B  opDstMod,opID
00002BB8  5939 00002D3C           2239              SUB.B   #4,opID
00002BBE  13FC 0000 00002DA6      2240              MOVE.B  #0,opDstMod
00002BC6                          2241              ** Immediate data?
00002BC6  0C39 0007 00002DA8      2242              CMP.B   #7, opSrcMod
00002BCE  6700 00BA               2243                      BEQ     Fn_IDD_DataSrc
00002BD2  6000 013E               2244                      BRA     Fn_IDD_Done
00002BD6                          2245              
00002BD6  47F9 00002E1F           2246  Fn_IDD_Case3LEA     opNam_ADDA,A3
00002BDC  13F9 00002DA6 00002D3C  2247              MOVE.B  opDstMod,opID
00002BE6  5939 00002D3C           2248              SUB.B   #4,opID
00002BEC  13FC 0000 00002DA6      2249              MOVE.B  #0,opDstMod
00002BF4                          2250              ** Immediate data?
00002BF4  0C39 0007 00002DA8      2251              CMP.B   #7, opSrcMod
00002BFC  6700 008C               2252                      BEQ     Fn_IDD_DataSrc
00002C00  6000 0110               2253                      BRA     Fn_IDD_Done
00002C04                          2254              
00002C04  0C39 0000 00002DA5      2255  Fn_IDD_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002C0C  6700 0058               2256                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002C10  0C39 0001 00002DA5      2257                      CMP.B   #1, opDstReg                * Check if source register is 1
00002C18  6700 005E               2258                      BEQ     Fn_IDD_DtaDstLng            * Load next long
00002C1C  0C39 0004 00002DA5      2259                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002C24  6700 0006               2260                      BEQ     Fn_IDD_DtaDstImd            * Load first word into word one
00002C28  6000 00E6               2261                      BRA     FN_IDD_Error                * Invalid register value
00002C2C                          2262                      
00002C2C  0C39 0001 00002D3C      2263  Fn_IDD_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002C34  6700 001E               2264                      BEQ     Fn_IDD_DtaDstByt            * Load next byte
00002C38  0C39 0003 00002D3C      2265                      CMP.B   #3, opID                    * opID = 3 - size is word
00002C40  6700 0024               2266                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002C44  0C39 0002 00002D3C      2267                      CMP.B   #2, opID                    * opID = 0 - size is long
00002C4C  6700 002A               2268                      BEQ     Fn_IDD_DtaDstLng            * Load next
00002C50  6000 00BE               2269                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002C54                          2270  
00002C54  33DA 00002DAA           2271  Fn_IDD_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002C5A  13FC 0000 00002DAE      2272                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002C62  6000 00AE               2273                      BRA     Fn_IDD_Done
00002C66  33DA 00002DAA           2274  Fn_IDD_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002C6C  13FC 0001 00002DAE      2275                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002C74  6000 009C               2276                      BRA     Fn_IDD_Done
00002C78  23DA 00002DAA           2277  Fn_IDD_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002C7E  13FC 0002 00002DAE      2278                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002C86  6000 008A               2279                      BRA     Fn_IDD_Done
00002C8A                          2280              
00002C8A  0C39 0000 00002DA7      2281  Fn_IDD_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002C92  6700 0058               2282                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002C96  0C39 0001 00002DA7      2283                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002C9E  6700 005E               2284                      BEQ     Fn_IDD_DtaSrcLng            * Load next long
00002CA2  0C39 0004 00002DA7      2285                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002CAA  6700 0006               2286                      BEQ     Fn_IDD_DtaSrcImd            * Load first word into word one
00002CAE  6000 0060               2287                      BRA     FN_IDD_Error                * Invalid register value
00002CB2                          2288                      
00002CB2  0C39 0001 00002D3C      2289  Fn_IDD_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002CBA  6700 001E               2290                      BEQ     Fn_IDD_DtaSrcByt            * Load next byte
00002CBE  0C39 0003 00002D3C      2291                      CMP.B   #3, opID                    * opID = 3 - size is word
00002CC6  6700 0024               2292                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002CCA  0C39 0002 00002D3C      2293                      CMP.B   #2, opID                    * opID = 0 - size is long
00002CD2  6700 002A               2294                      BEQ     Fn_IDD_DtaSrcLng            * Load next
00002CD6  6000 0038               2295                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002CDA                          2296  
00002CDA  33DA 00002DB0           2297  Fn_IDD_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002CE0  13FC 0000 00002DB4      2298                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002CE8  6000 0028               2299                      BRA     Fn_IDD_Done
00002CEC  33DA 00002DB0           2300  Fn_IDD_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002CF2  13FC 0001 00002DB4      2301                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002CFA  6000 0016               2302                      BRA     Fn_IDD_Done
00002CFE  23DA 00002DB0           2303  Fn_IDD_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002D04  13FC 0002 00002DB4      2304                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002D0C  6000 0004               2305                      BRA     Fn_IDD_Done
00002D10                          2306  
00002D10                          2307  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
00002D10                          2308                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002D10  4E75                    2309                      RTS   
00002D12                          2310  
00002D12  13FC 0000 00002D3D      2311  Fn_IDD_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002D1A  4E75                    2312              RTS
00002D1A  4E75                    2313  -------------------- end include --------------------
00002D1C                          2314                      INCLUDE 'SR_IDE.X68'
00002D1C                          2315  
00002D1C                          2316  SR_IDE
00002D1C                          2317  
00002D1C  4E75                    2318                RTS
00002D1C  4E75                    2319  -------------------- end include --------------------
00002D1E                          2320  
00002D1E                          2321  ** -----------------------------------------------------------
00002D1E                          2322  ** Variables and constants
00002D1E                          2323  ** -----------------------------------------------------------
00002D1E                          2324  
00002D1E  =0000001A               2325  maxLines            EQU      26                      * Max lines to display
00002D1E                          2326  
00002D1E= 00000000                2327  adrValStart         DC.L     $00000000               * Value of starting address - set by user
00002D22= 38 39 41 42 43 44 ...   2328  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
00002D2B= FF                      2329  adrStsStart         DC.B     $FF                     * Status of starting address
00002D2C                          2330                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002D2C= 00000000                2331  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
00002D30= 38 39 41 42 43 44 ...   2332  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
00002D39= FF                      2333  adrStsEnd           DC.B     $FF                     * Status of ending address
00002D3A                          2334                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002D3A                          2335  
00002D3A= 0000                    2336  opWord              DC.W     $0000                   * 16 bit instruction Word
00002D3C= 00                      2337  opID                DC.B     $00                     * First 4 bit value ID
00002D3D= 01                      2338  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
00002D3E                          2339  
00002D3E= 00000000                2340  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
00002D42= 38 39 41 42 43 44 ...   2341  opStrAdr            DC.B     '89ABCDEF',0            * String address
00002D4C= 00000000                2342  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
00002D50                          2343  
00002D50= 50 6C 61 63 65 68 ...   2344  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
00002DA0= 00000000                2345  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002DA4                          2346  
00002DA4= FF                      2347  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002DA5                          2348  
00002DA5= FF                      2349  opDstReg            DC.B     $FF                     * Destination Register Value
00002DA6= FF                      2350  opDstMod            DC.B     $FF                     * Destination Mode Value
00002DA7= FF                      2351  opSrcReg            DC.B     $FF                     * Source Register Value
00002DA8= FF                      2352  opSrcMod            DC.B     $FF                     * Source Register Mode
00002DA9                          2353  
00002DAA= 00000000                2354  opDta1              DC.L     $00000000               * Data value one (most likely source)
00002DAE= FF                      2355  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
00002DB0= 00000000                2356  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002DB4= FF                      2357  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002DB5= 30 30 30 30 00          2358  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002DBA= 30 30 30 30 30 30 ...   2359  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002DC3                          2360  
00002DC4= 00000000                2361  opMask              DC.L     $00000000               * Mask for MOVEM
00002DC8= 00                      2362  opRotate            DC.B     $00                     * Rotation for IDE(14)
00002DC9= 00                      2363  opSizDir            DC.B     $00                     * Size/Direction for IDE(14)
00002DCA= 00                      2364  opIR                DC.B     $00                     * Immediate/Rotate for IDE(14)
00002DCB                          2365  
00002DCB= 44 41 54 41 00          2366  opNam_DATA          DC.B     'DATA',0
00002DD0= 4D 4F 56 45 00          2367  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
00002DD5= 4D 4F 56 45 41 00       2368  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002DDB= 4C 45 41 00             2369  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002DDF= 4E 4F 54 00             2370  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002DE3= 4D 4F 56 45 4D 00       2371  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
00002DE9= 4E 4F 50 00             2372  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002DED= 52 54 53 00             2373  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002DF1= 4A 53 52 00             2374  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
00002DF5= 41 44 44 51 00          2375  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002DFA= 42 52 41 00             2376  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002DFE= 42 45 51 00             2377  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002E02= 42 47 54 00             2378  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
00002E06= 42 4C 45 00             2379  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
00002E0A= 4D 4F 56 45 51 00       2380  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
00002E10= 4F 52 00                2381  opNam_OR            DC.B     'OR',0                  * String value for instruction
00002E13= 53 55 42 00             2382  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
00002E17= 41 4E 44 00             2383  opNam_AND           DC.B     'AND',0                 * String value for instruction
00002E1B= 41 44 44 00             2384  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
00002E1F= 41 44 44 41 00          2385  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
00002E24= 41 53 4C 00             2386  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
00002E28= 41 53 52 00             2387  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
00002E2C= 4C 53 4C 00             2388  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
00002E30= 4C 53 52 00             2389  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
00002E34= 52 4F 4C 00             2390  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
00002E38= 52 4F 52 00             2391  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
00002E3C                          2392  
00002E3C= 2E 42 00                2393  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
00002E3F= 2E 57 00                2394  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
00002E42= 2E 4C 00                2395  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
00002E45                          2396  
00002E45= 50 6C 61 63 65 68 ...   2397  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
00002E96= 45 72 72 6F 72 00       2398  msgErr              DC.B     'Error',0               * Debug message
00002E9C                          2399  
00002E9C= 33 20 43 6F 72 65 ...   2400  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002EB3= 4D 65 6D 6F 72 79 ...   2401  msgHdr02a           DC.B     'Memory range:',0
00002EC1= 20 74 6F 20 00          2402  msgHdr02b           DC.B     ' to ',0
00002EC6                          2403  
00002EC6= 20 2D 20 41 6C 6C ...   2404  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
00002EF5= 20 2D 20 56 61 6C ...   2405  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
00002F27= 20 2D 20 53 74 61 ...   2406  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
00002F5C= 20 20 20 40 20 58 ...   2407  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002F7B= 20 2D 20 41 64 64 ...   2408  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002FBC= 20 20 20 28 61 75 ...   2409  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002FD1= 50 6C 65 61 73 65 ...   2410  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00002FF3= 49 6E 76 61 6C 69 ...   2411  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
00003015= 49 6E 76 61 6C 69 ...   2412  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
00003042= 53 74 61 72 74 69 ...   2413  msgStrAdr1Scc       DC.B     'Starting address: ',0
00003055= 50 6C 65 61 73 65 ...   2414  msgStrAdr2          DC.B     'Please enter an ending address: ',0
00003076= 49 6E 76 61 6C 69 ...   2415  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
00003096= 49 6E 76 61 6C 69 ...   2416  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
000030C1                          2417  
000030C1= 48 69 74 20 45 6E ...   2418  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
000030E4= 59 6F 75 20 68 61 ...   2419  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
00003117= 20 20 20 20 20 20 ...   2420  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
00003149= 54 68 61 6E 6B 20 ...   2421  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
00003173                          2422  
00003173= 2A 2A 2A 2A 2A 2A ...   2423  msgLine             DC.B     '**************************************************',CR,LF,0
000031A8= 0D 0A 00                2424  msgNewLine          DC.B     CR,LF,0
000031AB= 2C 00                   2425  opComma             DC.B     ',',0
000031AD= 2E 00                   2426  opPeriod            DC.B     '.',0
000031AF= 20 00                   2427  opSpace             DC.B     ' ',0
000031B2= 0900                    2428  opTab               DC.W     $0900                  * Tab - doesn't work as expected
000031B4= 00                      2429  opBlank             DC.B     '',0
000031B5  =0000000D               2430  CR                  EQU      $0D                     * ASCII code for Carriage Return
000031B5  =0000000A               2431  LF                  EQU      $0A                     * ASCII code for Line Feed
000031B5                          2432  
000031B5                          2433                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           2D30
ADRSTRSTART         2D22
ADRSTSEND           2D39
ADRSTSSTART         2D2B
ADRVALEND           2D2C
ADRVALSTART         2D1E
CR                  D
FN_ASCII_LCLTR      19B6
FN_ASCII_NUM        19AA
FN_ASCII_UCLTR      19B0
FN_CPY_STR_DONE     1A14
FN_CPY_STR_LOOP     1A06
FN_DSP_DATA         15EC
FN_DSP_DONE         1984
FN_DSP_DTA1         1684
FN_DSP_DTA1_00      16DC
FN_DSP_DTA1_01      16F0
FN_DSP_DTA1_02      1704
FN_DSP_DTA1_03      1720
FN_DSP_DTA1_04      1740
FN_DSP_DTA1_07      1760
FN_DSP_DTA1_BYT     1788
FN_DSP_DTA1_ERR     17EE
FN_DSP_DTA1_LNG     17CC
FN_DSP_DTA1_WRD     17AA
FN_DSP_DTA2         180A
FN_DSP_DTA2_00      1862
FN_DSP_DTA2_01      1876
FN_DSP_DTA2_02      188A
FN_DSP_DTA2_03      18A6
FN_DSP_DTA2_04      18C6
FN_DSP_DTA2_07      18E6
FN_DSP_DTA2_BYT     190E
FN_DSP_DTA2_ERR     1974
FN_DSP_DTA2_LNG     1952
FN_DSP_DTA2_WRD     1930
FN_DSP_INSTR        1608
FN_DSP_OPR1         1678
FN_DSP_OPR2         17FE
FN_DSP_SIZB         1648
FN_DSP_SIZL         1668
FN_DSP_SIZW         1658
FN_HEX_LTR          19CE
FN_HEX_NUM          19C8
FN_HEX_STR_DONE     1A00
FN_HEX_STR_LOOP     19D4
FN_ID3_CHKDSTMOD    1C02
FN_ID3_CHKDSTREG    1C12
FN_ID3_CHKSRCREG    1B7C
FN_ID3_DONE         1C52
FN_ID3_DTADSTLNG    1C40
FN_ID3_DTADSTWRD    1C2E
FN_ID3_DTASRCBYT    1BCC
FN_ID3_DTASRCIMD    1BA4
FN_ID3_DTASRCLNG    1BF0
FN_ID3_DTASRCWRD    1BDE
FN_ID3_ERROR        1C5A
FN_ID3_INS01        1A9C
FN_ID3_INS02        1AAC
FN_ID3_SIZB         1B48
FN_ID3_SIZL         1B60
FN_ID3_SIZW         1B54
FN_ID3_SRCMOD       1B6C
FN_ID3_VERIFY       1AC4
FN_ID4_CHECKD1      1D0E
FN_ID4_CHECKD2      1D32
FN_ID4_CHECKD3      1D62
FN_ID4_DATA         2058
FN_ID4_DATA_MVM     20DE
FN_ID4_DONE         2170
FN_ID4_DTABYT       20A8
FN_ID4_DTABYT_MVM   212E
FN_ID4_DTAIMD       2080
FN_ID4_DTAIMD_MVM   2106
FN_ID4_DTALNG       20CC
FN_ID4_DTALNG_MVM   2152
FN_ID4_DTAWRD       20BA
FN_ID4_DTAWRD_MVM   2140
FN_ID4_ERROR        216E
FN_ID4_GRABMASK     2164
FN_ID4_JSR          1D7A
FN_ID4_JSR_SRC      1E16
FN_ID4_LEA          1E26
FN_ID4_LEA_SRC      1E86
FN_ID4_MOVEMMTOR    1F06
FN_ID4_MOVEMRTOM    1E96
FN_ID4_MOVEM_SRC    1F72
FN_ID4_NOP          1F82
FN_ID4_NOT          1FC2
FN_ID4_NOT_SRC      1FFE
FN_ID4_RTS          2018
FN_ID4_VERIFY_JSR   1D86
FN_ID4_VERIFY_LEA   1E32
FN_ID4_VERIFY_MMR   1F12
FN_ID4_VERIFY_MRM   1EA2
FN_ID4_VERIFY_NOP   1F8E
FN_ID4_VERIFY_NOT   1FCE
FN_ID4_VERIFY_RTS   2024
FN_ID5_CHKDSTMOD    2290
FN_ID5_CHKDSTREG    22A0
FN_ID5_DONE         22E2
FN_ID5_DTADSTLNG    22CE
FN_ID5_DTADSTWRD    22BC
FN_ID5_DTASRCBYT    225A
FN_ID5_DTASRCIMD    2232
FN_ID5_DTASRCLNG    227E
FN_ID5_DTASRCWRD    226C
FN_ID5_ERROR        22E0
FN_ID5_VERIFY       21F2
FN_ID6_BEQ          236C
FN_ID6_BGT          2376
FN_ID6_BLE          2380
FN_ID6_BRA          2362
FN_ID6_DISPLACEMENT  2386
FN_ID6_DONE         23DA
FN_ID6_DSPLCMNT16   23B4
FN_ID6_DSPLCMNT32   23C6
FN_ID6_ERROR        23D8
FN_ID7_DONE         246A
FN_ID7_ERROR        2468
FN_ID8_CASE1        2508
FN_ID8_CASE2        254A
FN_ID8_DATADST      2572
FN_ID8_DATASRC      25F8
FN_ID8_DONE         2680
FN_ID8_DTADSTBYT    25C2
FN_ID8_DTADSTIMD    259A
FN_ID8_DTADSTLNG    25E6
FN_ID8_DTADSTWRD    25D4
FN_ID8_DTASRCBYT    2648
FN_ID8_DTASRCIMD    2620
FN_ID8_DTASRCLNG    266C
FN_ID8_DTASRCWRD    265A
FN_ID8_ERROR        267E
FN_ID9_CASE1        271E
FN_ID9_CASE2        2760
FN_ID9_DATADST      2788
FN_ID9_DATASRC      280E
FN_ID9_DONE         2896
FN_ID9_DTADSTBYT    27D8
FN_ID9_DTADSTIMD    27B0
FN_ID9_DTADSTLNG    27FC
FN_ID9_DTADSTWRD    27EA
FN_ID9_DTASRCBYT    285E
FN_ID9_DTASRCIMD    2836
FN_ID9_DTASRCLNG    2882
FN_ID9_DTASRCWRD    2870
FN_ID9_ERROR        2894
FN_IDA_DONE         28A0
FN_IDB_DONE         28A2
FN_IDC_CASE1        2938
FN_IDC_CASE2        297A
FN_IDC_DATADST      29A2
FN_IDC_DATASRC      2A28
FN_IDC_DONE         2AB0
FN_IDC_DTADSTBYT    29F2
FN_IDC_DTADSTIMD    29CA
FN_IDC_DTADSTLNG    2A16
FN_IDC_DTADSTWRD    2A04
FN_IDC_DTASRCBYT    2A78
FN_IDC_DTASRCIMD    2A50
FN_IDC_DTASRCLNG    2A9C
FN_IDC_DTASRCWRD    2A8A
FN_IDC_ERROR        2AAE
FN_IDD_CASE1        2B60
FN_IDD_CASE2        2BA8
FN_IDD_CASE3        2BD6
FN_IDD_DATADST      2C04
FN_IDD_DATASRC      2C8A
FN_IDD_DONE         2D12
FN_IDD_DTADSTBYT    2C54
FN_IDD_DTADSTIMD    2C2C
FN_IDD_DTADSTLNG    2C78
FN_IDD_DTADSTWRD    2C66
FN_IDD_DTASRCBYT    2CDA
FN_IDD_DTASRCIMD    2CB2
FN_IDD_DTASRCLNG    2CFE
FN_IDD_DTASRCWRD    2CEC
FN_IDD_ERROR        2D10
FN_MAIN_CHKAGN      1162
FN_MAIN_CHKEND      1154
FN_MAIN_CHKLIN      111C
FN_MAIN_CHKPAG      1132
FN_MAIN_CONTINUE    119A
FN_MAIN_DONE        119E
FN_MAIN_DSP         1116
FN_MAIN_ERRINS      1110
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_UI_CHKHEX        13FE
FN_UI_CHKHEXASL     1452
FN_UI_CHKHEXDONE    143A
FN_UI_CHKHEXLOOP    1404
FN_UI_CHKHEXRDR     1454
FN_UI_CHKLEN        13CA
FN_UI_CHKVAL        14DE
FN_UI_CHKVALCMP     1512
FN_UI_CHKVALEBIG    150C
FN_UI_CHKVALEMAX    14FE
FN_UI_CHKVALSBIG    14F8
FN_UI_CHKVALSMAX    14EA
FN_UI_CHKVALSONE    1538
FN_UI_CHKVALSWP     151C
FN_UI_CHKVALSWRD    1522
FN_UI_DONE          153A
FN_UI_DSPSTART      127A
FN_UI_END           1372
FN_UI_ENDE1         138E
FN_UI_ENDE2         139E
FN_UI_END_IN        13AE
FN_UI_HDRNEXT       129E
FN_UI_LOOP          1248
FN_UI_SETEHEX       14B6
FN_UI_SETEHEXI1     14C6
FN_UI_SETEHEXI2     14D2
FN_UI_SETELEN       13D6
FN_UI_SETELENI1     13E6
FN_UI_SETELENI2     13F2
FN_UI_SETVHEX       145E
FN_UI_SETVHEXI1     146E
FN_UI_SETVHEXI2     1492
FN_UI_START         131A
FN_UI_STARTE1       1336
FN_UI_STARTE2       1346
FN_UI_START_IN      1356
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             3149
MSGENDMEM01         30E4
MSGENDMEM02         3117
MSGERR              2E96
MSGHDR01            2E9C
MSGHDR02A           2EB3
MSGHDR02B           2EC1
MSGINTEMP           2E45
MSGLINE             3173
MSGNEWLINE          31A8
MSGPAGE             30C1
MSGSTRADR1          2FD1
MSGSTRADR1ERR1      2FF3
MSGSTRADR1ERR2      3015
MSGSTRADR1SCC       3042
MSGSTRADR2          3055
MSGSTRADR2ERR1      3076
MSGSTRADR2ERR2      3096
MSGSTRINTRO         2EC6
MSGSTRNOTE          2F7B
MSGSTRNOTEMORE      2FBC
MSGSTRRANGE         2EF5
MSGSTRSIZE          2F27
MSGSTRSIZEEXMPL     2F5C
OPBLANK             31B4
OPCOMMA             31AB
OPDSTMOD            2DA6
OPDSTREG            2DA5
OPDTA1              2DAA
OPDTA1T             2DAE
OPDTA2              2DB0
OPDTA2T             2DB4
OPERR               2D3D
OPID                2D3C
OPIR                2DCA
OPMASK              2DC4
OPNAM_ADD           2E1B
OPNAM_ADDA          2E1F
OPNAM_ADDQ          2DF5
OPNAM_AND           2E17
OPNAM_ASL           2E24
OPNAM_ASR           2E28
OPNAM_BEQ           2DFE
OPNAM_BGT           2E02
OPNAM_BLE           2E06
OPNAM_BRA           2DFA
OPNAM_DATA          2DCB
OPNAM_JSR           2DF1
OPNAM_LEA           2DDB
OPNAM_LSL           2E2C
OPNAM_LSR           2E30
OPNAM_MOVE          2DD0
OPNAM_MOVEA         2DD5
OPNAM_MOVEM         2DE3
OPNAM_MOVEQ         2E0A
OPNAM_NOP           2DE9
OPNAM_NOT           2DDF
OPNAM_OR            2E10
OPNAM_ROL           2E34
OPNAM_ROR           2E38
OPNAM_RTS           2DED
OPNAM_SUB           2E13
OPNXTADR            2D4C
OPOUTBUF            2D50
OPPERIOD            31AD
OPPTRNAM            2DA0
OPROTATE            2DC8
OPSIZB              2E3C
OPSIZDIR            2DC9
OPSIZL              2E42
OPSIZW              2E3F
OPSPACE             31AF
OPSRCMOD            2DA8
OPSRCREG            2DA7
OPSTRADR            2D42
OPSTRDTALNG         2DBA
OPSTRDTAWRD         2DB5
OPTAB               31B2
OPVALADR            2D3E
OPVALSIZ            2DA4
OPWORD              2D3A
SR_ASCII_HEX        1996
SR_CNT_STR_BUF      1A16
SR_CPY_STR_BUF      1A06
SR_DSP_DISPLAY      15B4
SR_DSP_HEADER       1552
SR_HEX_ASCII        19BC
SR_HEX_STR          19D4
SR_ID3              1A1A
SR_ID4              1C5C
SR_ID5              217A
SR_ID6              22EC
SR_ID7              23E4
SR_ID8              2474
SR_ID9              268A
SR_IDA              28A0
SR_IDB              28A2
SR_IDC              28A4
SR_IDD              2ABA
SR_IDE              2D1C
SR_IDX              1A18
SR_JUMP             11B8
SR_UI_INPUT         1238
