00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/7/2021 6:56:54 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 00002D2E    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 00002D3C    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 00002D2E             51                      LEA     adrValStart,A4
00001020  4BF9 00002D32             52                      LEA     adrStrStart,A5
00001026  4EB9 000019D4             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 00002D3C             54                      LEA     adrValEnd,A4
00001032  4BF9 00002D40             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019D4             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 000011B8             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 00002D2E             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001552             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 00002D4E             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 00002D4A             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 00002D5C             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 00002D4C        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 00002D4D        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002DB4        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002DB5        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002DB6        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002DB7        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002DB8        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002DBA    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 00002DBE        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 00002DC0    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002DC4        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA  23FC 00000000 00002DD4    96                      MOVE.L  #$00000000,opMask
000010D4  13FC 0000 00002DD8        97                      MOVE.B  #$00,opRotate
000010DC  13FC 0000 00002DD9        98                      MOVE.B  #$00,opSizDir
000010E4  13FC 0000 00002DDA        99                      MOVE.B  #$00,opIR
000010EC                           100  
000010EC                           101                      ** Jump table
000010EC                           102                      **
000010EC  3A39 00002D4A            103                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010F2  1C3C 000C                104                      MOVE.B  #12,D6
000010F6  EC6D                     105                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010F8  CAFC 0008                106                      MULU    #8,D5                   * offset is multiple of 8
000010FC  4EB0 5000                107                      JSR     0(A0,D5)                * Jump indirect with index
00001100                           108  
00001100                           109                      ** Invalid instruction
00001100                           110                      **
00001100  0C39 0001 00002D4D       111                      CMP.B   #1,opErr
00001108  6700 0006                112                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
0000110C  6000 0008                113                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
00001110  2479 00002D5C            114  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
00001116                           115  
00001116                           116                      ** Display result
00001116                           117                      **
00001116  4EB9 000015B4            118  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
0000111C                           119  
0000111C                           120                      ** Max lines display stop, wait for enter
0000111C                           121                      **
0000111C  5207                     122  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
0000111E                           123  
0000111E  2C07                     124                      MOVE.L  D7,D6                   * Line counter to D6 for division
00001120  8CFC 001A                125                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001124  4846                     126                      SWAP    D6                      * Swap for remainder (modulo)
00001126  BC3C 0000                127                      CMP.B   #0,D6                   * Check remainder for zero
0000112A  6700 0006                128                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000112E  6000 0024                129                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001132                           130  
00001132                           131                      ** Logic to check ENTER key to show next page
00001132                           132                      **
00001132  43F9 000030D1            133  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001138  103C 000E                134                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000113C  4E4F                     135                      TRAP    #15                     * Display to screen
0000113E  103C 0005                136                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001142  4E4F                     137                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001144                           138  
00001144                           139                      ** Clear screen
00001144  103C 000B                140                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001148  323C FF00                141                      MOVE.W  #$FF00,D1               * Clear the screen
0000114C  4E4F                     142                      TRAP    #15
0000114E                           143  
0000114E                           144                      ** Display header
0000114E  4EB9 00001552            145                      JSR     SR_DSP_HEADER
00001154                           146  
00001154                           147                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001154                           148                      **
00001154  B5F9 00002D3C            149  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
0000115A  6C00 0006                150                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000115E  6000 003A                151                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001162                           152  
00001162                           153                      ** Logic to check for for Y or N to check another region of memory
00001162                           154                      **
00001162  43F9 000030F4            155  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001168  103C 000E                156                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000116C  4E4F                     157                      TRAP    #15                     * Display to screen
0000116E  43F9 00003127            158                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001174  103C 000E                159                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001178  4E4F                     160                      TRAP    #15                     * Display to screen
0000117A                           161  
0000117A  43F9 00002E55            162                      LEA     msgInTemp,A1            * Load placeholder for input string
00001180  103C 0002                163                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001184  4E4F                     164                      TRAP    #15                     * Read string to (A1), length in D1.W
00001186  0C11 0059                165                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
0000118A  6700 FE7A                166                      BEQ     Fn_MAIN_Start           * Restart program
0000118E  0C11 0079                167                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001192  6700 FE72                168                      BEQ     Fn_MAIN_Start           * Restart program
00001196  6000 0006                169                      BRA     Fn_Main_Done            * Exit program
0000119A                           170  
0000119A  6000 FEC0                171  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000119E                           172  
0000119E                           173  Fn_MAIN_Done        ** That's all folks
0000119E  103C 000B                174                      MOVE.B  #11,D0                  * Trap task 2 does the following:
000011A2  323C FF00                175                      MOVE.W  #$FF00,D1               * Clear the screen
000011A6  4E4F                     176                      TRAP    #15
000011A8                           177  
000011A8                           178                      ** Thank you message
000011A8  43F9 00003159            179                      LEA     msgDone,A1              * Loads MESSAGE into A1
000011AE  103C 000E                180                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000011B2  4E4F                     181                      TRAP    #15                     * Display to screen
000011B4                           182  
000011B4                           183  
000011B4  4E72 2700                184                      STOP   #$2700                   * Stop execution
000011B8                           185  
000011B8                           186  ** -----------------------------------------------------------
000011B8                           187  ** JUMP TABLE: First 4 bits of instruction
000011B8                           188  **
000011B8                           189  ** Jump instruction: pointing to label (xxx).L
000011B8                           190  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
000011B8                           191  **                          label address (Long)
000011B8                           192  **
000011B8                           193  ** RTS instruction:
000011B8                           194  **  |4    E    |7    5     |               - Offset 2 bytes
000011B8                           195  **
000011B8                           196  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
000011B8                           197  **
000011B8                           198  ** Note: should find a value since 4 bits is 0 to F
000011B8                           199  ** Note: There aren't any instructions that start with F
000011B8                           200  **
000011B8                           201  ** -----------------------------------------------------------
000011B8  4EB9 00001A18            202  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
000011BE  4E75                     203                      RTS
000011C0  4EB9 00001A1A            204                      JSR     SR_ID3
000011C6  4E75                     205                      RTS
000011C8  4EB9 00001A1A            206                      JSR     SR_ID3
000011CE  4E75                     207                      RTS
000011D0  4EB9 00001A1A            208                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011D6  4E75                     209                      RTS
000011D8  4EB9 00001C5C            210                      JSR     SR_ID4
000011DE  4E75                     211                      RTS
000011E0  4EB9 0000218A            212                      JSR     SR_ID5
000011E6  4E75                     213                      RTS
000011E8  4EB9 000022FC            214                      JSR     SR_ID6
000011EE  4E75                     215                      RTS
000011F0  4EB9 000023F4            216                      JSR     SR_ID7
000011F6  4E75                     217                      RTS
000011F8  4EB9 00002484            218                      JSR     SR_ID8
000011FE  4E75                     219                      RTS
00001200  4EB9 0000269A            220                      JSR     SR_ID9
00001206  4E75                     221                      RTS
00001208  4EB9 000028B0            222                      JSR     SR_IDA
0000120E  4E75                     223                      RTS
00001210  4EB9 000028B2            224                      JSR     SR_IDB
00001216  4E75                     225                      RTS
00001218  4EB9 000028B4            226                      JSR     SR_IDC
0000121E  4E75                     227                      RTS
00001220  4EB9 00002ACA            228                      JSR     SR_IDD
00001226  4E75                     229                      RTS
00001228  4EB9 00002D2C            230                      JSR     SR_IDE
0000122E  4E75                     231                      RTS
00001230  4EB9 00001A18            232                      JSR     SR_IDX                   * No instructions @ ID=15
00001236  4E75                     233                      RTS
00001238                           234  
00001238                           235  ** -----------------------------------------------------------
00001238                           236  ** UI: User mem input
00001238                           237  ** -----------------------------------------------------------
00001238                           238  SR_UI_INPUT
00001238  13F8 00FF 00002D3B       239                      MOVE.B  $FF,adrStsStart         * Reset starting address status
00001240  13F8 00FF 00002D49       240                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001248                           241  
00001248                           242  Fn_UI_Loop          ** Clear screen
00001248  103C 000B                243                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000124C  323C FF00                244                      MOVE.W  #$FF00,D1               * Clear the screen
00001250  4E4F                     245                      TRAP    #15
00001252                           246  
00001252                           247                      ** Header
00001252                           248                      ** ***************************************
00001252                           249  
00001252  43F9 00003183            250                      LEA     msgLine,A1              * '********************'
00001258  103C 000E                251                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000125C  4E4F                     252                      TRAP    #15                     * Display to screen
0000125E                           253  
0000125E  43F9 00002EAC            254                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001264  103C 000E                255                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001268  4E4F                     256                      TRAP    #15                     * Display to screen
0000126A                           257  
0000126A  0C39 0000 00002D3B       258                      CMP.B   #0,adrStsStart          * Starting address is set
00001272  6700 0006                259                      BEQ     Fn_UI_DspStart          * Display starting address
00001276  6000 0026                260                      BRA     Fn_UI_HdrNext           * Display the rest of the header
0000127A                           261  
0000127A  43F9 00003052            262  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
00001280  103C 000E                263                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001284  4E4F                     264                      TRAP    #15                     * Display to screen
00001286                           265  
00001286  43F9 00002D32            266                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000128C  103C 000E                267                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001290  4E4F                     268                      TRAP    #15                     * Display to screen
00001292                           269  
00001292  43F9 000031B8            270                      LEA     msgNewLine,A1           * CR,LF
00001298  103C 000E                271                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129C  4E4F                     272                      TRAP    #15                     * Display to screen
0000129E                           273  
0000129E  43F9 00003183            274  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
000012A4  103C 000E                275                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012A8  4E4F                     276                      TRAP    #15                     * Display to screen
000012AA                           277  
000012AA  43F9 00002ED6            278                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
000012B0  103C 000E                279                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B4  4E4F                     280                      TRAP    #15                     * Display to screen
000012B6                           281  
000012B6  43F9 00002F05            282                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
000012BC  103C 000E                283                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C0  4E4F                     284                      TRAP    #15                     * Display to screen
000012C2                           285  
000012C2  43F9 00002F37            286                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012C8  103C 000E                287                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CC  4E4F                     288                      TRAP    #15                     * Display to screen
000012CE                           289  
000012CE  43F9 00002F6C            290                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012D4  103C 000E                291                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012D8  4E4F                     292                      TRAP    #15                     * Display to screen
000012DA                           293  
000012DA  43F9 00002F8B            294                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012E0  103C 000E                295                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012E4  4E4F                     296                      TRAP    #15                     * Display to screen
000012E6                           297  
000012E6  43F9 00002FCC            298                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012EC  103C 000E                299                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012F0  4E4F                     300                      TRAP    #15                     * Display to screen
000012F2                           301  
000012F2  43F9 000031B8            302                      LEA     msgNewLine,A1           * CR,LF
000012F8  103C 000E                303                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012FC  4E4F                     304                      TRAP    #15                     * Display to screen
000012FE                           305  
000012FE                           306                      ** Input check
000012FE                           307                      ** ***************************************
000012FE                           308  
000012FE  0C39 0000 00002D3B       309                      CMP.B #0,adrStsStart            * Check status of address 0 = success
00001306  6600 0012                310                      BNE   Fn_UI_Start               * Input starting address
0000130A                           311  
0000130A  0C39 0000 00002D49       312                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
00001312  6600 005E                313                      BNE   Fn_UI_End                 * Input ending address
00001316                           314  
00001316                           315                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
00001316  6000 01C6                316                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
0000131A                           317  
0000131A                           318  Fn_UI_Start         ** Input Start Address
0000131A                           319                      ** ***************************************
0000131A                           320  
0000131A                           321                      ** Check errors
0000131A  0C39 0001 00002D3B       322                      CMP.B   #1,adrStsStart
00001322  6700 0012                323                      BEQ     Fn_UI_StartE1           * Error: length
00001326  0C39 0002 00002D3B       324                      CMP.B   #2,adrStsStart
0000132E  6700 0016                325                      BEQ     Fn_UI_StartE2           * Error: hex value
00001332  6000 0022                326                      BRA     Fn_UI_Start_In          * No error: ask for input
00001336                           327  
00001336  43F9 00003003            328  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000133C  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001340  4E4F                     330                      TRAP    #15
00001342  6000 0012                331                      BRA     Fn_UI_Start_In          * User input
00001346                           332  
00001346  43F9 00003025            333  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000134C  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001350  4E4F                     335                      TRAP    #15
00001352  6000 0002                336                      BRA     Fn_UI_Start_In          * User input
00001356                           337  
00001356  43F9 00002FE1            338  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000135C  103C 000E                339                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001360  4E4F                     340                      TRAP    #15                     * Display to screen
00001362                           341  
00001362  43F9 00002E55            342                      LEA     msgInTemp,A1            * Load placeholder for input string
00001368  103C 0002                343                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000136C  4E4F                     344                      TRAP    #15                     * Read string to (A1), length in D1.W
0000136E                           345  
0000136E  6000 005A                346                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001372                           347  
00001372                           348  Fn_UI_End           ** Input End Address
00001372                           349                      ** ***************************************
00001372                           350  
00001372                           351                      ** Check errors
00001372  0C39 0001 00002D49       352                      CMP.B   #1,adrStsEnd
0000137A  6700 0012                353                      BEQ     Fn_UI_EndE1             * Error: length
0000137E  0C39 0002 00002D49       354                      CMP.B   #2,adrStsEnd
00001386  6700 0016                355                      BEQ     Fn_UI_EndE2             * Error: hex value
0000138A  6000 0022                356                      BRA     Fn_UI_End_In            * No error: ask for input
0000138E                           357  
0000138E  43F9 00003086            358  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001394  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001398  4E4F                     360                      TRAP    #15
0000139A  6000 0012                361                      BRA     Fn_UI_End_In            * User input
0000139E                           362  
0000139E  43F9 000030A6            363  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
000013A4  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013A8  4E4F                     365                      TRAP    #15
000013AA  6000 0002                366                      BRA     Fn_UI_End_In            * User input
000013AE                           367  
000013AE  43F9 00003065            368  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
000013B4  103C 000E                369                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013B8  4E4F                     370                      TRAP    #15                     * Display to screen
000013BA                           371  
000013BA  43F9 00002E55            372                      LEA     msgInTemp,A1            * Load placeholder for input string
000013C0  103C 0002                373                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013C4  4E4F                     374                      TRAP    #15                     * Read string to (A1), length in D1.W
000013C6                           375  
000013C6  6000 0002                376                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013CA                           377  
000013CA                           378  Fn_UI_ChkLen        ** Check length
000013CA                           379                      **   length should be 8 ascii characters
000013CA                           380                      **   value stored in D1.W from input
000013CA                           381                      ** ***************************************
000013CA                           382  
000013CA  B27C 0008                383                      CMP.W   #8,D1                   * Address should be 8 chars long
000013CE  6600 0006                384                      BNE     Fn_UI_SetELen           * Invalid address length
000013D2  6000 002A                385                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013D6                           386  
000013D6                           387  Fn_UI_SetELen       ** Error: length
000013D6  0C39 0000 00002D3B       388                      CMP.B #0,adrStsStart
000013DE  6600 0006                389                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013E2  6000 000E                390                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013E6                           391  Fn_UI_SetELenI1     ** Set error on input 1
000013E6  13FC 0001 00002D3B       392                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013EE  6000 FE58                393                      BRA     Fn_UI_Loop
000013F2                           394  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013F2  13FC 0001 00002D49       395                      MOVE.B  #1,adrStsEnd
000013FA  6000 FE4C                396                      BRA     Fn_UI_Loop
000013FE                           397  
000013FE                           398  Fn_UI_ChkHex        ** Check hex values
000013FE                           399                      **   30 - 39 (0-9)
000013FE                           400                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013FE                           401                      ** ***************************************
000013FE                           402  
000013FE  163C 0000                403                      MOVE.B  #0,D3                   * Loop counter
00001402  4286                     404                      CLR.L   D6                      * Temporary address storage
00001404                           405  
00001404                           406  Fn_UI_ChkHexLoop    ** Check hex values one at a time
00001404  1819                     407                      MOVE.B  (A1)+,D4                * Unload byte and increment input
00001406                           408  
00001406  B83C 0030                409                      CMP.B   #$30,D4
0000140A  6D00 00AA                410                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140E                           411  
0000140E  B83C 0039                412                      CMP.B   #$39,D4
00001412  6F00 0026                413                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001416                           414  
00001416  B83C 0041                415                      CMP.B   #$41,D4
0000141A  6D00 009A                416                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000141E                           417  
0000141E  B83C 0046                418                      CMP.B   #$46,D4
00001422  6F00 0016                419                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001426                           420  
00001426  B83C 0061                421                      CMP.B   #$61,D4
0000142A  6D00 008A                422                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000142E                           423  
0000142E  B83C 0066                424                      CMP.B   #$66,D4
00001432  6F00 0006                425                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001436                           426  
00001436  6000 007E                427                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
0000143A                           428  
0000143A                           429  Fn_UI_ChkHexDone    ** Check if at end of loop
0000143A                           430  
0000143A  5203                     431                      ADDI.B  #1,D3                   * Increment loop counter
0000143C                           432  
0000143C                           433                      ** Insert ascii value into temp address
0000143C  1A04                     434                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000143E  4EB9 00001996            435                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001444  DC05                     436                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001446  B63C 0008                437                      CMP.B   #8,D3                   * To shift or not to shift
0000144A  6D00 0006                438                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000144E  6000 0004                439                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001452  E986                     440  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001454                           441  
00001454                           442  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001454  B63C 0008                443                      CMP.B   #8,D3                   * Loop 8 times
00001458  66AA                     444                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
0000145A  6000 0002                445                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000145E                           446  
0000145E                           447  Fn_UI_SetVHex       ** Valid: hex values
0000145E  0C39 0000 00002D3B       448                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001466  6600 0006                449                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
0000146A  6000 0026                450                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000146E                           451  
0000146E                           452  Fn_UI_SetVHexI1     ** Set valid on input 1
0000146E  13FC 0000 00002D3B       453                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001476  23C6 00002D2E            454                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000147C  49F9 00002D2E            455                      LEA     adrValStart,A4
00001482  4BF9 00002D32            456                      LEA     adrStrStart,A5
00001488  4EB9 000019D4            457                      JSR     SR_HEX_STR              * Copy address value to string for display
0000148E  6000 FDB8                458                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001492                           459  
00001492                           460  Fn_UI_SetVHexI2     ** Set valid on input 2
00001492  13FC 0000 00002D49       461                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
0000149A  23C6 00002D3C            462                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
000014A0  49F9 00002D3C            463                      LEA     adrValEnd,A4
000014A6  4BF9 00002D40            464                      LEA     adrStrEnd,A5
000014AC  4EB9 000019D4            465                      JSR     SR_HEX_STR              * Copy address value to string for display
000014B2  6000 FD94                466                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
000014B6                           467  
000014B6                           468  Fn_UI_SetEHex       ** Error: hex values
000014B6  0C39 0000 00002D3B       469                      CMP.B   #0,adrStsStart
000014BE  6600 0006                470                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014C2  6000 000E                471                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014C6                           472  
000014C6                           473  Fn_UI_SetEHexI1     ** Set error on input 1
000014C6  13FC 0002 00002D3B       474                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014CE  6000 FD78                475                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014D2                           476  
000014D2                           477  Fn_UI_SetEHexI2     ** Set error on input 2
000014D2  13FC 0002 00002D49       478                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014DA  6000 FD6C                479                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014DE                           480  
000014DE                           481  Fn_UI_ChkVal        ** Check address range, order
000014DE                           482                      **   Address automagic - will fix addresses if invalid input
000014DE                           483                      ** Note: addresses are unsigned; should not be less than zero
000014DE                           484                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014DE                           485                      ** Note: subtracting one from Start address if not even
000014DE                           486                      **       doesn't really matter if end address is even or odd
000014DE                           487                      ** ***************************************
000014DE                           488  
000014DE  2A39 00002D2E            489                      MOVE.L  adrValStart,D5
000014E4  2C39 00002D3C            490                      MOVE.L  adrValEnd,D6
000014EA                           491  
000014EA  BABC 00FFFFEC            492  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014F0  6200 0006                493                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014F4  6000 0008                494                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014F8                           495  
000014F8  2A3C 00FFFFEC            496  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014FE                           497  
000014FE  BCBC 00FFFFED            498  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
00001504  6200 0006                499                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
00001508  6000 0008                500                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
0000150C                           501  
0000150C  2C3C 00FFFFED            502  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
00001512                           503  
00001512  BA86                     504  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
00001514  6200 0006                505                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
00001518  6000 0008                506                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
0000151C                           507  
0000151C  2805                     508  Fn_UI_ChkValSwp     MOVE.L  D5,D4
0000151E  2A06                     509                      MOVE.L  D6,D5
00001520  2C04                     510                      MOVE.L  D4,D6
00001522                           511  
00001522                           512  FN_UI_ChkValSWrd    ** Check start for word boundry
00001522  1605                     513                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001524  183C 0002                514                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001528  86C4                     515                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
0000152A  4843                     516                      SWAP    D3                       * Swap for remainder (the modulo part)
0000152C  B63C 0000                517                      CMP.B   #0,D3                    * If zero, then even
00001530  6600 0006                518                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001534  6000 0004                519                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001538                           520  
00001538  5385                     521  Fn_UI_ChkValSOne    SUBI.L  #1,D5
0000153A                           522  
0000153A                           523  Fn_UI_Done          ** All done with input, time to go
0000153A                           524                      ** ***************************************
0000153A                           525  
0000153A  23C5 00002D2E            526                      MOVE.L  D5,adrValStart          * Move final address to Start
00001540  23C6 00002D3C            527                      MOVE.L  D6,adrValEnd            * Move final address to End
00001546                           528  
00001546                           529                      ** Clear screen
00001546  103C 000B                530                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000154A  323C FF00                531                      MOVE.W  #$FF00,D1               * Clear the screen
0000154E  4E4F                     532                      TRAP    #15
00001550                           533  
00001550  4E75                     534                      RTS
00001552                           535  
00001552                           536  ** -----------------------------------------------------------
00001552                           537  ** UI: Display Header
00001552                           538  ** -----------------------------------------------------------
00001552                           539  SR_DSP_HEADER
00001552                           540  
00001552                           541                      ** Header line 03
00001552  43F9 00003183            542                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001558  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155C  4E4F                     544                      TRAP    #15                     * Display to screen
0000155E                           545  
0000155E                           546                      ** Header line 01
0000155E  43F9 00002EAC            547                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001564  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001568  4E4F                     549                      TRAP    #15                     * Display to screen
0000156A                           550  
0000156A                           551                      ** Header line 02
0000156A  43F9 00002EC3            552                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
00001570  103C 000E                553                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001574  4E4F                     554                      TRAP    #15                     * Display to screen
00001576                           555  
00001576  43F9 00002D32            556                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000157C  103C 000E                557                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001580  4E4F                     558                      TRAP    #15                     * Display to screen
00001582                           559  
00001582  43F9 00002ED1            560                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001588  103C 000E                561                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158C  4E4F                     562                      TRAP    #15
0000158E                           563  
0000158E  43F9 00002D40            564                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001594  103C 000E                565                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001598  4E4F                     566                      TRAP    #15                     * Display to screen
0000159A                           567  
0000159A  43F9 000031B8            568                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
000015A0  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015A4  4E4F                     570                      TRAP    #15                     * Display to screen
000015A6                           571  
000015A6                           572                      ** Header line 03
000015A6  43F9 00003183            573                      LEA     msgLine,A1              * Loads MESSAGE into A1
000015AC  103C 000E                574                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015B0  4E4F                     575                      TRAP    #15                     * Display to screen
000015B2                           576  
000015B2  4E75                     577                      RTS
000015B4                           578  
000015B4                           579  ** -----------------------------------------------------------
000015B4                           580  ** UI: Display item
000015B4                           581  ** -----------------------------------------------------------
000015B4                           582  SR_DSP_DISPLAY
000015B4                           583                      ** Output buffer
000015B4                           584                      **   Need buffer for spacing issues
000015B4                           585                      **
000015B4  47F9 00002D60            586                      LEA     opOutBuf,A3             * Reset pointer to output buffer
000015BA  16BC 0000                587                      MOVE.B  #$00,(A3)               * Insert NULL
000015BE                           588  
000015BE                           589                      ** Push opValAdr to opStrAdr
000015BE  49F9 00002D4E            590                      LEA     opValAdr,A4             * input hex
000015C4  4BF9 00002D52            591                      LEA     opStrAdr,A5             * output string
000015CA  4EB9 000019D4            592                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015D0  49F9 00002D52            593                      LEA     opStrAdr,A4
000015D6  4EB9 00001A06            594                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015DC                           595  
000015DC                           596                      ** Instruction or DATA redirector
000015DC                           597                      **
000015DC  0C39 0001 00002D4D       598                      CMP.B   #1, opErr               * Check instruction type
000015E4  6700 0006                599                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015E8  6000 001E                600                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015EC                           601  
000015EC                           602  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015EC                           603                      **
000015EC                           604  
000015EC                           605                      ** Space
000015EC  49F9 000031BF            606                      LEA     opSpace,A4
000015F2  4EB9 00001A06            607                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F8                           608  
000015F8                           609                      ** Instruction name
000015F8  49F9 00002DDB            610                      LEA     opNam_DATA,A4
000015FE  4EB9 00001A06            611                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001604                           612  
00001604  6000 037E                613                      BRA     Fn_Dsp_Done
00001608                           614  
00001608                           615  Fn_Dsp_Instr        ** Process instruction
00001608                           616                      **
00001608                           617  
00001608                           618                      ** Space
00001608  49F9 000031BF            619                      LEA     opSpace,A4
0000160E  4EB9 00001A06            620                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001614                           621  
00001614                           622                      ** Instruction name
00001614  2879 00002DB0            623                      MOVE.L  opPtrNam,A4
0000161A  4EB9 00001A06            624                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001620                           625  
00001620                           626                      ** Instruciton size
00001620                           627                      **
00001620  0C39 0000 00002DB4       628                      CMP.B   #0,opValSiz
00001628  6700 001E                629                      BEQ     Fn_DSP_SizB             * Size is Byte
0000162C  0C39 0001 00002DB4       630                      CMP.B   #1,opValSiz
00001634  6700 0022                631                      BEQ     Fn_DSP_SizW             * Size is Word
00001638  0C39 0002 00002DB4       632                      CMP.B   #2,opValSiz
00001640  6700 0026                633                      BEQ     Fn_DSP_SizL             * Size is Long
00001644  6000 003E                634                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001648                           635  
00001648  49F9 00002E4C            636  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000164E  4EB9 00001A06            637                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001654  6000 0022                638                      BRA     Fn_DSP_OPR1
00001658                           639  
00001658  49F9 00002E4F            640  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000165E  4EB9 00001A06            641                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001664  6000 0012                642                      BRA     Fn_DSP_OPR1
00001668                           643  
00001668  49F9 00002E52            644  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000166E  4EB9 00001A06            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001674  6000 0002                646                      BRA     Fn_DSP_OPR1
00001678                           647  
00001678                           648  Fn_DSP_OPR1         ** Display First Operand
00001678  49F9 000031C2            649                      LEA     opTab,A4                * Tab (or calculated spaces)
0000167E  4EB9 00001A06            650                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001684                           651  
00001684                           652  Fn_DSP_DTA1         ** Data 1 (source)
00001684                           653                      ** **************************************************
00001684                           654                      **
00001684                           655  
00001684                           656                      ** Check if source mode set (may not have a source)
00001684  0C39 00FF 00002DBA       657                      CMP.B   #$FF,opDta1
0000168C  6700 017C                658                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
00001690                           659  
00001690                           660                      ** Check source mode
00001690                           661                      **
00001690  0C39 0000 00002DB8       662                      CMP.B   #0,opSrcMod
00001698  6700 0042                663                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000169C  0C39 0001 00002DB8       664                      CMP.B   #1,opSrcMod
000016A4  6700 004A                665                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
000016A8  0C39 0002 00002DB8       666                      CMP.B   #2,opSrcMod
000016B0  6700 0052                667                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
000016B4  0C39 0003 00002DB8       668                      CMP.B   #3,opSrcMod
000016BC  6700 0062                669                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
000016C0  0C39 0004 00002DB8       670                      CMP.B   #4,opSrcMod
000016C8  6700 0076                671                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016CC  0C39 0007 00002DB8       672                      CMP.B   #7,opSrcMod
000016D4  6700 008A                673                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016D8                           674  
000016D8  6000 0114                675                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016DC                           676  
000016DC                           677  Fn_DSP_DTA1_00      ** Handling data mode 0
000016DC  16FC 0044                678                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016E0  1639 00002DB7            679                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016E6  0603 0030                680                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016EA  16C3                     681                      MOVE.B  D3,(A3)+                * Insert Register value
000016EC  6000 0110                682                      BRA     Fn_DSP_OPR2             * Display data 2
000016F0                           683  
000016F0                           684  Fn_DSP_DTA1_01      ** Handling data mode 1
000016F0  16FC 0041                685                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016F4  1639 00002DB7            686                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016FA  0603 0030                687                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016FE  16C3                     688                      MOVE.B  D3,(A3)+                * Insert Register value
00001700  6000 00FC                689                      BRA     Fn_DSP_OPR2             * Display data 2
00001704                           690  
00001704                           691  Fn_DSP_DTA1_02      ** Handling data mode 2
00001704  16FC 0028                692                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001708  16FC 0041                693                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000170C  1639 00002DB7            694                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001712  0603 0030                695                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001716  16C3                     696                      MOVE.B  D3,(A3)+                * Insert Register value
00001718  16FC 0029                697                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000171C  6000 00E0                698                      BRA     Fn_DSP_OPR2             * Display data 2
00001720                           699  
00001720                           700  Fn_DSP_DTA1_03      ** Handling data mode 3
00001720  16FC 0028                701                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001724  16FC 0041                702                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001728  1639 00002DB7            703                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000172E  0603 0030                704                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001732  16C3                     705                      MOVE.B  D3,(A3)+                * Insert Register value
00001734  16FC 0029                706                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001738  16FC 002B                707                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000173C  6000 00C0                708                      BRA     Fn_DSP_OPR2             * Display data 2
00001740                           709  
00001740                           710  Fn_DSP_DTA1_04      ** Handling data mode 4
00001740  16FC 002D                711                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001744  16FC 0028                712                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001748  16FC 0041                713                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000174C  1639 00002DB7            714                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001752  0603 0030                715                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001756  16C3                     716                      MOVE.B  D3,(A3)+                * Insert Register value
00001758  16FC 0029                717                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000175C  6000 00A0                718                      BRA     Fn_DSP_OPR2             * Display data 2
00001760                           719  
00001760                           720  Fn_DSP_DTA1_07      ** Handling data mode 7
00001760  0C39 0000 00002DBE       721                      CMP.B   #0,opDta1T
00001768  6700 001E                722                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000176C  0C39 0001 00002DBE       723                      CMP.B   #1,opDta1T
00001774  6700 0034                724                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001778  0C39 0002 00002DBE       725                      CMP.B   #2,opDta1T
00001780  6700 004A                726                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001784                           727  
00001784  6000 0068                728                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001788                           729  
00001788                           730  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001788  49F9 00002DBA            731                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002DC5            732                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019D4            733                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002DC5            734                      LEA     opStrDtaWrd,A4
000017A0  4EB9 00001A06            735                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0056                736                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           737  
000017AA                           738  Fn_DSP_DTA1_WRD     ** Display data Word
000017AA  49F9 00002DBA            739                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002DC5            740                      LEA     opStrDtaWrd,A5          * output string
000017B6  4EB9 000019D4            741                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002DC5            742                      LEA     opStrDtaWrd,A4
000017C2  4EB9 00001A06            743                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0034                744                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           745  
000017CC                           746  Fn_DSP_DTA1_LNG     ** Display data Long
000017CC  49F9 00002DBA            747                      LEA     opDta1,A4               * input hex
000017D2  4BF9 00002DCA            748                      LEA     opStrDtaLng,A5          * output string
000017D8  4EB9 000019D4            749                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017DE  49F9 00002DCA            750                      LEA     opStrDtaLng,A4
000017E4  4EB9 00001A06            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017EA  6000 0012                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017EE                           753  
000017EE                           754  Fn_DSP_DTA1_ERR     ** Something is messed up
000017EE  49F9 00002EA6            755                      LEA     msgErr,A4
000017F4  4EB9 00001A06            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017FA  6000 0002                757                      BRA     Fn_DSP_OPR2             * Display data 2
000017FE                           758  
000017FE                           759  Fn_DSP_OPR2         ** Display Second Operand
000017FE  49F9 000031BB            760                      LEA     opComma,A4              * Comma
00001804  4EB9 00001A06            761                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000180A                           762  
0000180A                           763  Fn_DSP_DTA2         ** Data 2 (destination)
0000180A                           764                      ** **************************************************
0000180A                           765                      **
0000180A                           766  
0000180A                           767                      ** Check if destination mode set (may not have a destination)
0000180A  0C39 00FF 00002DB6       768                      CMP.B   #$FF,opDstMod
00001812  6700 0170                769                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
00001816                           770  
00001816  0C39 0000 00002DB6       771                      CMP.B   #0,opDstMod
0000181E  6700 0042                772                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001822  0C39 0001 00002DB6       773                      CMP.B   #1,opDstMod
0000182A  6700 004A                774                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000182E  0C39 0002 00002DB6       775                      CMP.B   #2,opDstMod
00001836  6700 0052                776                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
0000183A  0C39 0003 00002DB6       777                      CMP.B   #3,opDstMod
00001842  6700 0062                778                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001846  0C39 0004 00002DB6       779                      CMP.B   #4,opDstMod
0000184E  6700 0076                780                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001852  0C39 0007 00002DB6       781                      CMP.B   #7,opDstMod
0000185A  6700 008A                782                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000185E                           783  
0000185E  6000 0114                784                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001862                           785  
00001862                           786  Fn_DSP_DTA2_00      ** Handling mode 0
00001862  16FC 0044                787                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001866  1639 00002DB5            788                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000186C  0603 0030                789                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001870  16C3                     790                      MOVE.B  D3,(A3)+                * Insert Register value
00001872  6000 0110                791                      BRA     Fn_DSP_DONE             * Done with display
00001876                           792  
00001876                           793  Fn_DSP_DTA2_01      ** Handling mode 1
00001876  16FC 0041                794                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000187A  1639 00002DB5            795                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001880  0603 0030                796                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001884  16C3                     797                      MOVE.B  D3,(A3)+                * Insert Register value
00001886  6000 00FC                798                      BRA     Fn_DSP_DONE             * Done with display
0000188A                           799  
0000188A                           800  Fn_DSP_DTA2_02      ** Handling mode 2
0000188A  16FC 0028                801                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000188E  16FC 0041                802                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001892  1639 00002DB5            803                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001898  0603 0030                804                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000189C  16C3                     805                      MOVE.B  D3,(A3)+                * Insert Register value
0000189E  16FC 0029                806                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018A2  6000 00E0                807                      BRA     Fn_DSP_DONE             * Done with display
000018A6                           808  
000018A6                           809  Fn_DSP_DTA2_03      ** Handling mode 3
000018A6  16FC 0028                810                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AA  16FC 0041                811                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018AE  1639 00002DB5            812                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
000018B4  0603 0030                813                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018B8  16C3                     814                      MOVE.B  D3,(A3)+                * Insert Register value
000018BA  16FC 0029                815                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018BE  16FC 002B                816                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018C2  6000 00C0                817                      BRA     Fn_DSP_DONE             * Done with display
000018C6                           818  
000018C6                           819  Fn_DSP_DTA2_04      ** Handling mode 4
000018C6  16FC 002D                820                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018CA  16FC 0028                821                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018CE  16FC 0041                822                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018D2  1639 00002DB7            823                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018D8  0603 0030                824                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018DC  16C3                     825                      MOVE.B  D3,(A3)+                * Insert Register value
000018DE  16FC 0029                826                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018E2  6000 00A0                827                      BRA     Fn_DSP_DONE             * Done with display
000018E6                           828  
000018E6                           829  Fn_DSP_DTA2_07      ** Handling mode 8
000018E6  0C39 0000 00002DC4       830                      CMP.B   #0,opDta2T
000018EE  6700 001E                831                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018F2  0C39 0001 00002DC4       832                      CMP.B   #1,opDta2T
000018FA  6700 0034                833                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018FE  0C39 0002 00002DC4       834                      CMP.B   #2,opDta2T
00001906  6700 004A                835                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
0000190A                           836  
0000190A  6000 0068                837                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
0000190E                           838  
0000190E                           839  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
0000190E  49F9 00002DC0            840                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002DC5            841                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019D4            842                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002DC5            843                      LEA     opStrDtaWrd,A4
00001926  4EB9 00001A06            844                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0056                845                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           846  
00001930                           847  Fn_DSP_DTA2_WRD     ** Display data Word
00001930  49F9 00002DC0            848                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002DC5            849                      LEA     opStrDtaWrd,A5          * output string
0000193C  4EB9 000019D4            850                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002DC5            851                      LEA     opStrDtaWrd,A4
00001948  4EB9 00001A06            852                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0034                853                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           854  
00001952                           855  Fn_DSP_DTA2_LNG     ** Display data Long
00001952  49F9 00002DC0            856                      LEA     opDta2,A4               * input hex
00001958  4BF9 00002DCA            857                      LEA     opStrDtaLng,A5          * output string
0000195E  4EB9 000019D4            858                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001964  49F9 00002DCA            859                      LEA     opStrDtaLng,A4
0000196A  4EB9 00001A06            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001970  6000 0012                861                      BRA     Fn_DSP_DONE             * Display data 2
00001974                           862  
00001974                           863  Fn_DSP_DTA2_ERR     ** Something is messed up
00001974  49F9 00002EA6            864                      LEA     msgErr,A4
0000197A  4EB9 00001A06            865                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001980  6000 0002                866                      BRA     Fn_DSP_DONE             * Display data 2
00001984                           867  
00001984                           868  Fn_Dsp_Done         ** Done with instruction display
00001984  16BC 0000                869                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001988  43F9 00002D60            870                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000198E  103C 000D                871                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001992  4E4F                     872                      TRAP    #15
00001994                           873  
00001994                           874                      ** We're all done here - time to go
00001994                           875                      **
00001994  4E75                     876                      RTS                             * Return back to caller
00001996                           877  
00001996                           878  ** -----------------------------------------------------------
00001996                           879  ** Convert single ASCII value to hexadecimal
00001996                           880  **    ASCII values should be in range 0-9, A-F
00001996                           881  **
00001996                           882  ** Parameters
00001996                           883  **   D5 - Hex value to assess. Converted value returned in D5
00001996                           884  **
00001996                           885  ** Example:
00001996                           886  **   $30 -> $0
00001996                           887  **   $41 -> $A
00001996                           888  **   $61 -> $A
00001996                           889  ** -----------------------------------------------------------
00001996                           890  SR_ASCII_HEX
00001996  BA3C 0039                891                      CMP.B   #$39,D5
0000199A  6F00 000E                892                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000199E  BA3C 0046                893                      CMP.B   #$46,D5
000019A2  6F00 000C                894                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
000019A6  6000 000E                895                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
000019AA                           896  
000019AA  0405 0030                897  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
000019AE  4E75                     898                      RTS
000019B0  0405 0037                899  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
000019B4  4E75                     900                      RTS
000019B6  0405 0057                901  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
000019BA  4E75                     902                      RTS
000019BC                           903  
000019BC                           904  ** -----------------------------------------------------------
000019BC                           905  ** Convert single hexadecimal value to ASCII
000019BC                           906  **    hexadecimal values should be in range 0-9, A-F
000019BC                           907  **
000019BC                           908  ** Parameters
000019BC                           909  **   D5 - Hex value to assess. Converted value returned in D5
000019BC                           910  **
000019BC                           911  ** Example:
000019BC                           912  **   $0 -> $30
000019BC                           913  **   $A -> $41
000019BC                           914  **   $a -> $41
000019BC                           915  **
000019BC                           916  ** Note: this function is case insensitive an $a = $A = $41 etc.
000019BC                           917  ** -----------------------------------------------------------
000019BC                           918  SR_HEX_ASCII
000019BC  BA3C 0009                919                      CMP.B   #$9,D5
000019C0  6F00 0006                920                      BLE     Fn_HEX_Num              * Hex $0-$9
000019C4  6000 0008                921                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019C8                           922  
000019C8  0605 0030                923  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019CC  4E75                     924                      RTS
000019CE  0605 0037                925  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019D2  4E75                     926                      RTS
000019D4                           927  
000019D4                           928  ** -----------------------------------------------------------
000019D4                           929  ** Copy hexadecimal value to string
000019D4                           930  **
000019D4                           931  ** Parameters
000019D4                           932  **   A4 - Pointer to value copying from
000019D4                           933  **   A5 - Pointer to defined constant
000019D4                           934  **
000019D4                           935  ** Data registers
000019D4                           936  **   D4 - Current byte      (hex value A4)
000019D4                           937  **   D5 - Temp byte         (hex value or string)
000019D4                           938  **   D6 - Number to shift
000019D4                           939  **
000019D4                           940  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019D4                           941  **
000019D4                           942  ** -----------------------------------------------------------
000019D4                           943  SR_HEX_STR
000019D4                           944  
000019D4  181C                     945  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019D6                           946  
000019D6  1A15                     947                      MOVE.B  (A5),D5
000019D8  BA3C 0000                948                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019DC  6700 0022                949                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019E0                           950  
000019E0                           951                      ** First Hex value (high order value)
000019E0  1A04                     952                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019E2  1C3C 0004                953                      MOVE.B  #4,D6
000019E6  EC2D                     954                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019E8  4EB8 19BC                955                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019EC  1AC5                     956                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019EE                           957  
000019EE                           958                      ** Second Hex value (low order value)
000019EE  1A04                     959                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019F0  1C3C 0004                960                      MOVE.B  #4,D6
000019F4  ED2D                     961                      LSL.B   D6,D5
000019F6  EC2D                     962                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019F8  4EB8 19BC                963                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019FC  1AC5                     964                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019FE                           965  
000019FE  60D4                     966                      BRA     Fn_Hex_Str_Loop
00001A00                           967  Fn_Hex_Str_Done
00001A00  1AFC 0000                968                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
00001A04                           969  
00001A04  4E75                     970                      RTS
00001A06                           971  
00001A06                           972  ** -----------------------------------------------------------
00001A06                           973  ** Copy string to output buffer @ A3
00001A06                           974  **
00001A06                           975  ** Parameters
00001A06                           976  **   A4 - Pointer to string copying from
00001A06                           977  **
00001A06                           978  ** Data registers
00001A06                           979  **   D5 - Temp byte         (hex value or string)
00001A06                           980  ** -----------------------------------------------------------
00001A06                           981  SR_CPY_STR_BUF
00001A06                           982  
00001A06  1A14                     983  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
00001A08  BA3C 0000                984                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
00001A0C  6700 0006                985                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
00001A10                           986  
00001A10  16DC                     987                      MOVE.B  (A4)+,(A3)+
00001A12  60F2                     988                      BRA     Fn_CPY_STR_Loop
00001A14                           989  
00001A14  4E75                     990  Fn_CPY_STR_Done     RTS
00001A16                           991  
00001A16                           992  ** -----------------------------------------------------------
00001A16                           993  ** Length of string output buffer
00001A16                           994  ** -----------------------------------------------------------
00001A16                           995  SR_CNT_STR_BUF
00001A16                           996  
00001A16  4E75                     997                      RTS
00001A18                           998  
00001A18                           999  ** -----------------------------------------------------------
00001A18                          1000  ** Includes: Subroutines etc.
00001A18                          1001  ** -----------------------------------------------------------
00001A18                          1002                      INCLUDE 'SR_IDX.X68'
00001A18                          1003  
00001A18                          1004  
00001A18                          1005  SR_IDX
00001A18                          1006  
00001A18  4E75                    1007                RTS
00001A18  4E75                    1008  -------------------- end include --------------------
00001A1A                          1009                      INCLUDE 'SR_ID3.X68'
00001A1A                          1010  
00001A1A                          1011  
00001A1A                          1012  SR_ID3
00001A1A                          1013  
00001A1A                          1014                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
00001A1A                          1015  
00001A1A                          1016  
00001A1A                          1017                      ** ***************************************
00001A1A                          1018                      ** Read first 4 bits
00001A1A                          1019                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
00001A1A                          1020                      ** Note: most instructions will be in this format 3,3,3,3
00001A1A                          1021                      **    I think there is only one instrction that is 4,8
00001A1A                          1022                      **
00001A1A                          1023                      ** ***************************************
00001A1A  3639 00002D4A           1024                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A20  183C 000C               1025                      MOVE.B  #12,D4
00001A24  E86B                    1026                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A26  13C3 00002D4C           1027                      MOVE.B  D3, opID
00001A2C                          1028  
00001A2C                          1029                      ** Read next 3 bits
00001A2C                          1030                      **
00001A2C  3639 00002D4A           1031                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A32  183C 0004               1032                      MOVE.B  #4, D4
00001A36  E96B                    1033                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A38  183C 000D               1034                      MOVE.B  #13,D4
00001A3C  E86B                    1035                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A3E  13C3 00002DB5           1036                      MOVE.B  D3, opDstReg
00001A44                          1037  
00001A44                          1038                      ** Read next 3 bits
00001A44                          1039                      **
00001A44  3639 00002D4A           1040                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A4A  183C 0007               1041                      MOVE.B  #7, D4
00001A4E  E96B                    1042                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A50  183C 000D               1043                      MOVE.B  #13,D4
00001A54  E86B                    1044                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A56  13C3 00002DB6           1045                      MOVE.B  D3, opDstMod
00001A5C                          1046  
00001A5C                          1047                      ** Read next 3 bits
00001A5C                          1048                      **
00001A5C  3639 00002D4A           1049                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A62  183C 000A               1050                      MOVE.B  #10, D4
00001A66  E96B                    1051                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A68  183C 000D               1052                      MOVE.B  #13,D4
00001A6C  E86B                    1053                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A6E  13C3 00002DB8           1054                      MOVE.B  D3, opSrcMod
00001A74                          1055  
00001A74                          1056                      ** Read next 3 bits
00001A74                          1057                      **
00001A74  3639 00002D4A           1058                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A7A  183C 000D               1059                      MOVE.B  #13, D4
00001A7E  E96B                    1060                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A80  183C 000D               1061                      MOVE.B  #13,D4
00001A84  E86B                    1062                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A86  13C3 00002DB7           1063                      MOVE.B  D3, opSrcReg
00001A8C                          1064  
00001A8C                          1065                      ** ***************************************
00001A8C                          1066                      ** Verify this is MOVE or MOVEA
00001A8C                          1067                      **
00001A8C                          1068                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A8C                          1069                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A8C                          1070                      **
00001A8C                          1071                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A8C                          1072                      **
00001A8C                          1073                      ** ***************************************
00001A8C  0C39 0001 00002DB6      1074                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A94  6700 0016               1075                      BEQ     Fn_ID3_Ins02                * Set as instruction 0 MOVEA
00001A98  6000 0002               1076                      BRA     Fn_ID3_Ins01                * Set as instruction 1 MOVE
00001A9C                          1077  
00001A9C  47F9 00002DE0           1078  Fn_ID3_Ins01        LEA     opNam_MOVE,A3
00001AA2  23CB 00002DB0           1079                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA8  6000 001A               1080                      BRA     Fn_ID3_Verify
00001AAC                          1081  
00001AAC  0C39 0001 00002D4C      1082  Fn_ID3_Ins02        CMP.B   #1, opID
00001AB4  6700 01A4               1083                      BEQ     Fn_ID3_Error               * MOVEA cannot have opID = 1 (byte)
00001AB8  47F9 00002DE5           1084                      LEA     opNam_MOVEA,A3
00001ABE  23CB 00002DB0           1085                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AC4                          1086  
00001AC4                          1087                      ** ***************************************
00001AC4                          1088                      ** Verify other instruction parameters are correct
00001AC4                          1089                      **
00001AC4                          1090                      **    DstMod = 0 to 7
00001AC4                          1091                      **    DstReg = 0 to 7
00001AC4                          1092                      **    SrcMod = 0 to 7
00001AC4                          1093                      **    SrcReg = 0 to 7
00001AC4                          1094                      **
00001AC4                          1095                      ** ***************************************
00001AC4  0C39 0000 00002DB6      1096  Fn_ID3_Verify       CMP.B   #0, opDstMod                * Destination mode is >= 0
00001ACC  6D00 018C               1097                      BLT     Fn_ID3_Error
00001AD0  0C39 0007 00002DB6      1098                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AD8  6E00 0180               1099                      BGT     Fn_ID3_Error
00001ADC  0C39 0000 00002DB5      1100                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AE4  6D00 0174               1101                      BLT     Fn_ID3_Error
00001AE8  0C39 0007 00002DB5      1102                      CMP.B   #7, opDstReg                * Destination register <= 7
00001AF0  6E00 0168               1103                      BGT     Fn_ID3_Error
00001AF4                          1104  
00001AF4  0C39 0000 00002DB8      1105                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001AFC  6D00 015C               1106                      BLT     Fn_ID3_Error
00001B00  0C39 0007 00002DB8      1107                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001B08  6E00 0150               1108                      BGT     Fn_ID3_Error
00001B0C  0C39 0000 00002DB7      1109                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001B14  6D00 0144               1110                      BLT     Fn_ID3_Error
00001B18  0C39 0007 00002DB7      1111                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001B20  6E00 0138               1112                      BGT     Fn_ID3_Error
00001B24                          1113  
00001B24                          1114                      ** ***************************************
00001B24                          1115                      ** Set instruction size - the .B,.W,.L part
00001B24                          1116                      ** Note: size set by opID only for MOVE, MOVEA
00001B24                          1117                      **       other instructions use 3 bits for size
00001B24                          1118                      ** ***************************************
00001B24  0C39 0001 00002D4C      1119                      CMP.B   #1, opID                    * Instruction size is Byte
00001B2C  6700 001A               1120                      BEQ     Fn_ID3_SizB
00001B30  0C39 0003 00002D4C      1121                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B38  6700 001A               1122                      BEQ     Fn_ID3_SizW
00001B3C  0C39 0002 00002D4C      1123                      CMP.B   #2, opID                    * Instruction size is Long
00001B44  6700 001A               1124                      BEQ     Fn_ID3_SizL
00001B48  13FC 0000 00002DB4      1125  Fn_ID3_SizB         MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B50  6000 001A               1126                      BRA     Fn_ID3_SrcMod
00001B54  13FC 0001 00002DB4      1127  Fn_ID3_SizW         MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B5C  6000 000E               1128                      BRA     Fn_ID3_SrcMod
00001B60  13FC 0002 00002DB4      1129  Fn_ID3_SizL         MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B68  6000 0002               1130                      BRA     Fn_ID3_SrcMod
00001B6C                          1131  
00001B6C                          1132                      ** ***************************************
00001B6C                          1133                      ** Grab extra DATA if needed
00001B6C                          1134                      **
00001B6C                          1135                      **    If DstMod = 7
00001B6C                          1136                      **       DstReg = 0 (get Word)
00001B6C                          1137                      **       DstReg = 1 (get Long)
00001B6C                          1138                      **
00001B6C                          1139                      **    If SrcMod = 7
00001B6C                          1140                      **       SrcReg = 0 (get Word)
00001B6C                          1141                      **       SrcReg = 1 (get Long)
00001B6C                          1142                      **       SrcReg = 4
00001B6C                          1143                      **          MOVE.B, MOVE.W (get Word)
00001B6C                          1144                      **          MOVE.L         (get Long)
00001B6C                          1145                      **
00001B6C                          1146                      ** SOURCE
00001B6C                          1147                      **
00001B6C                          1148                      ** ***************************************
00001B6C  0C39 0007 00002DB8      1149  Fn_ID3_SrcMod       CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B74  6700 0006               1150                      BEQ     Fn_ID3_ChkSrcReg            * Check source register
00001B78  6000 0088               1151                      BRA     Fn_ID3_ChkDstMod           * Source not 7, now check destination Mod
00001B7C  0C39 0000 00002DB7      1152  Fn_ID3_ChkSrcReg    CMP.B   #0, opSrcReg                 * Check is source register is 0
00001B84  6700 0058               1153                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001B88  0C39 0001 00002DB7      1154                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B90  6700 005E               1155                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001B94  0C39 0004 00002DB7      1156                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B9C  6700 0006               1157                      BEQ     Fn_ID3_DtaSrcImd            * Load first word into word one
00001BA0  6000 00B8               1158                      BRA     FN_ID3_Error                * Invalid register value
00001BA4                          1159  
00001BA4                          1160                      ** Note: Checking immediate value
00001BA4                          1161                      **       opID as size is specific to MOVE, MOVEA
00001BA4                          1162                      **       other instructions will use 3 bits to set size, not part of ID
00001BA4                          1163                      **
00001BA4  0C39 0001 00002D4C      1164  Fn_ID3_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00001BAC  6700 001E               1165                      BEQ     Fn_ID3_DtaSrcByt            * Load next byte
00001BB0  0C39 0003 00002D4C      1166                      CMP.B   #3, opID                    * opID = 3 - size is word
00001BB8  6700 0024               1167                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001BBC  0C39 0002 00002D4C      1168                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BC4  6700 002A               1169                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001BC8  6000 0090               1170                      BRA     Fn_ID3_Error                * Invalid opID (this should never happen)
00001BCC                          1171  
00001BCC  33DA 00002DBA           1172  Fn_ID3_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BD2  13FC 0000 00002DBE      1173                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BDA  6000 0026               1174                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BDE  33DA 00002DBA           1175  Fn_ID3_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BE4  13FC 0001 00002DBE      1176                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BEC  6000 0014               1177                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BF0  23DA 00002DBA           1178  Fn_ID3_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BF6  13FC 0002 00002DBE      1179                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BFE  6000 0002               1180                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001C02                          1181  
00001C02                          1182                      ** DESTINATION
00001C02                          1183                      **
00001C02  0C39 0007 00002DB6      1184  Fn_ID3_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00001C0A  6700 0006               1185                      BEQ     Fn_ID3_ChkDstReg            * Check destination register
00001C0E  6000 0042               1186                      BRA     Fn_ID3_Done                 * Destination not 7, done with data
00001C12  0C39 0000 00002DB5      1187  Fn_ID3_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00001C1A  6700 0012               1188                      BEQ     Fn_ID3_DtaDstWrd            * Load next word
00001C1E  0C39 0001 00002DB5      1189                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C26  6700 0018               1190                      BEQ     Fn_ID3_DtaDstLng            * Load next long
00001C2A  6000 002E               1191                      BRA     fn_ID3_Error                * Invalid registration Mode
00001C2E                          1192  
00001C2E  33DA 00002DC0           1193  Fn_ID3_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C34  13FC 0001 00002DC4      1194                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C3C  6000 0014               1195                      BRA     Fn_ID3_Done
00001C40  23DA 00002DC0           1196  Fn_ID3_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C46  13FC 0002 00002DC4      1197                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C4E  6000 0002               1198                      BRA     Fn_ID3_Done
00001C52                          1199  
00001C52  13FC 0000 00002D4D      1200  Fn_ID3_Done         MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C5A                          1201  
00001C5A                          1202  Fn_ID3_Error                                           * Exit out if error - main subroutine will handle DATA
00001C5A                          1203                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C5A  4E75                    1204                      RTS                                 * Return to main
00001C5A  4E75                    1205  -------------------- end include --------------------
00001C5C                          1206                      INCLUDE 'SR_ID4.X68'
00001C5C                          1207  
00001C5C                          1208  SR_ID4              * This is to grab the first four that are already set, ID4
00001C5C  3639 00002D4A           1209                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C62  183C 000C               1210                      MOVE.B  #12,D4
00001C66  E86B                    1211                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C68  13C3 00002D4C           1212                      MOVE.B  D3, opID        
00001C6E                          1213                      
00001C6E                          1214                      * Read next 3 bits into D3
00001C6E  3639 00002D4A           1215                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C74  183C 0004               1216                      MOVE.B  #4, D4
00001C78  E96B                    1217                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C7A  183C 000D               1218                      MOVE.B  #13,D4
00001C7E  E86B                    1219                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C80  13C3 00002DB5           1220                      MOVE.B  D3, opDstReg
00001C86                          1221                      
00001C86                          1222                      * Read next 3 bits into D3
00001C86  3639 00002D4A           1223                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C8C  183C 0007               1224                      MOVE.B  #7, D4
00001C90  E96B                    1225                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C92  183C 000D               1226                      MOVE.B  #13,D4
00001C96  E86B                    1227                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C98  13C3 00002DB6           1228                      MOVE.B  D3, opDstMod
00001C9E                          1229  
00001C9E                          1230                      ** Read next 3 bits
00001C9E                          1231                      **
00001C9E  3639 00002D4A           1232                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CA4  183C 000A               1233                      MOVE.B  #10, D4
00001CA8  E96B                    1234                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CAA  183C 000D               1235                      MOVE.B  #13,D4
00001CAE  E86B                    1236                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CB0  13C3 00002DB8           1237                      MOVE.B  D3, opSrcMod
00001CB6                          1238  
00001CB6                          1239                      ** Read next 3 bits
00001CB6                          1240                      **
00001CB6  3639 00002D4A           1241                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CBC  183C 000D               1242                      MOVE.B  #13, D4
00001CC0  E96B                    1243                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CC2  183C 000D               1244                      MOVE.B  #13,D4
00001CC6  E86B                    1245                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CC8  13C3 00002DB7           1246                      MOVE.B  D3, opSrcReg
00001CCE                          1247                      
00001CCE                          1248                      ** ***************************************
00001CCE                          1249                      ** Verify instruction
00001CCE                          1250                      **
00001CCE                          1251                      ** JSR: If DstReg=7, DstMod=2 
00001CCE                          1252                      ** LEA: If DstReg=0-7, DstMod=7
00001CCE                          1253                      ** MOVEM:
00001CCE                          1254                      **    RegToMem: DestReg=4, DestMod=2,3
00001CCE                          1255                      **    MemToReg: DestReg=6, DestMod=2,3
00001CCE                          1256                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CCE                          1257                      ** NOT: If DstReg=3, DstMod=0-2
00001CCE                          1258                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CCE                          1259                      **
00001CCE                          1260                      ** ***************************************
00001CCE  0C39 0000 00002DB6      1261                      CMP.B   #0, opDstMod
00001CD6  6700 02EA               1262                      BEQ     Fn_ID4_NOT
00001CDA  0C39 0001 00002DB6      1263                      CMP.B   #1, opDstMod
00001CE2  6700 002A               1264                      BEQ     Fn_ID4_CheckD1
00001CE6  0C39 0002 00002DB6      1265                      CMP.B   #2, opDstMod
00001CEE  6700 0042               1266                      BEQ     Fn_ID4_CheckD2
00001CF2  0C39 0003 00002DB6      1267                      CMP.B   #3, opDstMod
00001CFA  6700 0066               1268                      BEQ     Fn_ID4_CheckD3
00001CFE  0C39 0007 00002DB6      1269                      CMP.B   #7, opDstMod
00001D06  6700 011E               1270                      BEQ     Fn_ID4_LEA
00001D0A  6000 0472               1271                      BRA     Fn_ID4_Error
00001D0E                          1272                      
00001D0E                          1273  Fn_ID4_CheckD1
00001D0E  0C39 0003 00002DB5      1274                      CMP.B   #3, opDstReg
00001D16  6700 02AA               1275                      BEQ     Fn_ID4_NOT
00001D1A  0C39 0001 00002DB7      1276                      CMP.B   #1, opSrcReg
00001D22  6700 025E               1277                      BEQ     Fn_ID4_NOP
00001D26  0C39 0005 00002DB7      1278                      CMP.B   #5, opSrcReg
00001D2E  6700 02E8               1279                      BEQ     Fn_ID4_RTS
00001D32                          1280                      
00001D32                          1281  Fn_ID4_CheckD2
00001D32  0C39 0003 00002DB5      1282                      CMP.B   #3, opDstReg
00001D3A  6700 0286               1283                      BEQ     Fn_ID4_NOT
00001D3E  0C39 0004 00002DB5      1284                      CMP.B   #4, opDstReg
00001D46  6700 014E               1285                      BEQ     Fn_ID4_MOVEMRTOM
00001D4A  0C39 0006 00002DB5      1286                      CMP.B   #6, opDstReg
00001D52  6700 01B2               1287                      BEQ     Fn_ID4_MOVEMMTOR
00001D56  0C39 0007 00002DB5      1288                      CMP.B   #7, opDstReg
00001D5E  6700 001A               1289                      BEQ     Fn_ID4_JSR
00001D62                          1290  Fn_ID4_CheckD3
00001D62  0C39 0004 00002DB5      1291                      CMP.B   #4, opDstReg
00001D6A  6700 012A               1292                      BEQ     Fn_ID4_MOVEMRTOM
00001D6E  0C39 0006 00002DB5      1293                      CMP.B   #6, opDstReg
00001D76  6700 018E               1294                      BEQ     Fn_ID4_MOVEMMTOR
00001D7A                          1295  
00001D7A  47F9 00002E01           1296  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D80  23CB 00002DB0           1297                      MOVE.L  A3, opPtrNam
00001D86                          1298                      
00001D86  0C39 0007 00002DB5      1299  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D8E  6600 03EE               1300                      BNE     Fn_ID4_Error
00001D92  0C39 0002 00002DB6      1301                      CMP.B   #2, opDstMod
00001D9A  6600 03E2               1302                      BNE     Fn_ID4_Error
00001D9E                          1303                      
00001D9E                          1304                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D9E  0C39 0000 00002DB5      1305                      CMP.B   #0, opDstReg
00001DA6  6700 03D6               1306                      BEQ     Fn_ID4_Error
00001DAA  0C39 0001 00002DB5      1307                      CMP.B   #1, opDstReg
00001DB2  6700 03CA               1308                      BEQ     Fn_ID4_Error
00001DB6  0C39 0003 00002DB5      1309                      CMP.B   #3, opDstReg
00001DBE  6700 03BE               1310                      BEQ     Fn_ID4_Error
00001DC2  0C39 0004 00002DB5      1311                      CMP.B   #4, opDstReg
00001DCA  6700 03B2               1312                      BEQ     Fn_ID4_Error
00001DCE                          1313                      
00001DCE                          1314                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DCE  0C39 0000 00002DB8      1315                      CMP.B   #0, opSrcMod
00001DD6  6700 03A6               1316                      BEQ     Fn_ID4_Error
00001DDA  0C39 0001 00002DB8      1317                      CMP.B   #1, opSrcMod
00001DE2  6700 039A               1318                      BEQ     Fn_ID4_Error
00001DE6  0C39 0003 00002DB8      1319                      CMP.B   #3, opSrcMod
00001DEE  6700 038E               1320                      BEQ     Fn_ID4_Error
00001DF2  0C39 0004 00002DB8      1321                      CMP.B   #4, opSrcMod
00001DFA  6700 0382               1322                      BEQ     Fn_ID4_Error
00001DFE                          1323                      
00001DFE                          1324                      * Make sure src reg is between 0-7
00001DFE  0C39 0000 00002DB7      1325                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E06  6D00 0376               1326                      BLT     Fn_ID4_Error
00001E0A  0C39 0007 00002DB7      1327                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E12  6E00 036A               1328                      BGT     Fn_ID4_Error
00001E16                          1329                      
00001E16  0C39 0007 00002DB8      1330  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001E1E  6700 0248               1331                      BEQ     Fn_ID4_Data
00001E22  6000 035C               1332                      BRA     Fn_ID4_Done
00001E26                          1333  
00001E26  47F9 00002DEB           1334  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E2C  23CB 00002DB0           1335                      MOVE.L  A3, opPtrNam
00001E32                          1336                      
00001E32  0C39 0007 00002DB6      1337  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E3A  6600 0342               1338                      BNE     Fn_ID4_Error
00001E3E                          1339                      
00001E3E                          1340                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E3E  0C39 0000 00002DB8      1341                      CMP.B   #0, opSrcMod
00001E46  6700 0336               1342                      BEQ     Fn_ID4_Error
00001E4A  0C39 0001 00002DB8      1343                      CMP.B   #1, opSrcMod
00001E52  6700 032A               1344                      BEQ     Fn_ID4_Error
00001E56  0C39 0003 00002DB8      1345                      CMP.B   #3, opSrcMod
00001E5E  6700 031E               1346                      BEQ     Fn_ID4_Error
00001E62  0C39 0004 00002DB8      1347                      CMP.B   #4, opSrcMod
00001E6A  6700 0312               1348                      BEQ     Fn_ID4_Error
00001E6E                          1349                      
00001E6E                          1350                      * Make sure src reg is between 0-7
00001E6E  0C39 0000 00002DB7      1351                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E76  6D00 0306               1352                      BLT     Fn_ID4_Error
00001E7A  0C39 0007 00002DB7      1353                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E82  6E00 02FA               1354                      BGT     Fn_ID4_Error
00001E86                          1355                      
00001E86  0C39 0007 00002DB8      1356  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E8E  6700 01D8               1357                      BEQ     Fn_ID4_Data
00001E92  6000 02EC               1358                      BRA     Fn_ID4_Done
00001E96                          1359  
00001E96  47F9 00002DF3           1360  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E9C  23CB 00002DB0           1361                      MOVE.L  A3, opPtrNam
00001EA2                          1362                      
00001EA2  0C39 0004 00002DB5      1363  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001EAA  6600 02D2               1364                      BNE     Fn_ID4_Error
00001EAE                          1365                      
00001EAE                          1366                      * Make sure dest mode is only 2 or 3
00001EAE  0C39 0003 00002DB7      1367                      CMP.B   #3, opSrcReg                * Destination register > 2
00001EB6  6D00 02C6               1368                      BLT     Fn_ID4_Error
00001EBA  0C39 0003 00002DB7      1369                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EC2  6E00 02BA               1370                      BGT     Fn_ID4_Error
00001EC6                          1371                      
00001EC6                          1372                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EC6  0C39 0000 00002DB8      1373                      CMP.B   #0, opSrcMod
00001ECE  6700 02AE               1374                      BEQ     Fn_ID4_Error
00001ED2  0C39 0001 00002DB8      1375                      CMP.B   #1, opSrcMod
00001EDA  6700 02A2               1376                      BEQ     Fn_ID4_Error
00001EDE  0C39 0003 00002DB8      1377                      CMP.B   #3, opSrcMod
00001EE6  6700 0296               1378                      BEQ     Fn_ID4_Error
00001EEA                          1379                      
00001EEA                          1380                      * Make sure src reg is between 0-7
00001EEA  0C39 0000 00002DB7      1381                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001EF2  6D00 028A               1382                      BLT     Fn_ID4_Error
00001EF6  0C39 0007 00002DB7      1383                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EFE  6E00 027E               1384                      BGT     Fn_ID4_Error
00001F02  6000 006E               1385                      BRA Fn_ID4_MOVEM_Src
00001F06                          1386  
00001F06  47F9 00002DF3           1387  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001F0C  23CB 00002DB0           1388                      MOVE.L  A3, opPtrNam
00001F12                          1389                      
00001F12  0C39 0006 00002DB5      1390  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001F1A  6600 0262               1391                      BNE     Fn_ID4_Error
00001F1E                          1392                      
00001F1E                          1393                      * Make sure dest mode is only 2 or 3
00001F1E  0C39 0003 00002DB7      1394                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F26  6D00 0256               1395                      BLT     Fn_ID4_Error
00001F2A  0C39 0003 00002DB7      1396                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F32  6E00 024A               1397                      BGT     Fn_ID4_Error
00001F36                          1398                      
00001F36                          1399                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F36  0C39 0000 00002DB8      1400                      CMP.B   #0, opSrcMod
00001F3E  6700 023E               1401                      BEQ     Fn_ID4_Error
00001F42  0C39 0001 00002DB8      1402                      CMP.B   #1, opSrcMod
00001F4A  6700 0232               1403                      BEQ     Fn_ID4_Error
00001F4E  0C39 0003 00002DB8      1404                      CMP.B   #3, opSrcMod
00001F56  6700 0226               1405                      BEQ     Fn_ID4_Error
00001F5A                          1406                      
00001F5A                          1407                      * Make sure src reg is between 0-7
00001F5A  0C39 0000 00002DB7      1408                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F62  6D00 021A               1409                      BLT     Fn_ID4_Error
00001F66  0C39 0007 00002DB7      1410                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F6E  6E00 020E               1411                      BGT     Fn_ID4_Error
00001F72                          1412                      
00001F72  0C39 0007 00002DB8      1413  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F7A  6700 00EC               1414                      BEQ     Fn_ID4_Data
00001F7E  6000 01F4               1415                      BRA     Fn_ID4_GrabMask
00001F82                          1416  
00001F82  47F9 00002DF9           1417  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F88  23CB 00002DB0           1418                      MOVE.L  A3, opPtrNam
00001F8E                          1419  
00001F8E  0C39 0007 00002DB5      1420  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F96  6600 01E6               1421                      BNE     Fn_ID4_Error
00001F9A  0C39 0001 00002DB6      1422                      CMP.B   #1, opDstMod
00001FA2  6600 01DA               1423                      BNE     Fn_ID4_Error
00001FA6  0C39 0006 00002DB8      1424                      CMP.B   #6, opSrcMod
00001FAE  6600 01CE               1425                      BNE     Fn_ID4_Error
00001FB2  0C39 0001 00002DB7      1426                      CMP.B   #1, opSrcReg
00001FBA  6600 01C2               1427                      BNE     Fn_ID4_Error
00001FBE  6000 01C0               1428                      BRA     Fn_ID4_Done
00001FC2                          1429  
00001FC2                          1430  
00001FC2  47F9 00002DEF           1431  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FC8  23CB 00002DB0           1432                      MOVE.L  A3, opPtrNam
00001FCE                          1433                      
00001FCE  0C39 0003 00002DB5      1434  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FD6  6600 01A6               1435                      BNE     Fn_ID4_Error
00001FDA                          1436                      
00001FDA                          1437                      * Make sure src mode is not 1
00001FDA  0C39 0001 00002DB8      1438                      CMP.B   #1, opSrcMod
00001FE2  6700 019A               1439                      BEQ     Fn_ID4_Error
00001FE6                          1440                      
00001FE6                          1441                      * Make sure src reg is between 0-7
00001FE6  0C39 0000 00002DB7      1442                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FEE  6D00 018E               1443                      BLT     Fn_ID4_Error
00001FF2  0C39 0007 00002DB7      1444                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FFA  6E00 0182               1445                      BGT     Fn_ID4_Error
00001FFE                          1446                      
00001FFE  33F9 00002DB6 00002D4C  1447  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00002008  0C39 0007 00002DB8      1448                      CMP.B   #7, opSrcMod
00002010  6700 0056               1449                      BEQ     Fn_ID4_Data
00002014  6000 016A               1450                      BRA     Fn_ID4_Done
00002018                          1451  
00002018  47F9 00002DFD           1452  Fn_ID4_RTS          LEA    opNam_RTS,A3
0000201E  23CB 00002DB0           1453                      MOVE.L A3, opPtrNam
00002024                          1454                      
00002024  0C39 0007 00002DB5      1455  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000202C  6600 0150               1456                      BNE     Fn_ID4_Error
00002030  0C39 0001 00002DB6      1457                      CMP.B   #1, opDstMod
00002038  6600 0144               1458                      BNE     Fn_ID4_Error
0000203C  0C39 0006 00002DB8      1459                      CMP.B   #6, opSrcMod
00002044  6600 0138               1460                      BNE     Fn_ID4_Error
00002048  0C39 0005 00002DB7      1461                      CMP.B   #5, opSrcReg
00002050  6600 012C               1462                      BNE     Fn_ID4_Error
00002054  13FC 00FF 00002DB6      1463              MOVE.B  #$FF, opDstMod
0000205C  13FC 00FF 00002DB8      1464              MOVE.B  #$FF,opSrcMod
00002064  6000 011A               1465                      BRA     Fn_ID4_Done
00002068                          1466  
00002068  0C39 0000 00002DB7      1467  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
00002070  6700 0058               1468                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002074  0C39 0001 00002DB7      1469                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000207C  6700 005E               1470                      BEQ     Fn_ID4_DtaLng               * Load next long
00002080  0C39 0004 00002DB7      1471                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002088  6700 0006               1472                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000208C  6000 00F0               1473                      BRA     FN_ID4_Error                * Invalid register value
00002090                          1474                      
00002090  0C39 0001 00002D4C      1475  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002098  6700 001E               1476                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000209C  0C39 0003 00002D4C      1477                      CMP.B   #3, opID                    * opID = 3 - size is word
000020A4  6700 0024               1478                      BEQ     Fn_ID4_DtaWrd               * Load next word
000020A8  0C39 0002 00002D4C      1479                      CMP.B   #2, opID                    * opID = 0 - size is long
000020B0  6700 002A               1480                      BEQ     Fn_ID4_DtaLng               * Load next
000020B4  6000 00C8               1481                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
000020B8                          1482  
000020B8  33DA 00002DC0           1483  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000020BE  13FC 0000 00002DC4      1484                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000020C6  6000 00B8               1485                      BRA     Fn_ID4_Done
000020CA  33DA 00002DC0           1486  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
000020D0  13FC 0001 00002DC4      1487                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020D8  6000 00A6               1488                      BRA     Fn_ID4_Done
000020DC  23DA 00002DC0           1489  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020E2  13FC 0002 00002DC4      1490                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020EA  6000 0094               1491                      BRA     Fn_ID4_Done
000020EE  0C39 0000 00002DB7      1492  Fn_ID4_Data_MVM     CMP.B   #0, opSrcReg                * Check is source register is 0
000020F6  6700 0058               1493                      BEQ     Fn_ID4_DtaWrd_MVM           * Load next word
000020FA  0C39 0001 00002DB7      1494                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002102  6700 005E               1495                      BEQ     Fn_ID4_DtaLng_MVM           * Load next long
00002106  0C39 0004 00002DB7      1496                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
0000210E  6700 0006               1497                      BEQ     Fn_ID4_DtaImd_MVM           * Load first word into word one
00002112  6000 006A               1498                      BRA     FN_ID4_Error                * Invalid register value
00002116                          1499                      
00002116  0C39 0001 00002D4C      1500  Fn_ID4_DtaImd_MVM   CMP.B   #1, opID                    * opID = 0 - size is byte
0000211E  6700 001E               1501                      BEQ     Fn_ID4_DtaByt_MVM            * Load next byte
00002122  0C39 0003 00002D4C      1502                      CMP.B   #3, opID                     * opID = 3 - size is word
0000212A  6700 0024               1503                      BEQ     Fn_ID4_DtaWrd_MVM            * Load next word
0000212E  0C39 0002 00002D4C      1504                      CMP.B   #2, opID                     * opID = 0 - size is long
00002136  6700 002A               1505                      BEQ     Fn_ID4_DtaLng_MVM            * Load next
0000213A  6000 0042               1506                      BRA     Fn_ID4_Error                 * Invalid opID (this should never happen) long
0000213E                          1507  
0000213E  33DA 00002DC0           1508  Fn_ID4_DtaByt_MVM   MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002144  13FC 0000 00002DC4      1509                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
0000214C  6000 0026               1510                      BRA     Fn_ID4_GrabMask
00002150  33DA 00002DC0           1511  Fn_ID4_DtaWrd_MVM   MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002156  13FC 0001 00002DC4      1512                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
0000215E  6000 0014               1513                      BRA     Fn_ID4_GrabMask
00002162  23DA 00002DC0           1514  Fn_ID4_DtaLng_MVM   MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002168  13FC 0002 00002DC4      1515                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002170  6000 0002               1516                      BRA     Fn_ID4_GrabMask
00002174                          1517              
00002174  33DA 00002DD4           1518  Fn_ID4_GrabMask     MOVE.W  (A2)+, opMask
0000217A  6000 0004               1519              BRA     Fn_ID4_Done
0000217E                          1520  
0000217E                          1521  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
0000217E                          1522                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000217E  4E75                    1523                      RTS                                  * Return to main
00002180                          1524  
00002180  13FC 0000 00002D4D      1525  Fn_ID4_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002188  4E75                    1526              RTS
0000218A                          1527  
0000218A                          1528  
0000218A                          1529  
0000218A                          1530  -------------------- end include --------------------
0000218A                          1531                      INCLUDE 'SR_ID5.X68'
0000218A                          1532  
0000218A                          1533  
0000218A                          1534  SR_ID5              * This is to grab the first four that are already set, ID5
0000218A  3639 00002D4A           1535                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002190  183C 000C               1536                      MOVE.B  #12,D4
00002194  E86B                    1537                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002196  13C3 00002D4C           1538                      MOVE.B  D3, opID        
0000219C                          1539                      
0000219C                          1540                      * Read next 3 bits into D3
0000219C  3639 00002D4A           1541                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021A2  183C 0004               1542                      MOVE.B  #4, D4
000021A6  E96B                    1543                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000021A8  183C 000D               1544                      MOVE.B  #13,D4
000021AC  E86B                    1545                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021AE  13C3 00002DB8           1546                      MOVE.B  D3, opSrcMod
000021B4                          1547                      
000021B4                          1548                      * Read next 3 bits into D3
000021B4  3639 00002D4A           1549                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021BA  183C 0007               1550                      MOVE.B  #7, D4
000021BE  E96B                    1551                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000021C0  183C 000D               1552                      MOVE.B  #13,D4
000021C4  E86B                    1553                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021C6  13C3 00002D4C           1554                      MOVE.B  D3, opID
000021CC                          1555  
000021CC                          1556                      ** Read next 3 bits
000021CC                          1557                      **
000021CC  3639 00002D4A           1558                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021D2  183C 000A               1559                      MOVE.B  #10, D4
000021D6  E96B                    1560                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000021D8  183C 000D               1561                      MOVE.B  #13,D4
000021DC  E86B                    1562                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021DE  13C3 00002DB6           1563                      MOVE.B  D3, opDstMod
000021E4                          1564  
000021E4                          1565                      ** Read next 3 bits
000021E4                          1566                      **
000021E4  3639 00002D4A           1567                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000021EA  183C 000D               1568                      MOVE.B  #13, D4
000021EE  E96B                    1569                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000021F0  183C 000D               1570                      MOVE.B  #13,D4
000021F4  E86B                    1571                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000021F6  13C3 00002DB5           1572                      MOVE.B  D3, opDstReg
000021FC                          1573              
000021FC                          1574              ** Set name
000021FC  47F9 00002E05           1575              LEA     opNam_ADDQ,A3
00002202                          1576              
00002202                          1577  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
00002202  0C39 0000 00002DB8      1578                      CMP.B   #0, opSrcMod                * Destination register >= 0
0000220A  6D00 00E4               1579                      BLT     Fn_ID5_Error
0000220E  0C39 0007 00002DB5      1580                      CMP.B   #7, opDstReg                * Destination register <= 7
00002216  6E00 00D8               1581                      BGT     Fn_ID5_Error
0000221A                          1582              
0000221A                          1583              * Make sure opId  is between 0-2
0000221A  0C39 0000 00002D4C      1584                      CMP.B   #0, opID                    * Destination register >= 0
00002222  6D00 00CC               1585                      BLT     Fn_ID5_Error
00002226  0C39 0002 00002D4C      1586                      CMP.B   #2, opID                    * Destination register <= 2
0000222E  6E00 00C0               1587                      BGT     Fn_ID5_Error
00002232                          1588              
00002232                          1589              * Move data to  appropriate places for printing
00002232  13FC 0007 00002DB8      1590              MOVE.B  #7,opSrcMod
0000223A  13FC 0004 00002DB7      1591              MOVE.B  #4,opSrcReg
00002242                          1592  
00002242                          1593                      ** Note: Checking immediate value
00002242                          1594                      **       opID as size is specific to MOVE, MOVEA
00002242                          1595                      **       other instructions will use 3 bits to set size, not part of ID
00002242                          1596                      **
00002242  0C39 0001 00002D4C      1597  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000224A  6700 001E               1598                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
0000224E  0C39 0003 00002D4C      1599                      CMP.B   #3, opID                    * opID = 3 - size is word
00002256  6700 0024               1600                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
0000225A  0C39 0002 00002D4C      1601                      CMP.B   #2, opID                    * opID = 0 - size is long
00002262  6700 002A               1602                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
00002266  6000 0088               1603                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
0000226A                          1604  
0000226A  33DA 00002DBA           1605  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002270  13FC 0000 00002DBE      1606                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002278  6000 0026               1607                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
0000227C  33DA 00002DBA           1608  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002282  13FC 0001 00002DBE      1609                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000228A  6000 0014               1610                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
0000228E  23DA 00002DBA           1611  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002294  13FC 0002 00002DBE      1612                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000229C  6000 0002               1613                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000022A0                          1614              
000022A0  0C39 0007 00002DB6      1615  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
000022A8  6700 0006               1616                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
000022AC  6000 0044               1617                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
000022B0  0C39 0000 00002DB5      1618  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
000022B8  6700 0012               1619                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
000022BC  0C39 0001 00002DB5      1620                      CMP.B   #1, opDstReg                * Check if destination register is 1
000022C4  6700 0018               1621                      BEQ     Fn_ID5_DtaDstLng            * Load next long
000022C8  6000 0026               1622                      BRA     Fn_ID5_Error                * Invalid registration Mode
000022CC                          1623  
000022CC  33DA 00002DC0           1624  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000022D2  13FC 0001 00002DC4      1625                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
000022DA  6000 0016               1626                      BRA     Fn_ID5_Done
000022DE  23DA 00002DC0           1627  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000022E4  13FC 0002 00002DC4      1628                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
000022EC  6000 0004               1629                      BRA     Fn_ID5_Done
000022F0                          1630  
000022F0                          1631  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
000022F0                          1632                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000022F0  4E75                    1633                      RTS   
000022F2                          1634              
000022F2  13FC 0000 00002D4D      1635  Fn_ID5_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000022FA  4E75                    1636              RTS
000022FA  4E75                    1637  -------------------- end include --------------------
000022FC                          1638                      INCLUDE 'SR_ID6.X68'
000022FC                          1639  
000022FC                          1640  
000022FC                          1641  SR_ID6              * This is to grab the first four that are already set, ID6
000022FC  3639 00002D4A           1642                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002302  183C 000C               1643                      MOVE.B  #12,D4
00002306  E86B                    1644                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002308  13C3 00002D4C           1645                      MOVE.B  D3, opID        
0000230E                          1646                      
0000230E                          1647                      * Read next 4 bits into D3
0000230E  3639 00002D4A           1648                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002314  183C 0004               1649                      MOVE.B  #4, D4
00002318  E96B                    1650                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
0000231A  183C 000C               1651                      MOVE.B  #12,D4
0000231E  E86B                    1652                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
00002320  13C3 00002D4C           1653                      MOVE.B  D3, opID
00002326                          1654                      
00002326                          1655                      * Read next 8 bits into D3
00002326  3639 00002D4A           1656                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000232C  183C 0007               1657                      MOVE.B  #7, D4
00002330  E96B                    1658                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
00002332  183C 0008               1659                      MOVE.B  #8,D4
00002336  E86B                    1660                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002338  13C3 00002DB6           1661                      MOVE.B  D3, opDstMod
0000233E                          1662              
0000233E                          1663              ** Condition is stored in opID - displacement is in DstMod
0000233E                          1664              ** All thats leftis to branch per condition and output name, check reg if needed more
0000233E                          1665              ** BRA - opID=0
0000233E                          1666              ** BEQ - opID=7
0000233E                          1667              ** BGT - opID=14
0000233E                          1668              ** BLE - opID=15
0000233E  0C39 0000 00002D4C      1669              CMP.B   #0,opID
00002346  6700 002A               1670              BEQ     Fn_ID6_BRA
0000234A  0C39 0007 00002D4C      1671              CMP.B   #7,opID
00002352  6700 0028               1672              BEQ     Fn_ID6_BEQ
00002356  0C39 000E 00002D4C      1673              CMP.B   #14,opID
0000235E  6700 0026               1674              BEQ     Fn_ID6_BGT
00002362  0C39 000F 00002D4C      1675              CMP.B   #15,opID
0000236A  6700 0024               1676              BEQ     Fn_ID6_BLE
0000236E  6000 0078               1677              BRA     Fn_ID6_ERROR
00002372                          1678  
00002372  47F9 00002E0A           1679  Fn_ID6_BRA  LEA     opNam_BRA,A3
00002378  6000 001C               1680              BRA     Fn_ID6_Displacement
0000237C                          1681              
0000237C  47F9 00002E0E           1682  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
00002382  6000 0012               1683              BRA     Fn_ID6_Displacement
00002386                          1684              
00002386  47F9 00002E12           1685  Fn_ID6_BGT  LEA     opNam_BGT,A3
0000238C  6000 0008               1686              BRA     Fn_ID6_Displacement
00002390                          1687              
00002390  47F9 00002E16           1688  Fn_ID6_BLE  LEA     opNam_BLE,A3
00002396                          1689              
00002396  0C39 0000 00002DB6      1690  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
0000239E  6700 0024               1691              BEQ     Fn_ID6_Dsplcmnt16
000023A2  0C39 00FF 00002DB6      1692              CMP.B   #$FF,opDstMod
000023AA  6700 002A               1693              BEQ     Fn_ID6_Dsplcmnt32
000023AE                          1694              ** 8 bit is good
000023AE  33F9 00002DB6 00002DC0  1695              MOVE.W  opDstMod,opDta2
000023B8  13FC 0000 00002DC4      1696              MOVE.B  #0,opDta2T
000023C0  6000 0028               1697              BRA     Fn_ID6_Done
000023C4                          1698              
000023C4  33DA 00002DC0           1699  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
000023CA  13FC 0001 00002DC4      1700              MOVE.B  #1,opDta2T
000023D2  6000 0016               1701              BRA     Fn_ID6_Done
000023D6                          1702  
000023D6  23DA 00002DC0           1703  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
000023DC  13FC 0002 00002DC4      1704              MOVE.B  #2,opDta2T
000023E4  6000 0004               1705              BRA     Fn_ID6_Done 
000023E8                          1706  
000023E8                          1707  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
000023E8                          1708                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000023E8  4E75                    1709                      RTS 
000023EA                          1710  
000023EA  13FC 0000 00002D4D      1711  Fn_ID6_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000023F2  4E75                    1712              RTS
000023F2  4E75                    1713  -------------------- end include --------------------
000023F4                          1714                      INCLUDE 'SR_ID7.X68'
000023F4                          1715  
000023F4                          1716  
000023F4                          1717  SR_ID7              * This is to grab the first four that are already set, ID7
000023F4  3639 00002D4A           1718                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023FA  183C 000C               1719                      MOVE.B  #12,D4
000023FE  E86B                    1720                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002400  13C3 00002D4C           1721                      MOVE.B  D3, opID        
00002406                          1722                      
00002406                          1723                      * Read next 3 bits into D3
00002406  3639 00002D4A           1724                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000240C  183C 0004               1725                      MOVE.B  #4, D4
00002410  E96B                    1726                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002412  183C 000D               1727                      MOVE.B  #13,D4
00002416  E86B                    1728                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002418  13C3 00002DBA           1729                      MOVE.B  D3, opDta1      
0000241E                          1730              
0000241E                          1731              * Read next 1 bits into D3
0000241E  3639 00002D4A           1732                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002424  183C 0007               1733                      MOVE.B  #7, D4
00002428  E96B                    1734                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000242A  183C 000F               1735                      MOVE.B  #15,D4
0000242E  E86B                    1736                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002430  13C3 00002DB6           1737                      MOVE.B  D3, opDstMod    
00002436  0C39 0000 00002DB6      1738              CMP.B   #0,opDstMod
0000243E  6600 0038               1739              BNE     Fn_ID7_Error
00002442                          1740              
00002442                          1741              * Read next 8 bits into D3
00002442  3639 00002D4A           1742                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002448  183C 0008               1743                      MOVE.B  #8, D4
0000244C  E96B                    1744                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000244E  183C 0008               1745                      MOVE.B  #8,D4
00002452  E86B                    1746                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002454  13C3 00002DC0           1747                      MOVE.B  D3, opDta2
0000245A                          1748  
0000245A  47F9 00002E1A           1749              LEA     opNam_MOVEQ,A3
00002460                          1750              * Set appropriate data
00002460  13FC 0001 00002DC4      1751              MOVE.B  #1, opDta2T
00002468  13FC 0007 00002DB8      1752              MOVE.B  #7, opSrcMod
00002470  13FC 0000 00002DB7      1753              MOVE.B  #0, opSrcReg
00002478                          1754  
00002478                          1755  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
00002478                          1756                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002478  4E75                    1757                      RTS                                  * Return to main
0000247A                          1758              
0000247A  13FC 0000 00002D4D      1759  Fn_ID7_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002482  4E75                    1760              RTS
00002482  4E75                    1761  -------------------- end include --------------------
00002484                          1762                      INCLUDE 'SR_ID8.X68'
00002484                          1763  
00002484                          1764  
00002484                          1765  SR_ID8              * This is to grab the first four that are already set, ID4
00002484  3639 00002D4A           1766                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000248A  183C 000C               1767                      MOVE.B  #12,D4
0000248E  E86B                    1768                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002490  13C3 00002D4C           1769                      MOVE.B  D3, opID        
00002496                          1770                      
00002496                          1771                      * Read next 3 bits into D3
00002496  3639 00002D4A           1772                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000249C  183C 0004               1773                      MOVE.B  #4, D4
000024A0  E96B                    1774                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000024A2  183C 000D               1775                      MOVE.B  #13,D4
000024A6  E86B                    1776                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024A8  13C3 00002DB5           1777                      MOVE.B  D3, opDstReg
000024AE                          1778                      
000024AE                          1779                      * Read next 3 bits into D3
000024AE  3639 00002D4A           1780                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024B4  183C 0007               1781                      MOVE.B  #7, D4
000024B8  E96B                    1782                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000024BA  183C 000D               1783                      MOVE.B  #13,D4
000024BE  E86B                    1784                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024C0  13C3 00002DB6           1785                      MOVE.B  D3, opDstMod
000024C6                          1786  
000024C6                          1787                      ** Read next 3 bits
000024C6                          1788                      **
000024C6  3639 00002D4A           1789                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024CC  183C 000A               1790                      MOVE.B  #10, D4
000024D0  E96B                    1791                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000024D2  183C 000D               1792                      MOVE.B  #13,D4
000024D6  E86B                    1793                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024D8  13C3 00002DB8           1794                      MOVE.B  D3, opSrcMod
000024DE                          1795  
000024DE                          1796                      ** Read next 3 bits
000024DE                          1797                      **
000024DE  3639 00002D4A           1798                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000024E4  183C 000D               1799                      MOVE.B  #13, D4
000024E8  E96B                    1800                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000024EA  183C 000D               1801                      MOVE.B  #13,D4
000024EE  E86B                    1802                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000024F0  13C3 00002DB7           1803                      MOVE.B  D3, opSrcReg
000024F6                          1804              
000024F6                          1805              ** Find out if its Dn, ea or ea, Dn
000024F6                          1806              ** ea, Dn - 0,1,2
000024F6                          1807              ** Dn, ea - 4,5,6
000024F6  47F9 00002E20           1808              LEA     opNam_OR,A3
000024FC  0C39 0003 00002DB6      1809              CMP.B   #3,opDstMod
00002504  6D00 0012               1810              BLT     Fn_ID8_Case1
00002508  0C39 0007 00002DB6      1811              CMP.B   #7,opDstMod
00002510  6D00 0048               1812              BLT     Fn_ID8_Case2
00002514  6000 0178               1813              BRA     Fn_ID8_Error
00002518                          1814  
00002518  13F9 00002DB6 00002D4C  1815  Fn_ID8_Case1MOVE.B  opDstMod,opID
00002522  13F9 00002DB8 00002DB6  1816              MOVE.B  opSrcMod,opDstMod
0000252C  1C39 00002DB5           1817              MOVE.B  opDstReg,D6
00002532  13F9 00002DB7 00002DB5  1818              MOVE.B  opSrcReg,opDstReg
0000253C  13C6 00002DB7           1819              MOVE.B  D6,opSrcReg
00002542  13FC 0000 00002DB8      1820              MOVE.B  #0,opSrcMod
0000254A                          1821              ** Immediate data?
0000254A  0C39 0007 00002DB6      1822              CMP.B   #7, opDstMod
00002552  6700 002E               1823                      BEQ     Fn_ID8_DataDst
00002556  6000 0138               1824                      BRA     Fn_ID8_Done
0000255A                          1825  
0000255A  13F9 00002DB6 00002D4C  1826  Fn_ID8_Case2MOVE.B  opDstMod,opID
00002564  5939 00002D4C           1827              SUB.B   #4,opID
0000256A  13FC 0000 00002DB6      1828              MOVE.B  #0,opDstMod
00002572                          1829              ** Immediate data?
00002572  0C39 0007 00002DB8      1830              CMP.B   #7, opSrcMod
0000257A  6700 008C               1831                      BEQ     Fn_ID8_DataSrc
0000257E  6000 0110               1832                      BRA     Fn_ID8_Done
00002582                          1833              
00002582  0C39 0000 00002DB5      1834  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
0000258A  6700 0058               1835                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
0000258E  0C39 0001 00002DB5      1836                      CMP.B   #1, opDstReg                * Check if source register is 1
00002596  6700 005E               1837                      BEQ     Fn_ID8_DtaDstLng            * Load next long
0000259A  0C39 0004 00002DB5      1838                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000025A2  6700 0006               1839                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
000025A6  6000 00E6               1840                      BRA     FN_ID8_Error                * Invalid register value
000025AA                          1841                      
000025AA  0C39 0001 00002D4C      1842  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000025B2  6700 001E               1843                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
000025B6  0C39 0003 00002D4C      1844                      CMP.B   #3, opID                    * opID = 3 - size is word
000025BE  6700 0024               1845                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000025C2  0C39 0002 00002D4C      1846                      CMP.B   #2, opID                    * opID = 0 - size is long
000025CA  6700 002A               1847                      BEQ     Fn_ID8_DtaDstLng            * Load next
000025CE  6000 00BE               1848                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000025D2                          1849  
000025D2  33DA 00002DBA           1850  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000025D8  13FC 0000 00002DBE      1851                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000025E0  6000 00AE               1852                      BRA     Fn_ID8_Done
000025E4  33DA 00002DBA           1853  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000025EA  13FC 0001 00002DBE      1854                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000025F2  6000 009C               1855                      BRA     Fn_ID8_Done
000025F6  23DA 00002DBA           1856  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000025FC  13FC 0002 00002DBE      1857                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002604  6000 008A               1858                      BRA     Fn_ID8_Done
00002608                          1859              
00002608  0C39 0000 00002DB7      1860  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002610  6700 0058               1861                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002614  0C39 0001 00002DB7      1862                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000261C  6700 005E               1863                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
00002620  0C39 0004 00002DB7      1864                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002628  6700 0006               1865                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
0000262C  6000 0060               1866                      BRA     FN_ID8_Error                * Invalid register value
00002630                          1867                      
00002630  0C39 0001 00002D4C      1868  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002638  6700 001E               1869                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
0000263C  0C39 0003 00002D4C      1870                      CMP.B   #3, opID                    * opID = 3 - size is word
00002644  6700 0024               1871                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002648  0C39 0002 00002D4C      1872                      CMP.B   #2, opID                    * opID = 0 - size is long
00002650  6700 002A               1873                      BEQ     Fn_ID8_DtaSrcLng            * Load next
00002654  6000 0038               1874                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
00002658                          1875  
00002658  33DA 00002DC0           1876  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
0000265E  13FC 0000 00002DC4      1877                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002666  6000 0028               1878                      BRA     Fn_ID8_Done
0000266A  33DA 00002DC0           1879  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002670  13FC 0001 00002DC4      1880                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002678  6000 0016               1881                      BRA     Fn_ID8_Done
0000267C  23DA 00002DC0           1882  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002682  13FC 0002 00002DC4      1883                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
0000268A  6000 0004               1884                      BRA     Fn_ID8_Done
0000268E                          1885  
0000268E                          1886  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
0000268E                          1887                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
0000268E  4E75                    1888                      RTS   
00002690                          1889              
00002690  13FC 0000 00002D4D      1890  Fn_ID8_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002698  4E75                    1891              RTS
00002698  4E75                    1892  -------------------- end include --------------------
0000269A                          1893                      INCLUDE 'SR_ID9.X68'
0000269A                          1894  
0000269A                          1895  
0000269A                          1896  SR_ID9      * This is to grab the first four that are already set, ID4
0000269A  3639 00002D4A           1897                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026A0  183C 000C               1898                      MOVE.B  #12,D4
000026A4  E86B                    1899                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000026A6  13C3 00002D4C           1900                      MOVE.B  D3, opID        
000026AC                          1901                      
000026AC                          1902                      * Read next 3 bits into D3
000026AC  3639 00002D4A           1903                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026B2  183C 0004               1904                      MOVE.B  #4, D4
000026B6  E96B                    1905                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000026B8  183C 000D               1906                      MOVE.B  #13,D4
000026BC  E86B                    1907                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026BE  13C3 00002DB5           1908                      MOVE.B  D3, opDstReg
000026C4                          1909                      
000026C4                          1910                      * Read next 3 bits into D3
000026C4  3639 00002D4A           1911                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026CA  183C 0007               1912                      MOVE.B  #7, D4
000026CE  E96B                    1913                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000026D0  183C 000D               1914                      MOVE.B  #13,D4
000026D4  E86B                    1915                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026D6  13C3 00002DB6           1916                      MOVE.B  D3, opDstMod
000026DC                          1917  
000026DC                          1918                      ** Read next 3 bits
000026DC                          1919                      **
000026DC  3639 00002D4A           1920                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026E2  183C 000A               1921                      MOVE.B  #10, D4
000026E6  E96B                    1922                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
000026E8  183C 000D               1923                      MOVE.B  #13,D4
000026EC  E86B                    1924                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000026EE  13C3 00002DB8           1925                      MOVE.B  D3, opSrcMod
000026F4                          1926  
000026F4                          1927                      ** Read next 3 bits
000026F4                          1928                      **
000026F4  3639 00002D4A           1929                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000026FA  183C 000D               1930                      MOVE.B  #13, D4
000026FE  E96B                    1931                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002700  183C 000D               1932                      MOVE.B  #13,D4
00002704  E86B                    1933                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002706  13C3 00002DB7           1934                      MOVE.B  D3, opSrcReg
0000270C                          1935              
0000270C                          1936              ** Find out if its Dn, ea or ea, Dn
0000270C                          1937              ** ea, Dn - 0,1,2
0000270C                          1938              ** Dn, ea - 4,5,6
0000270C  47F9 00002E23           1939              LEA     opNam_SUB,A3
00002712  0C39 0003 00002DB6      1940              CMP.B   #3,opDstMod
0000271A  6D00 0012               1941              BLT     Fn_ID9_Case1
0000271E  0C39 0007 00002DB6      1942              CMP.B   #7,opDstMod
00002726  6D00 0048               1943              BLT     Fn_ID9_Case2
0000272A  6000 0178               1944              BRA     Fn_ID9_Error
0000272E                          1945  
0000272E  13F9 00002DB6 00002D4C  1946  Fn_ID9_Case1MOVE.B  opDstMod,opID
00002738  13F9 00002DB8 00002DB6  1947              MOVE.B  opSrcMod,opDstMod
00002742  1C39 00002DB5           1948              MOVE.B  opDstReg,D6
00002748  13F9 00002DB7 00002DB5  1949              MOVE.B  opSrcReg,opDstReg
00002752  13C6 00002DB7           1950              MOVE.B  D6,opSrcReg
00002758  13FC 0000 00002DB8      1951              MOVE.B  #0,opSrcMod
00002760                          1952              ** Immediate data?
00002760  0C39 0007 00002DB6      1953              CMP.B   #7, opDstMod
00002768  6700 002E               1954                      BEQ     Fn_ID9_DataDst
0000276C  6000 0138               1955                      BRA     Fn_ID9_Done
00002770                          1956  
00002770  13F9 00002DB6 00002D4C  1957  Fn_ID9_Case2MOVE.B  opDstMod,opID
0000277A  5939 00002D4C           1958              SUB.B   #4,opID
00002780  13FC 0000 00002DB6      1959              MOVE.B  #0,opDstMod
00002788                          1960              ** Immediate data?
00002788  0C39 0007 00002DB8      1961              CMP.B   #7, opSrcMod
00002790  6700 008C               1962                      BEQ     Fn_ID9_DataSrc
00002794  6000 0110               1963                      BRA     Fn_ID9_Done
00002798                          1964              
00002798  0C39 0000 00002DB5      1965  Fn_ID9_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000027A0  6700 0058               1966                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000027A4  0C39 0001 00002DB5      1967                      CMP.B   #1, opDstReg                * Check if source register is 1
000027AC  6700 005E               1968                      BEQ     Fn_ID9_DtaDstLng            * Load next long
000027B0  0C39 0004 00002DB5      1969                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000027B8  6700 0006               1970                      BEQ     Fn_ID9_DtaDstImd            * Load first word into word one
000027BC  6000 00E6               1971                      BRA     FN_ID9_Error                * Invalid register value
000027C0                          1972                      
000027C0  0C39 0001 00002D4C      1973  Fn_ID9_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000027C8  6700 001E               1974                      BEQ     Fn_ID9_DtaDstByt            * Load next byte
000027CC  0C39 0003 00002D4C      1975                      CMP.B   #3, opID                    * opID = 3 - size is word
000027D4  6700 0024               1976                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000027D8  0C39 0002 00002D4C      1977                      CMP.B   #2, opID                    * opID = 0 - size is long
000027E0  6700 002A               1978                      BEQ     Fn_ID9_DtaDstLng            * Load next
000027E4  6000 00BE               1979                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
000027E8                          1980  
000027E8  33DA 00002DBA           1981  Fn_ID9_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000027EE  13FC 0000 00002DBE      1982                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000027F6  6000 00AE               1983                      BRA     Fn_ID9_Done
000027FA  33DA 00002DBA           1984  Fn_ID9_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002800  13FC 0001 00002DBE      1985                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002808  6000 009C               1986                      BRA     Fn_ID9_Done
0000280C  23DA 00002DBA           1987  Fn_ID9_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002812  13FC 0002 00002DBE      1988                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000281A  6000 008A               1989                      BRA     Fn_ID9_Done
0000281E                          1990              
0000281E  0C39 0000 00002DB7      1991  Fn_ID9_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002826  6700 0058               1992                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000282A  0C39 0001 00002DB7      1993                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002832  6700 005E               1994                      BEQ     Fn_ID9_DtaSrcLng            * Load next long
00002836  0C39 0004 00002DB7      1995                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
0000283E  6700 0006               1996                      BEQ     Fn_ID9_DtaSrcImd            * Load first word into word one
00002842  6000 0060               1997                      BRA     FN_ID9_Error                * Invalid register value
00002846                          1998                      
00002846  0C39 0001 00002D4C      1999  Fn_ID9_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000284E  6700 001E               2000                      BEQ     Fn_ID9_DtaSrcByt            * Load next byte
00002852  0C39 0003 00002D4C      2001                      CMP.B   #3, opID                    * opID = 3 - size is word
0000285A  6700 0024               2002                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000285E  0C39 0002 00002D4C      2003                      CMP.B   #2, opID                    * opID = 0 - size is long
00002866  6700 002A               2004                      BEQ     Fn_ID9_DtaSrcLng            * Load next
0000286A  6000 0038               2005                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
0000286E                          2006  
0000286E  33DA 00002DC0           2007  Fn_ID9_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002874  13FC 0000 00002DC4      2008                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
0000287C  6000 0028               2009                      BRA     Fn_ID9_Done
00002880  33DA 00002DC0           2010  Fn_ID9_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002886  13FC 0001 00002DC4      2011                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
0000288E  6000 0016               2012                      BRA     Fn_ID9_Done
00002892  23DA 00002DC0           2013  Fn_ID9_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002898  13FC 0002 00002DC4      2014                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000028A0  6000 0004               2015                      BRA     Fn_ID9_Done
000028A4                          2016  
000028A4                          2017  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
000028A4                          2018                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000028A4  4E75                    2019                      RTS   
000028A6                          2020  
000028A6  13FC 0000 00002D4D      2021  Fn_ID9_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000028AE  4E75                    2022              RTS
000028AE  4E75                    2023  -------------------- end include --------------------
000028B0                          2024                      INCLUDE 'SR_IDA.X68'
000028B0                          2025  
000028B0                          2026  
000028B0                          2027  SR_IDA
000028B0                          2028  
000028B0                          2029  
000028B0  4E75                    2030  Fn_IDA_Done        RTS
000028B0  4E75                    2031  -------------------- end include --------------------
000028B2                          2032                      INCLUDE 'SR_IDB.X68'
000028B2                          2033  
000028B2                          2034  
000028B2                          2035  SR_IDB
000028B2                          2036  
000028B2                          2037  
000028B2  4E75                    2038  Fn_IDB_Done        RTS
000028B2  4E75                    2039  -------------------- end include --------------------
000028B4                          2040                      INCLUDE 'SR_IDC.X68'
000028B4                          2041  
000028B4                          2042  
000028B4                          2043  SR_IDC      * This is to grab the first four that are already set, ID4
000028B4  3639 00002D4A           2044                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028BA  183C 000C               2045                      MOVE.B  #12,D4
000028BE  E86B                    2046                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000028C0  13C3 00002D4C           2047                      MOVE.B  D3, opID        
000028C6                          2048                      
000028C6                          2049                      * Read next 3 bits into D3
000028C6  3639 00002D4A           2050                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028CC  183C 0004               2051                      MOVE.B  #4, D4
000028D0  E96B                    2052                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000028D2  183C 000D               2053                      MOVE.B  #13,D4
000028D6  E86B                    2054                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000028D8  13C3 00002DB5           2055                      MOVE.B  D3, opDstReg
000028DE                          2056                      
000028DE                          2057                      * Read next 3 bits into D3
000028DE  3639 00002D4A           2058                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028E4  183C 0007               2059                      MOVE.B  #7, D4
000028E8  E96B                    2060                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
000028EA  183C 000D               2061                      MOVE.B  #13,D4
000028EE  E86B                    2062                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000028F0  13C3 00002DB6           2063                      MOVE.B  D3, opDstMod
000028F6                          2064  
000028F6                          2065                      ** Read next 3 bits
000028F6                          2066                      **
000028F6  3639 00002D4A           2067                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000028FC  183C 000A               2068                      MOVE.B  #10, D4
00002900  E96B                    2069                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002902  183C 000D               2070                      MOVE.B  #13,D4
00002906  E86B                    2071                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002908  13C3 00002DB8           2072                      MOVE.B  D3, opSrcMod
0000290E                          2073  
0000290E                          2074                      ** Read next 3 bits
0000290E                          2075                      **
0000290E  3639 00002D4A           2076                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002914  183C 000D               2077                      MOVE.B  #13, D4
00002918  E96B                    2078                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000291A  183C 000D               2079                      MOVE.B  #13,D4
0000291E  E86B                    2080                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002920  13C3 00002DB7           2081                      MOVE.B  D3, opSrcReg
00002926                          2082              
00002926                          2083              ** Find out if its Dn, ea or ea, Dn
00002926                          2084              ** ea, Dn - 0,1,2
00002926                          2085              ** Dn, ea - 4,5,6
00002926  47F9 00002E27           2086              LEA     opNam_AND,A3
0000292C  0C39 0003 00002DB6      2087              CMP.B   #3,opDstMod
00002934  6D00 0012               2088              BLT     Fn_IDC_Case1
00002938  0C39 0007 00002DB6      2089              CMP.B   #7,opDstMod
00002940  6D00 0048               2090              BLT     Fn_IDC_Case2
00002944  6000 0178               2091              BRA     Fn_IDC_Error
00002948                          2092  
00002948  13F9 00002DB6 00002D4C  2093  Fn_IDC_Case1MOVE.B  opDstMod,opID
00002952  13F9 00002DB8 00002DB6  2094              MOVE.B  opSrcMod,opDstMod
0000295C  1C39 00002DB5           2095              MOVE.B  opDstReg,D6
00002962  13F9 00002DB7 00002DB5  2096              MOVE.B  opSrcReg,opDstReg
0000296C  13C6 00002DB7           2097              MOVE.B  D6,opSrcReg
00002972  13FC 0000 00002DB8      2098              MOVE.B  #0,opSrcMod
0000297A                          2099              ** Immediate data?
0000297A  0C39 0007 00002DB6      2100              CMP.B   #7, opDstMod
00002982  6700 002E               2101                      BEQ     Fn_IDC_DataDst
00002986  6000 0138               2102                      BRA     Fn_IDC_Done
0000298A                          2103  
0000298A  13F9 00002DB6 00002D4C  2104  Fn_IDC_Case2MOVE.B  opDstMod,opID
00002994  5939 00002D4C           2105              SUB.B   #4,opID
0000299A  13FC 0000 00002DB6      2106              MOVE.B  #0,opDstMod
000029A2                          2107              ** Immediate data?
000029A2  0C39 0007 00002DB8      2108              CMP.B   #7, opSrcMod
000029AA  6700 008C               2109                      BEQ     Fn_IDC_DataSrc
000029AE  6000 0110               2110                      BRA     Fn_IDC_Done
000029B2                          2111              
000029B2  0C39 0000 00002DB5      2112  Fn_IDC_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000029BA  6700 0058               2113                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000029BE  0C39 0001 00002DB5      2114                      CMP.B   #1, opDstReg                * Check if source register is 1
000029C6  6700 005E               2115                      BEQ     Fn_IDC_DtaDstLng            * Load next long
000029CA  0C39 0004 00002DB5      2116                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000029D2  6700 0006               2117                      BEQ     Fn_IDC_DtaDstImd            * Load first word into word one
000029D6  6000 00E6               2118                      BRA     FN_IDC_Error                * Invalid register value
000029DA                          2119                      
000029DA  0C39 0001 00002D4C      2120  Fn_IDC_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000029E2  6700 001E               2121                      BEQ     Fn_IDC_DtaDstByt            * Load next byte
000029E6  0C39 0003 00002D4C      2122                      CMP.B   #3, opID                    * opID = 3 - size is word
000029EE  6700 0024               2123                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000029F2  0C39 0002 00002D4C      2124                      CMP.B   #2, opID                    * opID = 0 - size is long
000029FA  6700 002A               2125                      BEQ     Fn_IDC_DtaDstLng            * Load next
000029FE  6000 00BE               2126                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002A02                          2127  
00002A02  33DA 00002DBA           2128  Fn_IDC_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002A08  13FC 0000 00002DBE      2129                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002A10  6000 00AE               2130                      BRA     Fn_IDC_Done
00002A14  33DA 00002DBA           2131  Fn_IDC_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002A1A  13FC 0001 00002DBE      2132                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002A22  6000 009C               2133                      BRA     Fn_IDC_Done
00002A26  23DA 00002DBA           2134  Fn_IDC_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002A2C  13FC 0002 00002DBE      2135                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002A34  6000 008A               2136                      BRA     Fn_IDC_Done
00002A38                          2137              
00002A38  0C39 0000 00002DB7      2138  Fn_IDC_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002A40  6700 0058               2139                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002A44  0C39 0001 00002DB7      2140                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002A4C  6700 005E               2141                      BEQ     Fn_IDC_DtaSrcLng            * Load next long
00002A50  0C39 0004 00002DB7      2142                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002A58  6700 0006               2143                      BEQ     Fn_IDC_DtaSrcImd            * Load first word into word one
00002A5C  6000 0060               2144                      BRA     FN_IDC_Error                * Invalid register value
00002A60                          2145                      
00002A60  0C39 0001 00002D4C      2146  Fn_IDC_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002A68  6700 001E               2147                      BEQ     Fn_IDC_DtaSrcByt            * Load next byte
00002A6C  0C39 0003 00002D4C      2148                      CMP.B   #3, opID                    * opID = 3 - size is word
00002A74  6700 0024               2149                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
00002A78  0C39 0002 00002D4C      2150                      CMP.B   #2, opID                    * opID = 0 - size is long
00002A80  6700 002A               2151                      BEQ     Fn_IDC_DtaSrcLng            * Load next
00002A84  6000 0038               2152                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
00002A88                          2153  
00002A88  33DA 00002DC0           2154  Fn_IDC_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002A8E  13FC 0000 00002DC4      2155                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002A96  6000 0028               2156                      BRA     Fn_IDC_Done
00002A9A  33DA 00002DC0           2157  Fn_IDC_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002AA0  13FC 0001 00002DC4      2158                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002AA8  6000 0016               2159                      BRA     Fn_IDC_Done
00002AAC  23DA 00002DC0           2160  Fn_IDC_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002AB2  13FC 0002 00002DC4      2161                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002ABA  6000 0004               2162                      BRA     Fn_IDC_Done
00002ABE                          2163  
00002ABE                          2164  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
00002ABE                          2165                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002ABE  4E75                    2166                      RTS   
00002AC0                          2167  
00002AC0  13FC 0000 00002D4D      2168  Fn_IDC_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002AC8  4E75                    2169              RTS
00002AC8  4E75                    2170  -------------------- end include --------------------
00002ACA                          2171                      INCLUDE 'SR_IDD.X68'
00002ACA                          2172  
00002ACA                          2173  
00002ACA                          2174  SR_IDD      * This is to grab the first four that are already set, ID4
00002ACA  3639 00002D4A           2175                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AD0  183C 000C               2176                      MOVE.B  #12,D4
00002AD4  E86B                    2177                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002AD6  13C3 00002D4C           2178                      MOVE.B  D3, opID        
00002ADC                          2179                      
00002ADC                          2180                      * Read next 3 bits into D3
00002ADC  3639 00002D4A           2181                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AE2  183C 0004               2182                      MOVE.B  #4, D4
00002AE6  E96B                    2183                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002AE8  183C 000D               2184                      MOVE.B  #13,D4
00002AEC  E86B                    2185                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002AEE  13C3 00002DB5           2186                      MOVE.B  D3, opDstReg
00002AF4                          2187                      
00002AF4                          2188                      * Read next 3 bits into D3
00002AF4  3639 00002D4A           2189                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002AFA  183C 0007               2190                      MOVE.B  #7, D4
00002AFE  E96B                    2191                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002B00  183C 000D               2192                      MOVE.B  #13,D4
00002B04  E86B                    2193                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002B06  13C3 00002DB6           2194                      MOVE.B  D3, opDstMod
00002B0C                          2195  
00002B0C                          2196                      ** Read next 3 bits
00002B0C                          2197                      **
00002B0C  3639 00002D4A           2198                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002B12  183C 000A               2199                      MOVE.B  #10, D4
00002B16  E96B                    2200                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002B18  183C 000D               2201                      MOVE.B  #13,D4
00002B1C  E86B                    2202                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002B1E  13C3 00002DB8           2203                      MOVE.B  D3, opSrcMod
00002B24                          2204  
00002B24                          2205                      ** Read next 3 bits
00002B24                          2206                      **
00002B24  3639 00002D4A           2207                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002B2A  183C 000D               2208                      MOVE.B  #13, D4
00002B2E  E96B                    2209                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002B30  183C 000D               2210                      MOVE.B  #13,D4
00002B34  E86B                    2211                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002B36  13C3 00002DB7           2212                      MOVE.B  D3, opSrcReg
00002B3C                          2213              
00002B3C                          2214              ** Find out if its Dn, ea or ea, Dn
00002B3C                          2215              ** ea, Dn - 0,1,2
00002B3C                          2216              ** Dn, ea - 4,5,6
00002B3C  0C39 0003 00002DB6      2217              CMP.B   #3,opDstMod
00002B44  6D00 002A               2218              BLT     Fn_IDD_Case1
00002B48  0C39 0003 00002DB6      2219              CMP.B   #3,opDstMod
00002B50  6700 0094               2220              BEQ     Fn_IDD_Case3
00002B54  0C39 0007 00002DB6      2221              CMP.B   #7,opDstMod
00002B5C  6D00 005A               2222              BLT     Fn_IDD_Case2
00002B60  0C39 0007 00002DB6      2223              CMP.B   #7,opDstMod
00002B68  6700 007C               2224              BEQ     Fn_IDD_Case3
00002B6C  6000 01B2               2225              BRA     Fn_IDD_Error
00002B70                          2226  
00002B70  47F9 00002E2B           2227  Fn_IDD_Case1LEA     opNam_ADD,A3
00002B76  13F9 00002DB6 00002D4C  2228              MOVE.B  opDstMod,opID
00002B80  13F9 00002DB8 00002DB6  2229              MOVE.B  opSrcMod,opDstMod
00002B8A  1C39 00002DB5           2230              MOVE.B  opDstReg,D6
00002B90  13F9 00002DB7 00002DB5  2231              MOVE.B  opSrcReg,opDstReg
00002B9A  13C6 00002DB7           2232              MOVE.B  D6,opSrcReg
00002BA0  13FC 0000 00002DB8      2233              MOVE.B  #0,opSrcMod
00002BA8                          2234              ** Immediate data?
00002BA8  0C39 0007 00002DB6      2235              CMP.B   #7, opDstMod
00002BB0  6700 0062               2236                      BEQ     Fn_IDD_DataDst
00002BB4  6000 016C               2237                      BRA     Fn_IDD_Done
00002BB8                          2238  
00002BB8  47F9 00002E2B           2239  Fn_IDD_Case2LEA     opNam_ADD,A3
00002BBE  13F9 00002DB6 00002D4C  2240              MOVE.B  opDstMod,opID
00002BC8  5939 00002D4C           2241              SUB.B   #4,opID
00002BCE  13FC 0000 00002DB6      2242              MOVE.B  #0,opDstMod
00002BD6                          2243              ** Immediate data?
00002BD6  0C39 0007 00002DB8      2244              CMP.B   #7, opSrcMod
00002BDE  6700 00BA               2245                      BEQ     Fn_IDD_DataSrc
00002BE2  6000 013E               2246                      BRA     Fn_IDD_Done
00002BE6                          2247              
00002BE6  47F9 00002E2F           2248  Fn_IDD_Case3LEA     opNam_ADDA,A3
00002BEC  13F9 00002DB6 00002D4C  2249              MOVE.B  opDstMod,opID
00002BF6  5939 00002D4C           2250              SUB.B   #4,opID
00002BFC  13FC 0000 00002DB6      2251              MOVE.B  #0,opDstMod
00002C04                          2252              ** Immediate data?
00002C04  0C39 0007 00002DB8      2253              CMP.B   #7, opSrcMod
00002C0C  6700 008C               2254                      BEQ     Fn_IDD_DataSrc
00002C10  6000 0110               2255                      BRA     Fn_IDD_Done
00002C14                          2256              
00002C14  0C39 0000 00002DB5      2257  Fn_IDD_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002C1C  6700 0058               2258                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002C20  0C39 0001 00002DB5      2259                      CMP.B   #1, opDstReg                * Check if source register is 1
00002C28  6700 005E               2260                      BEQ     Fn_IDD_DtaDstLng            * Load next long
00002C2C  0C39 0004 00002DB5      2261                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002C34  6700 0006               2262                      BEQ     Fn_IDD_DtaDstImd            * Load first word into word one
00002C38  6000 00E6               2263                      BRA     FN_IDD_Error                * Invalid register value
00002C3C                          2264                      
00002C3C  0C39 0001 00002D4C      2265  Fn_IDD_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002C44  6700 001E               2266                      BEQ     Fn_IDD_DtaDstByt            * Load next byte
00002C48  0C39 0003 00002D4C      2267                      CMP.B   #3, opID                    * opID = 3 - size is word
00002C50  6700 0024               2268                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002C54  0C39 0002 00002D4C      2269                      CMP.B   #2, opID                    * opID = 0 - size is long
00002C5C  6700 002A               2270                      BEQ     Fn_IDD_DtaDstLng            * Load next
00002C60  6000 00BE               2271                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002C64                          2272  
00002C64  33DA 00002DBA           2273  Fn_IDD_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002C6A  13FC 0000 00002DBE      2274                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002C72  6000 00AE               2275                      BRA     Fn_IDD_Done
00002C76  33DA 00002DBA           2276  Fn_IDD_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002C7C  13FC 0001 00002DBE      2277                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002C84  6000 009C               2278                      BRA     Fn_IDD_Done
00002C88  23DA 00002DBA           2279  Fn_IDD_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002C8E  13FC 0002 00002DBE      2280                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002C96  6000 008A               2281                      BRA     Fn_IDD_Done
00002C9A                          2282              
00002C9A  0C39 0000 00002DB7      2283  Fn_IDD_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002CA2  6700 0058               2284                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002CA6  0C39 0001 00002DB7      2285                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002CAE  6700 005E               2286                      BEQ     Fn_IDD_DtaSrcLng            * Load next long
00002CB2  0C39 0004 00002DB7      2287                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002CBA  6700 0006               2288                      BEQ     Fn_IDD_DtaSrcImd            * Load first word into word one
00002CBE  6000 0060               2289                      BRA     FN_IDD_Error                * Invalid register value
00002CC2                          2290                      
00002CC2  0C39 0001 00002D4C      2291  Fn_IDD_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002CCA  6700 001E               2292                      BEQ     Fn_IDD_DtaSrcByt            * Load next byte
00002CCE  0C39 0003 00002D4C      2293                      CMP.B   #3, opID                    * opID = 3 - size is word
00002CD6  6700 0024               2294                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002CDA  0C39 0002 00002D4C      2295                      CMP.B   #2, opID                    * opID = 0 - size is long
00002CE2  6700 002A               2296                      BEQ     Fn_IDD_DtaSrcLng            * Load next
00002CE6  6000 0038               2297                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002CEA                          2298  
00002CEA  33DA 00002DC0           2299  Fn_IDD_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002CF0  13FC 0000 00002DC4      2300                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002CF8  6000 0028               2301                      BRA     Fn_IDD_Done
00002CFC  33DA 00002DC0           2302  Fn_IDD_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002D02  13FC 0001 00002DC4      2303                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002D0A  6000 0016               2304                      BRA     Fn_IDD_Done
00002D0E  23DA 00002DC0           2305  Fn_IDD_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002D14  13FC 0002 00002DC4      2306                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002D1C  6000 0004               2307                      BRA     Fn_IDD_Done
00002D20                          2308  
00002D20                          2309  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
00002D20                          2310                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002D20  4E75                    2311                      RTS   
00002D22                          2312  
00002D22  13FC 0000 00002D4D      2313  Fn_IDD_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
00002D2A  4E75                    2314              RTS
00002D2A  4E75                    2315  -------------------- end include --------------------
00002D2C                          2316                      INCLUDE 'SR_IDE.X68'
00002D2C                          2317  
00002D2C                          2318  SR_IDE
00002D2C                          2319  
00002D2C  4E75                    2320                RTS
00002D2C  4E75                    2321  -------------------- end include --------------------
00002D2E                          2322  
00002D2E                          2323  ** -----------------------------------------------------------
00002D2E                          2324  ** Variables and constants
00002D2E                          2325  ** -----------------------------------------------------------
00002D2E                          2326  
00002D2E  =0000001A               2327  maxLines            EQU      26                      * Max lines to display
00002D2E                          2328  
00002D2E= 00000000                2329  adrValStart         DC.L     $00000000               * Value of starting address - set by user
00002D32= 38 39 41 42 43 44 ...   2330  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
00002D3B= FF                      2331  adrStsStart         DC.B     $FF                     * Status of starting address
00002D3C                          2332                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002D3C= 00000000                2333  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
00002D40= 38 39 41 42 43 44 ...   2334  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
00002D49= FF                      2335  adrStsEnd           DC.B     $FF                     * Status of ending address
00002D4A                          2336                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002D4A                          2337  
00002D4A= 0000                    2338  opWord              DC.W     $0000                   * 16 bit instruction Word
00002D4C= 00                      2339  opID                DC.B     $00                     * First 4 bit value ID
00002D4D= 01                      2340  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
00002D4E                          2341  
00002D4E= 00000000                2342  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
00002D52= 38 39 41 42 43 44 ...   2343  opStrAdr            DC.B     '89ABCDEF',0            * String address
00002D5C= 00000000                2344  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
00002D60                          2345  
00002D60= 50 6C 61 63 65 68 ...   2346  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
00002DB0= 00000000                2347  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002DB4                          2348  
00002DB4= FF                      2349  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002DB5                          2350  
00002DB5= FF                      2351  opDstReg            DC.B     $FF                     * Destination Register Value
00002DB6= FF                      2352  opDstMod            DC.B     $FF                     * Destination Mode Value
00002DB7= FF                      2353  opSrcReg            DC.B     $FF                     * Source Register Value
00002DB8= FF                      2354  opSrcMod            DC.B     $FF                     * Source Register Mode
00002DB9                          2355  
00002DBA= 00000000                2356  opDta1              DC.L     $00000000               * Data value one (most likely source)
00002DBE= FF                      2357  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
00002DC0= 00000000                2358  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002DC4= FF                      2359  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002DC5= 30 30 30 30 00          2360  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002DCA= 30 30 30 30 30 30 ...   2361  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002DD3                          2362  
00002DD4= 00000000                2363  opMask              DC.L     $00000000               * Mask for MOVEM
00002DD8= 00                      2364  opRotate            DC.B     $00                     * Rotation for IDE(14)
00002DD9= 00                      2365  opSizDir            DC.B     $00                     * Size/Direction for IDE(14)
00002DDA= 00                      2366  opIR                DC.B     $00                     * Immediate/Rotate for IDE(14)
00002DDB                          2367  
00002DDB= 44 41 54 41 00          2368  opNam_DATA          DC.B     'DATA',0
00002DE0= 4D 4F 56 45 00          2369  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
00002DE5= 4D 4F 56 45 41 00       2370  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002DEB= 4C 45 41 00             2371  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002DEF= 4E 4F 54 00             2372  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002DF3= 4D 4F 56 45 4D 00       2373  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
00002DF9= 4E 4F 50 00             2374  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002DFD= 52 54 53 00             2375  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002E01= 4A 53 52 00             2376  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
00002E05= 41 44 44 51 00          2377  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002E0A= 42 52 41 00             2378  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002E0E= 42 45 51 00             2379  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002E12= 42 47 54 00             2380  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
00002E16= 42 4C 45 00             2381  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
00002E1A= 4D 4F 56 45 51 00       2382  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
00002E20= 4F 52 00                2383  opNam_OR            DC.B     'OR',0                  * String value for instruction
00002E23= 53 55 42 00             2384  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
00002E27= 41 4E 44 00             2385  opNam_AND           DC.B     'AND',0                 * String value for instruction
00002E2B= 41 44 44 00             2386  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
00002E2F= 41 44 44 41 00          2387  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
00002E34= 41 53 4C 00             2388  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
00002E38= 41 53 52 00             2389  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
00002E3C= 4C 53 4C 00             2390  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
00002E40= 4C 53 52 00             2391  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
00002E44= 52 4F 4C 00             2392  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
00002E48= 52 4F 52 00             2393  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
00002E4C                          2394  
00002E4C= 2E 42 00                2395  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
00002E4F= 2E 57 00                2396  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
00002E52= 2E 4C 00                2397  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
00002E55                          2398  
00002E55= 50 6C 61 63 65 68 ...   2399  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
00002EA6= 45 72 72 6F 72 00       2400  msgErr              DC.B     'Error',0               * Debug message
00002EAC                          2401  
00002EAC= 33 20 43 6F 72 65 ...   2402  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002EC3= 4D 65 6D 6F 72 79 ...   2403  msgHdr02a           DC.B     'Memory range:',0
00002ED1= 20 74 6F 20 00          2404  msgHdr02b           DC.B     ' to ',0
00002ED6                          2405  
00002ED6= 20 2D 20 41 6C 6C ...   2406  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
00002F05= 20 2D 20 56 61 6C ...   2407  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
00002F37= 20 2D 20 53 74 61 ...   2408  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
00002F6C= 20 20 20 40 20 58 ...   2409  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002F8B= 20 2D 20 41 64 64 ...   2410  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002FCC= 20 20 20 28 61 75 ...   2411  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002FE1= 50 6C 65 61 73 65 ...   2412  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00003003= 49 6E 76 61 6C 69 ...   2413  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
00003025= 49 6E 76 61 6C 69 ...   2414  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
00003052= 53 74 61 72 74 69 ...   2415  msgStrAdr1Scc       DC.B     'Starting address: ',0
00003065= 50 6C 65 61 73 65 ...   2416  msgStrAdr2          DC.B     'Please enter an ending address: ',0
00003086= 49 6E 76 61 6C 69 ...   2417  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
000030A6= 49 6E 76 61 6C 69 ...   2418  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
000030D1                          2419  
000030D1= 48 69 74 20 45 6E ...   2420  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
000030F4= 59 6F 75 20 68 61 ...   2421  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
00003127= 20 20 20 20 20 20 ...   2422  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
00003159= 54 68 61 6E 6B 20 ...   2423  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
00003183                          2424  
00003183= 2A 2A 2A 2A 2A 2A ...   2425  msgLine             DC.B     '**************************************************',CR,LF,0
000031B8= 0D 0A 00                2426  msgNewLine          DC.B     CR,LF,0
000031BB= 2C 00                   2427  opComma             DC.B     ',',0
000031BD= 2E 00                   2428  opPeriod            DC.B     '.',0
000031BF= 20 00                   2429  opSpace             DC.B     ' ',0
000031C2= 0900                    2430  opTab               DC.W     $0900                  * Tab - doesn't work as expected
000031C4= 00                      2431  opBlank             DC.B     '',0
000031C5  =0000000D               2432  CR                  EQU      $0D                     * ASCII code for Carriage Return
000031C5  =0000000A               2433  LF                  EQU      $0A                     * ASCII code for Line Feed
000031C5                          2434  
000031C5                          2435                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           2D40
ADRSTRSTART         2D32
ADRSTSEND           2D49
ADRSTSSTART         2D3B
ADRVALEND           2D3C
ADRVALSTART         2D2E
CR                  D
FN_ASCII_LCLTR      19B6
FN_ASCII_NUM        19AA
FN_ASCII_UCLTR      19B0
FN_CPY_STR_DONE     1A14
FN_CPY_STR_LOOP     1A06
FN_DSP_DATA         15EC
FN_DSP_DONE         1984
FN_DSP_DTA1         1684
FN_DSP_DTA1_00      16DC
FN_DSP_DTA1_01      16F0
FN_DSP_DTA1_02      1704
FN_DSP_DTA1_03      1720
FN_DSP_DTA1_04      1740
FN_DSP_DTA1_07      1760
FN_DSP_DTA1_BYT     1788
FN_DSP_DTA1_ERR     17EE
FN_DSP_DTA1_LNG     17CC
FN_DSP_DTA1_WRD     17AA
FN_DSP_DTA2         180A
FN_DSP_DTA2_00      1862
FN_DSP_DTA2_01      1876
FN_DSP_DTA2_02      188A
FN_DSP_DTA2_03      18A6
FN_DSP_DTA2_04      18C6
FN_DSP_DTA2_07      18E6
FN_DSP_DTA2_BYT     190E
FN_DSP_DTA2_ERR     1974
FN_DSP_DTA2_LNG     1952
FN_DSP_DTA2_WRD     1930
FN_DSP_INSTR        1608
FN_DSP_OPR1         1678
FN_DSP_OPR2         17FE
FN_DSP_SIZB         1648
FN_DSP_SIZL         1668
FN_DSP_SIZW         1658
FN_HEX_LTR          19CE
FN_HEX_NUM          19C8
FN_HEX_STR_DONE     1A00
FN_HEX_STR_LOOP     19D4
FN_ID3_CHKDSTMOD    1C02
FN_ID3_CHKDSTREG    1C12
FN_ID3_CHKSRCREG    1B7C
FN_ID3_DONE         1C52
FN_ID3_DTADSTLNG    1C40
FN_ID3_DTADSTWRD    1C2E
FN_ID3_DTASRCBYT    1BCC
FN_ID3_DTASRCIMD    1BA4
FN_ID3_DTASRCLNG    1BF0
FN_ID3_DTASRCWRD    1BDE
FN_ID3_ERROR        1C5A
FN_ID3_INS01        1A9C
FN_ID3_INS02        1AAC
FN_ID3_SIZB         1B48
FN_ID3_SIZL         1B60
FN_ID3_SIZW         1B54
FN_ID3_SRCMOD       1B6C
FN_ID3_VERIFY       1AC4
FN_ID4_CHECKD1      1D0E
FN_ID4_CHECKD2      1D32
FN_ID4_CHECKD3      1D62
FN_ID4_DATA         2068
FN_ID4_DATA_MVM     20EE
FN_ID4_DONE         2180
FN_ID4_DTABYT       20B8
FN_ID4_DTABYT_MVM   213E
FN_ID4_DTAIMD       2090
FN_ID4_DTAIMD_MVM   2116
FN_ID4_DTALNG       20DC
FN_ID4_DTALNG_MVM   2162
FN_ID4_DTAWRD       20CA
FN_ID4_DTAWRD_MVM   2150
FN_ID4_ERROR        217E
FN_ID4_GRABMASK     2174
FN_ID4_JSR          1D7A
FN_ID4_JSR_SRC      1E16
FN_ID4_LEA          1E26
FN_ID4_LEA_SRC      1E86
FN_ID4_MOVEMMTOR    1F06
FN_ID4_MOVEMRTOM    1E96
FN_ID4_MOVEM_SRC    1F72
FN_ID4_NOP          1F82
FN_ID4_NOT          1FC2
FN_ID4_NOT_SRC      1FFE
FN_ID4_RTS          2018
FN_ID4_VERIFY_JSR   1D86
FN_ID4_VERIFY_LEA   1E32
FN_ID4_VERIFY_MMR   1F12
FN_ID4_VERIFY_MRM   1EA2
FN_ID4_VERIFY_NOP   1F8E
FN_ID4_VERIFY_NOT   1FCE
FN_ID4_VERIFY_RTS   2024
FN_ID5_CHKDSTMOD    22A0
FN_ID5_CHKDSTREG    22B0
FN_ID5_DONE         22F2
FN_ID5_DTADSTLNG    22DE
FN_ID5_DTADSTWRD    22CC
FN_ID5_DTASRCBYT    226A
FN_ID5_DTASRCIMD    2242
FN_ID5_DTASRCLNG    228E
FN_ID5_DTASRCWRD    227C
FN_ID5_ERROR        22F0
FN_ID5_VERIFY       2202
FN_ID6_BEQ          237C
FN_ID6_BGT          2386
FN_ID6_BLE          2390
FN_ID6_BRA          2372
FN_ID6_DISPLACEMENT  2396
FN_ID6_DONE         23EA
FN_ID6_DSPLCMNT16   23C4
FN_ID6_DSPLCMNT32   23D6
FN_ID6_ERROR        23E8
FN_ID7_DONE         247A
FN_ID7_ERROR        2478
FN_ID8_CASE1        2518
FN_ID8_CASE2        255A
FN_ID8_DATADST      2582
FN_ID8_DATASRC      2608
FN_ID8_DONE         2690
FN_ID8_DTADSTBYT    25D2
FN_ID8_DTADSTIMD    25AA
FN_ID8_DTADSTLNG    25F6
FN_ID8_DTADSTWRD    25E4
FN_ID8_DTASRCBYT    2658
FN_ID8_DTASRCIMD    2630
FN_ID8_DTASRCLNG    267C
FN_ID8_DTASRCWRD    266A
FN_ID8_ERROR        268E
FN_ID9_CASE1        272E
FN_ID9_CASE2        2770
FN_ID9_DATADST      2798
FN_ID9_DATASRC      281E
FN_ID9_DONE         28A6
FN_ID9_DTADSTBYT    27E8
FN_ID9_DTADSTIMD    27C0
FN_ID9_DTADSTLNG    280C
FN_ID9_DTADSTWRD    27FA
FN_ID9_DTASRCBYT    286E
FN_ID9_DTASRCIMD    2846
FN_ID9_DTASRCLNG    2892
FN_ID9_DTASRCWRD    2880
FN_ID9_ERROR        28A4
FN_IDA_DONE         28B0
FN_IDB_DONE         28B2
FN_IDC_CASE1        2948
FN_IDC_CASE2        298A
FN_IDC_DATADST      29B2
FN_IDC_DATASRC      2A38
FN_IDC_DONE         2AC0
FN_IDC_DTADSTBYT    2A02
FN_IDC_DTADSTIMD    29DA
FN_IDC_DTADSTLNG    2A26
FN_IDC_DTADSTWRD    2A14
FN_IDC_DTASRCBYT    2A88
FN_IDC_DTASRCIMD    2A60
FN_IDC_DTASRCLNG    2AAC
FN_IDC_DTASRCWRD    2A9A
FN_IDC_ERROR        2ABE
FN_IDD_CASE1        2B70
FN_IDD_CASE2        2BB8
FN_IDD_CASE3        2BE6
FN_IDD_DATADST      2C14
FN_IDD_DATASRC      2C9A
FN_IDD_DONE         2D22
FN_IDD_DTADSTBYT    2C64
FN_IDD_DTADSTIMD    2C3C
FN_IDD_DTADSTLNG    2C88
FN_IDD_DTADSTWRD    2C76
FN_IDD_DTASRCBYT    2CEA
FN_IDD_DTASRCIMD    2CC2
FN_IDD_DTASRCLNG    2D0E
FN_IDD_DTASRCWRD    2CFC
FN_IDD_ERROR        2D20
FN_MAIN_CHKAGN      1162
FN_MAIN_CHKEND      1154
FN_MAIN_CHKLIN      111C
FN_MAIN_CHKPAG      1132
FN_MAIN_CONTINUE    119A
FN_MAIN_DONE        119E
FN_MAIN_DSP         1116
FN_MAIN_ERRINS      1110
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_UI_CHKHEX        13FE
FN_UI_CHKHEXASL     1452
FN_UI_CHKHEXDONE    143A
FN_UI_CHKHEXLOOP    1404
FN_UI_CHKHEXRDR     1454
FN_UI_CHKLEN        13CA
FN_UI_CHKVAL        14DE
FN_UI_CHKVALCMP     1512
FN_UI_CHKVALEBIG    150C
FN_UI_CHKVALEMAX    14FE
FN_UI_CHKVALSBIG    14F8
FN_UI_CHKVALSMAX    14EA
FN_UI_CHKVALSONE    1538
FN_UI_CHKVALSWP     151C
FN_UI_CHKVALSWRD    1522
FN_UI_DONE          153A
FN_UI_DSPSTART      127A
FN_UI_END           1372
FN_UI_ENDE1         138E
FN_UI_ENDE2         139E
FN_UI_END_IN        13AE
FN_UI_HDRNEXT       129E
FN_UI_LOOP          1248
FN_UI_SETEHEX       14B6
FN_UI_SETEHEXI1     14C6
FN_UI_SETEHEXI2     14D2
FN_UI_SETELEN       13D6
FN_UI_SETELENI1     13E6
FN_UI_SETELENI2     13F2
FN_UI_SETVHEX       145E
FN_UI_SETVHEXI1     146E
FN_UI_SETVHEXI2     1492
FN_UI_START         131A
FN_UI_STARTE1       1336
FN_UI_STARTE2       1346
FN_UI_START_IN      1356
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             3159
MSGENDMEM01         30F4
MSGENDMEM02         3127
MSGERR              2EA6
MSGHDR01            2EAC
MSGHDR02A           2EC3
MSGHDR02B           2ED1
MSGINTEMP           2E55
MSGLINE             3183
MSGNEWLINE          31B8
MSGPAGE             30D1
MSGSTRADR1          2FE1
MSGSTRADR1ERR1      3003
MSGSTRADR1ERR2      3025
MSGSTRADR1SCC       3052
MSGSTRADR2          3065
MSGSTRADR2ERR1      3086
MSGSTRADR2ERR2      30A6
MSGSTRINTRO         2ED6
MSGSTRNOTE          2F8B
MSGSTRNOTEMORE      2FCC
MSGSTRRANGE         2F05
MSGSTRSIZE          2F37
MSGSTRSIZEEXMPL     2F6C
OPBLANK             31C4
OPCOMMA             31BB
OPDSTMOD            2DB6
OPDSTREG            2DB5
OPDTA1              2DBA
OPDTA1T             2DBE
OPDTA2              2DC0
OPDTA2T             2DC4
OPERR               2D4D
OPID                2D4C
OPIR                2DDA
OPMASK              2DD4
OPNAM_ADD           2E2B
OPNAM_ADDA          2E2F
OPNAM_ADDQ          2E05
OPNAM_AND           2E27
OPNAM_ASL           2E34
OPNAM_ASR           2E38
OPNAM_BEQ           2E0E
OPNAM_BGT           2E12
OPNAM_BLE           2E16
OPNAM_BRA           2E0A
OPNAM_DATA          2DDB
OPNAM_JSR           2E01
OPNAM_LEA           2DEB
OPNAM_LSL           2E3C
OPNAM_LSR           2E40
OPNAM_MOVE          2DE0
OPNAM_MOVEA         2DE5
OPNAM_MOVEM         2DF3
OPNAM_MOVEQ         2E1A
OPNAM_NOP           2DF9
OPNAM_NOT           2DEF
OPNAM_OR            2E20
OPNAM_ROL           2E44
OPNAM_ROR           2E48
OPNAM_RTS           2DFD
OPNAM_SUB           2E23
OPNXTADR            2D5C
OPOUTBUF            2D60
OPPERIOD            31BD
OPPTRNAM            2DB0
OPROTATE            2DD8
OPSIZB              2E4C
OPSIZDIR            2DD9
OPSIZL              2E52
OPSIZW              2E4F
OPSPACE             31BF
OPSRCMOD            2DB8
OPSRCREG            2DB7
OPSTRADR            2D52
OPSTRDTALNG         2DCA
OPSTRDTAWRD         2DC5
OPTAB               31C2
OPVALADR            2D4E
OPVALSIZ            2DB4
OPWORD              2D4A
SR_ASCII_HEX        1996
SR_CNT_STR_BUF      1A16
SR_CPY_STR_BUF      1A06
SR_DSP_DISPLAY      15B4
SR_DSP_HEADER       1552
SR_HEX_ASCII        19BC
SR_HEX_STR          19D4
SR_ID3              1A1A
SR_ID4              1C5C
SR_ID5              218A
SR_ID6              22FC
SR_ID7              23F4
SR_ID8              2484
SR_ID9              269A
SR_IDA              28B0
SR_IDB              28B2
SR_IDC              28B4
SR_IDD              2ACA
SR_IDE              2D2C
SR_IDX              1A18
SR_JUMP             11B8
SR_UI_INPUT         1238
