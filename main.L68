00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 3/7/2021 2:34:57 PM

00000000                             1  ** -----------------------------------------------------------
00000000                             2  * Title      : Disassembler
00000000                             3  * Written by : 3 Cores
00000000                             4  * Date       : Winter 2021
00000000                             5  * Description: CSS 422 machine code disassembler
00000000                             6  ** -----------------------------------------------------------
00000000                             7  
00001000                             8                      ORG    $1000
00001000                             9  
00001000                            10  ** -----------------------------------------------------------
00001000                            11  ** MAIN LOGIC
00001000                            12  **
00001000                            13  ** Program data (do not overwrite)
00001000                            14  **   D0 - Reserved for Trap
00001000                            15  **   D1 - Reserved for Trap
00001000                            16  **   D2 - Reserved for Trap
00001000                            17  **   D7 - Line Counter (do not overwrite)
00001000                            18  
00001000                            19  **   A0 - Jump Table
00001000                            20  **   A1 - Reserved for Trap
00001000                            21  **   A2 - Pointer to Instruction space (the contents being disassembled)
00001000                            22  **   A3 - Pointer to Output buffer
00001000                            23  **   A7 - Stack pointer
00001000                            24  **
00001000                            25  ** Other data (ok to overwrite)
00001000                            26  **   D3 - misc
00001000                            27  **   D4 - misc
00001000                            28  **   D5 - misc
00001000                            29  **   D6 - misc
00001000                            30  **   A4 - misc
00001000                            31  **   A5 - misc
00001000                            32  **   A6 - misc
00001000                            33  **
00001000                            34  ** -----------------------------------------------------------
00001000                            35  MAIN
00001000  2E7C 00100000             36                      MOVEA.L #$00100000,SP           * Initialize stack pointer
00001006                            37  Fn_MAIN_Start
00001006                            38  
00001006                            39                      ** Test addresses if SR_UI_INPUT is turned off
00001006                            40                      **
00001006  23FC 00009000 00002C56    41                      MOVE.L  #$00009000, adrValStart
00001010  23FC 000093D0 00002C64    42                      MOVE.L  #$000093D0, adrValEnd
0000101A                            43  
0000101A                            44                      ** Address input interface
0000101A                            45                      ** Note: comment out to run tests
0000101A                            46                      **
0000101A                            47                      *JSR     SR_UI_INPUT             * Initiate user input for addresses
0000101A                            48  
0000101A                            49                      ** Load address strings for display
0000101A                            50                      **
0000101A  49F9 00002C56             51                      LEA     adrValStart,A4
00001020  4BF9 00002C5A             52                      LEA     adrStrStart,A5
00001026  4EB9 000019D4             53                      JSR     SR_HEX_STR              * Copy address value to string for display
0000102C  49F9 00002C64             54                      LEA     adrValEnd,A4
00001032  4BF9 00002C68             55                      LEA     adrStrEnd,A5
00001038  4EB9 000019D4             56                      JSR     SR_HEX_STR              * Copy address value to string for display
0000103E                            57  
0000103E                            58                      ** Main program variable setup
0000103E                            59                      ** Note: Don't change this!
0000103E                            60                      **
0000103E  4207                      61                      CLR.B   D7                      * Reset line counter to zero
00001040  41F9 000011B8             62                      LEA     SR_JUMP,A0              * Mem space for jump table
00001046  2479 00002C56             63                      MOVE.L  adrValStart,A2          * Mem space for disassembly
0000104C                            64  
0000104C                            65                      ** Clear screen
0000104C  103C 000B                 66                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001050  323C FF00                 67                      MOVE.W  #$FF00,D1               * Clear the screen
00001054  4E4F                      68                      TRAP    #15
00001056                            69  
00001056                            70                      ** Display header
00001056  4EB9 00001552             71                      JSR     SR_DSP_HEADER
0000105C                            72  fn_MAIN_Loop
0000105C                            73                      ** Prepare loop variables
0000105C                            74                      **
0000105C  23CA 00002C76             75                      MOVE.L  A2,opValAdr             * Set output address as current - need for display
00001062  33DA 00002C72             76                      MOVE.W  (A2)+,opWord            * load first 4 bit OpCode Word, increment A2 (4 bytes)
00001068  23CA 00002C84             77                      MOVE.L  A2,opNxtAdr             * Save next valid word address for invalid instruction
0000106E                            78  
0000106E                            79                      ** Reset local variables
0000106E                            80                      **
0000106E                            81  
0000106E  13FC 0000 00002C74        82                      MOVE.B  #$00,opID               * Reset opID (first 4 bits of opcode word)
00001076  13FC 0001 00002C75        83                      MOVE.B  #$01,opErr              * Reset error $01 - assume error until instruction found
0000107E  13FC 00FF 00002CDC        84                      MOVE.b  #$FF,opValSiz
00001086                            85  
00001086  13FC 00FF 00002CDD        86                      MOVE.B  #$FF, opDstReg
0000108E  13FC 00FF 00002CDE        87                      MOVE.B  #$FF, opDstMod
00001096  13FC 00FF 00002CDF        88                      MOVE.B  #$FF, opSrcReg
0000109E  13FC 00FF 00002CE0        89                      MOVE.B  #$FF, opSrcMod
000010A6                            90  
000010A6  23FC 00000000 00002CE2    91                      MOVE.L  #$0000, opDta1
000010B0  13FC 00FF 00002CE6        92                      MOVE.B  #$FF, opDta1T
000010B8  23FC 00000000 00002CE8    93                      MOVE.L  #$0000, opDta2
000010C2  13FC 00FF 00002CEC        94                      MOVE.B  #$FF, opDta2T
000010CA                            95  
000010CA  23FC 00000000 00002CFC    96                      MOVE.L  #$00000000,opMask
000010D4  13FC 0000 00002D00        97                      MOVE.B  #$00,opRotate
000010DC  13FC 0000 00002D01        98                      MOVE.B  #$00,opSizDir
000010E4  13FC 0000 00002D02        99                      MOVE.B  #$00,opIR
000010EC                           100  
000010EC                           101                      ** Jump table
000010EC                           102                      **
000010EC  3A39 00002C72            103                      MOVE.W  opWord,D5               * opWord to D5 for multiplication
000010F2  1C3C 000C                104                      MOVE.B  #12,D6
000010F6  EC6D                     105                      LSR.W   D6,D5                   * Shift 12 bits to the right (to get first 4 bits)
000010F8  CAFC 0008                106                      MULU    #8,D5                   * offset is multiple of 8
000010FC  4EB0 5000                107                      JSR     0(A0,D5)                * Jump indirect with index
00001100                           108  
00001100                           109                      ** Invalid instruction
00001100                           110                      **
00001100  0C39 0001 00002C75       111                      CMP.B   #1,opErr
00001108  6700 0006                112                      BEQ     Fn_MAIN_ErrIns          * Instruction error, reset A2
0000110C  6000 0008                113                      BRA     Fn_MAIN_Dsp             * Instruction valid, display
00001110  2479 00002C84            114  Fn_MAIN_ErrIns      MOVE.L  opNxtAdr,A2             * Resetting A2 to next valid word
00001116                           115  
00001116                           116                      ** Display result
00001116                           117                      **
00001116  4EB9 000015B4            118  Fn_MAIN_Dsp         JSR     SR_DSP_DISPLAY
0000111C                           119  
0000111C                           120                      ** Max lines display stop, wait for enter
0000111C                           121                      **
0000111C  5207                     122  Fn_MAIN_ChkLin      ADDI.B  #1,D7                   * Increment line counter
0000111E                           123  
0000111E  2C07                     124                      MOVE.L  D7,D6                   * Line counter to D6 for division
00001120  8CFC 001A                125                      DIVU.W  #maxLines,D6            * Divide unsigned -> [remainder|quotient]
00001124  4846                     126                      SWAP    D6                      * Swap for remainder (modulo)
00001126  BC3C 0000                127                      CMP.B   #0,D6                   * Check remainder for zero
0000112A  6700 0006                128                      BEQ     Fn_MAIN_ChkPag          * Reached the maximum number of lines per page
0000112E  6000 0024                129                      BRA     Fn_MAIN_ChkEnd          * Continue to Check if at End of address space
00001132                           130  
00001132                           131                      ** Logic to check ENTER key to show next page
00001132                           132                      **
00001132  43F9 00002FF9            133  Fn_MAIN_ChkPag      LEA     msgPage,A1              * Loads MESSAGE into A1
00001138  103C 000E                134                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000113C  4E4F                     135                      TRAP    #15                     * Display to screen
0000113E  103C 0005                136                      MOVE.B  #5,D0                   * Trap task 2 does the following:
00001142  4E4F                     137                      TRAP    #15                     * Read single char into D1.B - repurposed for ENTER key
00001144                           138  
00001144                           139                      ** Clear screen
00001144  103C 000B                140                      MOVE.B  #11,D0                  * Trap task 2 does the following:
00001148  323C FF00                141                      MOVE.W  #$FF00,D1               * Clear the screen
0000114C  4E4F                     142                      TRAP    #15
0000114E                           143  
0000114E                           144                      ** Display header
0000114E  4EB9 00001552            145                      JSR     SR_DSP_HEADER
00001154                           146  
00001154                           147                      ** Reached end of memory @ A2 - stop main logic, ask to do it again
00001154                           148                      **
00001154  B5F9 00002C64            149  Fn_MAIN_ChkEnd      CMP.L   adrValEnd, A2
0000115A  6C00 0006                150                      BGE     Fn_MAIN_ChkAgn          * Reached end of memory region
0000115E  6000 003A                151                      BRA     Fn_MAIN_Continue        * Continue to next loop iteration
00001162                           152  
00001162                           153                      ** Logic to check for for Y or N to check another region of memory
00001162                           154                      **
00001162  43F9 0000301C            155  Fn_MAIN_ChkAgn      LEA     msgEndMem01,A1          * Loads MESSAGE into A1
00001168  103C 000E                156                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000116C  4E4F                     157                      TRAP    #15                     * Display to screen
0000116E  43F9 0000304F            158                      LEA     msgEndMem02,A1          * Loads MESSAGE into A1
00001174  103C 000E                159                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001178  4E4F                     160                      TRAP    #15                     * Display to screen
0000117A                           161  
0000117A  43F9 00002D7D            162                      LEA     msgInTemp,A1            * Load placeholder for input string
00001180  103C 0002                163                      MOVE.B  #2,D0                   * Trap task 2 does the following:
00001184  4E4F                     164                      TRAP    #15                     * Read string to (A1), length in D1.W
00001186  0C11 0059                165                      CMP.B   #$59,(A1)               * Checking for 'Y' - otherwise Nope
0000118A  6700 FE7A                166                      BEQ     Fn_MAIN_Start           * Restart program
0000118E  0C11 0079                167                      CMP.B   #$79,(A1)               * Checking for 'y' - otherwise Nope
00001192  6700 FE72                168                      BEQ     Fn_MAIN_Start           * Restart program
00001196  6000 0006                169                      BRA     Fn_Main_Done            * Exit program
0000119A                           170  
0000119A  6000 FEC0                171  Fn_MAIN_Continue    BRA     Fn_MAIN_Loop            * Loop around and check another Word
0000119E                           172  
0000119E                           173  Fn_MAIN_Done        ** That's all folks
0000119E  103C 000B                174                      MOVE.B  #11,D0                  * Trap task 2 does the following:
000011A2  323C FF00                175                      MOVE.W  #$FF00,D1               * Clear the screen
000011A6  4E4F                     176                      TRAP    #15
000011A8                           177  
000011A8                           178                      ** Thank you message
000011A8  43F9 00003081            179                      LEA     msgDone,A1              * Loads MESSAGE into A1
000011AE  103C 000E                180                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000011B2  4E4F                     181                      TRAP    #15                     * Display to screen
000011B4                           182  
000011B4                           183  
000011B4  4E72 2700                184                      STOP   #$2700                   * Stop execution
000011B8                           185  
000011B8                           186  ** -----------------------------------------------------------
000011B8                           187  ** JUMP TABLE: First 4 bits of instruction
000011B8                           188  **
000011B8                           189  ** Jump instruction: pointing to label (xxx).L
000011B8                           190  **  |4    E    |F    9     |00 |00 |04 |80 - Offset 6 bytes
000011B8                           191  **                          label address (Long)
000011B8                           192  **
000011B8                           193  ** RTS instruction:
000011B8                           194  **  |4    E    |7    5     |               - Offset 2 bytes
000011B8                           195  **
000011B8                           196  ** e.g. If looking for code0010 - 8 bytes (offset) * 4 bit code (0 to 15)
000011B8                           197  **
000011B8                           198  ** Note: should find a value since 4 bits is 0 to F
000011B8                           199  ** Note: There aren't any instructions that start with F
000011B8                           200  **
000011B8                           201  ** -----------------------------------------------------------
000011B8  4EB9 00001A18            202  SR_JUMP             JSR     SR_IDX                  * No instructions @ ID=0
000011BE  4E75                     203                      RTS
000011C0  4EB9 00001A1A            204                      JSR     SR_ID3
000011C6  4E75                     205                      RTS
000011C8  4EB9 00001A1A            206                      JSR     SR_ID3
000011CE  4E75                     207                      RTS
000011D0  4EB9 00001A1A            208                      JSR     SR_ID3                  * Instructions @ ID=1,2,3 MOVE, MOVEA
000011D6  4E75                     209                      RTS
000011D8  4EB9 00001C5C            210                      JSR     SR_ID4
000011DE  4E75                     211                      RTS
000011E0  4EB9 000020EA            212                      JSR     SR_ID5
000011E6  4E75                     213                      RTS
000011E8  4EB9 00002254            214                      JSR     SR_ID6
000011EE  4E75                     215                      RTS
000011F0  4EB9 00002344            216                      JSR     SR_ID7
000011F6  4E75                     217                      RTS
000011F8  4EB9 000023CC            218                      JSR     SR_ID8
000011FE  4E75                     219                      RTS
00001200  4EB9 000025DA            220                      JSR     SR_ID9
00001206  4E75                     221                      RTS
00001208  4EB9 000027E8            222                      JSR     SR_IDA
0000120E  4E75                     223                      RTS
00001210  4EB9 000027EA            224                      JSR     SR_IDB
00001216  4E75                     225                      RTS
00001218  4EB9 000027EC            226                      JSR     SR_IDC
0000121E  4E75                     227                      RTS
00001220  4EB9 000029FA            228                      JSR     SR_IDD
00001226  4E75                     229                      RTS
00001228  4EB9 00002C54            230                      JSR     SR_IDE
0000122E  4E75                     231                      RTS
00001230  4EB9 00001A18            232                      JSR     SR_IDX                   * No instructions @ ID=15
00001236  4E75                     233                      RTS
00001238                           234  
00001238                           235  ** -----------------------------------------------------------
00001238                           236  ** UI: User mem input
00001238                           237  ** -----------------------------------------------------------
00001238                           238  SR_UI_INPUT
00001238  13F8 00FF 00002C63       239                      MOVE.B  $FF,adrStsStart         * Reset starting address status
00001240  13F8 00FF 00002C71       240                      MOVE.B  $FF,adrStsEnd           * Reset ending address status
00001248                           241  
00001248                           242  Fn_UI_Loop          ** Clear screen
00001248  103C 000B                243                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000124C  323C FF00                244                      MOVE.W  #$FF00,D1               * Clear the screen
00001250  4E4F                     245                      TRAP    #15
00001252                           246  
00001252                           247                      ** Header
00001252                           248                      ** ***************************************
00001252                           249  
00001252  43F9 000030AB            250                      LEA     msgLine,A1              * '********************'
00001258  103C 000E                251                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000125C  4E4F                     252                      TRAP    #15                     * Display to screen
0000125E                           253  
0000125E  43F9 00002DD4            254                      LEA     msgHdr01,A1             * '3 Cores disassembler'
00001264  103C 000E                255                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001268  4E4F                     256                      TRAP    #15                     * Display to screen
0000126A                           257  
0000126A  0C39 0000 00002C63       258                      CMP.B   #0,adrStsStart          * Starting address is set
00001272  6700 0006                259                      BEQ     Fn_UI_DspStart          * Display starting address
00001276  6000 0026                260                      BRA     Fn_UI_HdrNext           * Display the rest of the header
0000127A                           261  
0000127A  43F9 00002F7A            262  Fn_UI_DspStart      LEA     msgStrAdr1Scc,A1        * 'Starting address: '
00001280  103C 000E                263                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001284  4E4F                     264                      TRAP    #15                     * Display to screen
00001286                           265  
00001286  43F9 00002C5A            266                      LEA     adrStrStart,A1          * '89ABCDEF' (string address)
0000128C  103C 000E                267                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001290  4E4F                     268                      TRAP    #15                     * Display to screen
00001292                           269  
00001292  43F9 000030E0            270                      LEA     msgNewLine,A1           * CR,LF
00001298  103C 000E                271                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000129C  4E4F                     272                      TRAP    #15                     * Display to screen
0000129E                           273  
0000129E  43F9 000030AB            274  Fn_UI_HdrNext       LEA     msgLine,A1              * '********************'
000012A4  103C 000E                275                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012A8  4E4F                     276                      TRAP    #15                     * Display to screen
000012AA                           277  
000012AA  43F9 00002DFE            278                      LEA     msgStrIntro,A1          * ' - All addresses must be 32 bit hexadecimal.'
000012B0  103C 000E                279                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012B4  4E4F                     280                      TRAP    #15                     * Display to screen
000012B6                           281  
000012B6  43F9 00002E2D            282                      LEA     msgStrRange,A1          * ' - Valid address range is 00000000 to 00FFFFFF.'
000012BC  103C 000E                283                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012C0  4E4F                     284                      TRAP    #15                     * Display to screen
000012C2                           285  
000012C2  43F9 00002E5F            286                      LEA     msgStrSize,A1           * ' - Starting address should start on a word boundry'
000012C8  103C 000E                287                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012CC  4E4F                     288                      TRAP    #15                     * Display to screen
000012CE                           289  
000012CE  43F9 00002E94            290                      LEA     msgStrSizeExmpl,A1      * '   @ XXXXXXX(0,2,4,8,A,C,E).'
000012D4  103C 000E                291                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012D8  4E4F                     292                      TRAP    #15                     * Display to screen
000012DA                           293  
000012DA  43F9 00002EB3            294                      LEA     msgStrNote,A1           * ' - Addresses will be adjusted if out of order or out of range.'
000012E0  103C 000E                295                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012E4  4E4F                     296                      TRAP    #15                     * Display to screen
000012E6                           297  
000012E6  43F9 00002EF4            298                      LEA     msgStrNoteMore,A1       * '   (automagically)'
000012EC  103C 000E                299                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012F0  4E4F                     300                      TRAP    #15                     * Display to screen
000012F2                           301  
000012F2  43F9 000030E0            302                      LEA     msgNewLine,A1           * CR,LF
000012F8  103C 000E                303                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000012FC  4E4F                     304                      TRAP    #15                     * Display to screen
000012FE                           305  
000012FE                           306                      ** Input check
000012FE                           307                      ** ***************************************
000012FE                           308  
000012FE  0C39 0000 00002C63       309                      CMP.B #0,adrStsStart            * Check status of address 0 = success
00001306  6600 0012                310                      BNE   Fn_UI_Start               * Input starting address
0000130A                           311  
0000130A  0C39 0000 00002C71       312                      CMP.B #0,adrStsEnd              * Check status of address 0 = success
00001312  6600 005E                313                      BNE   Fn_UI_End                 * Input ending address
00001316                           314  
00001316                           315                      *BRA   Fn_UI_Done                * Both addresses set, bail out of UI
00001316  6000 01C6                316                      BRA   Fn_UI_ChkVal              * Check address values (range, order)
0000131A                           317  
0000131A                           318  Fn_UI_Start         ** Input Start Address
0000131A                           319                      ** ***************************************
0000131A                           320  
0000131A                           321                      ** Check errors
0000131A  0C39 0001 00002C63       322                      CMP.B   #1,adrStsStart
00001322  6700 0012                323                      BEQ     Fn_UI_StartE1           * Error: length
00001326  0C39 0002 00002C63       324                      CMP.B   #2,adrStsStart
0000132E  6700 0016                325                      BEQ     Fn_UI_StartE2           * Error: hex value
00001332  6000 0022                326                      BRA     Fn_UI_Start_In          * No error: ask for input
00001336                           327  
00001336  43F9 00002F2B            328  Fn_UI_StartE1       LEA     msgStrAdr1Err1,A1       * 'Invalid starting address length'
0000133C  103C 000E                329                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001340  4E4F                     330                      TRAP    #15
00001342  6000 0012                331                      BRA     Fn_UI_Start_In          * User input
00001346                           332  
00001346  43F9 00002F4D            333  Fn_UI_StartE2       LEA     msgStrAdr1Err2,A1       * 'Invalid starting address hexadecimal value'
0000134C  103C 000E                334                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001350  4E4F                     335                      TRAP    #15
00001352  6000 0002                336                      BRA     Fn_UI_Start_In          * User input
00001356                           337  
00001356  43F9 00002F09            338  Fn_UI_Start_In      LEA     msgStrAdr1,A1           * 'Please enter a starting address'
0000135C  103C 000E                339                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001360  4E4F                     340                      TRAP    #15                     * Display to screen
00001362                           341  
00001362  43F9 00002D7D            342                      LEA     msgInTemp,A1            * Load placeholder for input string
00001368  103C 0002                343                      MOVE.B  #2,D0                   * Trap task 2 does the following:
0000136C  4E4F                     344                      TRAP    #15                     * Read string to (A1), length in D1.W
0000136E                           345  
0000136E  6000 005A                346                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
00001372                           347  
00001372                           348  Fn_UI_End           ** Input End Address
00001372                           349                      ** ***************************************
00001372                           350  
00001372                           351                      ** Check errors
00001372  0C39 0001 00002C71       352                      CMP.B   #1,adrStsEnd
0000137A  6700 0012                353                      BEQ     Fn_UI_EndE1             * Error: length
0000137E  0C39 0002 00002C71       354                      CMP.B   #2,adrStsEnd
00001386  6700 0016                355                      BEQ     Fn_UI_EndE2             * Error: hex value
0000138A  6000 0022                356                      BRA     Fn_UI_End_In            * No error: ask for input
0000138E                           357  
0000138E  43F9 00002FAE            358  Fn_UI_EndE1         LEA     msgStrAdr2Err1,A1       * 'Invalid ending address length'
00001394  103C 000E                359                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001398  4E4F                     360                      TRAP    #15
0000139A  6000 0012                361                      BRA     Fn_UI_End_In            * User input
0000139E                           362  
0000139E  43F9 00002FCE            363  Fn_UI_EndE2         LEA     msgStrAdr2Err2,A1       * 'Invalid ending address hexadecimal value'
000013A4  103C 000E                364                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013A8  4E4F                     365                      TRAP    #15
000013AA  6000 0002                366                      BRA     Fn_UI_End_In            * User input
000013AE                           367  
000013AE  43F9 00002F8D            368  Fn_UI_End_In        LEA     msgStrAdr2,A1           * 'Please enter a ending address'
000013B4  103C 000E                369                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000013B8  4E4F                     370                      TRAP    #15                     * Display to screen
000013BA                           371  
000013BA  43F9 00002D7D            372                      LEA     msgInTemp,A1            * Load placeholder for input string
000013C0  103C 0002                373                      MOVE.B  #2,D0                   * Trap task 2 does the following:
000013C4  4E4F                     374                      TRAP    #15                     * Read string to (A1), length in D1.W
000013C6                           375  
000013C6  6000 0002                376                      BRA     Fn_UI_ChkLen            * Check addresses (length, hex validation)
000013CA                           377  
000013CA                           378  Fn_UI_ChkLen        ** Check length
000013CA                           379                      **   length should be 8 ascii characters
000013CA                           380                      **   value stored in D1.W from input
000013CA                           381                      ** ***************************************
000013CA                           382  
000013CA  B27C 0008                383                      CMP.W   #8,D1                   * Address should be 8 chars long
000013CE  6600 0006                384                      BNE     Fn_UI_SetELen           * Invalid address length
000013D2  6000 002A                385                      BRA     Fn_UI_ChkHex            * Length ok, now check hex values
000013D6                           386  
000013D6                           387  Fn_UI_SetELen       ** Error: length
000013D6  0C39 0000 00002C63       388                      CMP.B #0,adrStsStart
000013DE  6600 0006                389                      BNE     Fn_UI_SetELenI1         * Error must be with first input
000013E2  6000 000E                390                      BRA     Fn_UI_SetELenI2         * Error must be with second input
000013E6                           391  Fn_UI_SetELenI1     ** Set error on input 1
000013E6  13FC 0001 00002C63       392                      MOVE.B  #1,adrStsStart          * Set error code 1 (invalid length)
000013EE  6000 FE58                393                      BRA     Fn_UI_Loop
000013F2                           394  Fn_UI_SetELenI2     ** Set error on input 2         * Set error code 1 (invalid length)
000013F2  13FC 0001 00002C71       395                      MOVE.B  #1,adrStsEnd
000013FA  6000 FE4C                396                      BRA     Fn_UI_Loop
000013FE                           397  
000013FE                           398  Fn_UI_ChkHex        ** Check hex values
000013FE                           399                      **   30 - 39 (0-9)
000013FE                           400                      **   41 - 46 (A-F), 61 - 66 (a - f)
000013FE                           401                      ** ***************************************
000013FE                           402  
000013FE  163C 0000                403                      MOVE.B  #0,D3                   * Loop counter
00001402  4286                     404                      CLR.L   D6                      * Temporary address storage
00001404                           405  
00001404                           406  Fn_UI_ChkHexLoop    ** Check hex values one at a time
00001404  1819                     407                      MOVE.B  (A1)+,D4                * Unload byte and increment input
00001406                           408  
00001406  B83C 0030                409                      CMP.B   #$30,D4
0000140A  6D00 00AA                410                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000140E                           411  
0000140E  B83C 0039                412                      CMP.B   #$39,D4
00001412  6F00 0026                413                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001416                           414  
00001416  B83C 0041                415                      CMP.B   #$41,D4
0000141A  6D00 009A                416                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000141E                           417  
0000141E  B83C 0046                418                      CMP.B   #$46,D4
00001422  6F00 0016                419                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001426                           420  
00001426  B83C 0061                421                      CMP.B   #$61,D4
0000142A  6D00 008A                422                      BLT     Fn_UI_SetEHex           * Error - invalid hex character
0000142E                           423  
0000142E  B83C 0066                424                      CMP.B   #$66,D4
00001432  6F00 0006                425                      BLE     Fn_UI_ChkHexDone        * Loop around to check next value
00001436                           426  
00001436  6000 007E                427                      BRA     Fn_UI_SetEHex           * Error - invalid hex character
0000143A                           428  
0000143A                           429  Fn_UI_ChkHexDone    ** Check if at end of loop
0000143A                           430  
0000143A  5203                     431                      ADDI.B  #1,D3                   * Increment loop counter
0000143C                           432  
0000143C                           433                      ** Insert ascii value into temp address
0000143C  1A04                     434                      MOVE.B  D4,D5                   * Load current value into D5 for conversion
0000143E  4EB9 00001996            435                      JSR     SR_ASCII_HEX            * Convert ascii to hex, return in D5
00001444  DC05                     436                      ADD.B   D5,D6                   * Insert hex value into temp storage
00001446  B63C 0008                437                      CMP.B   #8,D3                   * To shift or not to shift
0000144A  6D00 0006                438                      BLT     Fn_UI_ChkHexASL         * Shift D6 left when loop < 8
0000144E  6000 0004                439                      BRA     Fn_UI_ChkHexRdr         * No shift to D6 when loop >= 8
00001452  E986                     440  Fn_UI_ChkHexASL     ASL.L   #4,D6                   * Left shift 4 to make room for next hex value
00001454                           441  
00001454                           442  Fn_UI_ChkHexRdr     ** Check counter and redirect accordingly
00001454  B63C 0008                443                      CMP.B   #8,D3                   * Loop 8 times
00001458  66AA                     444                      BNE     Fn_UI_ChkHexLoop        * Back to Hex Loop
0000145A  6000 0002                445                      BRA     Fn_UI_SetVHex           * Set address as valid (done checking hex)
0000145E                           446  
0000145E                           447  Fn_UI_SetVHex       ** Valid: hex values
0000145E  0C39 0000 00002C63       448                      CMP.B   #0,adrStsStart          * Value of 0 means it is a valid address
00001466  6600 0006                449                      BNE     Fn_UI_SetVHexI1         * Error must be with first input
0000146A  6000 0026                450                      BRA     Fn_UI_SetVHexI2         * Error must be with second input
0000146E                           451  
0000146E                           452  Fn_UI_SetVHexI1     ** Set valid on input 1
0000146E  13FC 0000 00002C63       453                      MOVE.B  #0,adrStsStart          * Set valid code 0 (address is valid)
00001476  23C6 00002C56            454                      MOVE.L  D6,adrValStart          * Copy input address to adrValEnd
0000147C  49F9 00002C56            455                      LEA     adrValStart,A4
00001482  4BF9 00002C5A            456                      LEA     adrStrStart,A5
00001488  4EB9 000019D4            457                      JSR     SR_HEX_STR              * Copy address value to string for display
0000148E  6000 FDB8                458                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
00001492                           459  
00001492                           460  Fn_UI_SetVHexI2     ** Set valid on input 2
00001492  13FC 0000 00002C71       461                      MOVE.B  #0,adrStsEnd            * Set valid code 0 (address is valid)
0000149A  23C6 00002C64            462                      MOVE.L  D6,adrValEnd            * Copy input address to adrValEnd
000014A0  49F9 00002C64            463                      LEA     adrValEnd,A4
000014A6  4BF9 00002C68            464                      LEA     adrStrEnd,A5
000014AC  4EB9 000019D4            465                      JSR     SR_HEX_STR              * Copy address value to string for display
000014B2  6000 FD94                466                      BRA     Fn_UI_Loop              * Loop back to make sure both addresses set
000014B6                           467  
000014B6                           468  Fn_UI_SetEHex       ** Error: hex values
000014B6  0C39 0000 00002C63       469                      CMP.B   #0,adrStsStart
000014BE  6600 0006                470                      BNE     Fn_UI_SetEHexI1         * Error must be with first input
000014C2  6000 000E                471                      BRA     Fn_UI_SetEHexI2         * Error must be with second input
000014C6                           472  
000014C6                           473  Fn_UI_SetEHexI1     ** Set error on input 1
000014C6  13FC 0002 00002C63       474                      MOVE.B  #2,adrStsStart          * Set error code 2 (invalid hex values)
000014CE  6000 FD78                475                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014D2                           476  
000014D2                           477  Fn_UI_SetEHexI2     ** Set error on input 2
000014D2  13FC 0002 00002C71       478                      MOVE.B  #2,adrStsEnd            * Set error code 2 (invalid hex values)
000014DA  6000 FD6C                479                      BRA     Fn_UI_Loop              * Loop around to see if we are done
000014DE                           480  
000014DE                           481  Fn_UI_ChkVal        ** Check address range, order
000014DE                           482                      **   Address automagic - will fix addresses if invalid input
000014DE                           483                      ** Note: addresses are unsigned; should not be less than zero
000014DE                           484                      ** Note: use BHI instead of BGT to compare unsigned addresses
000014DE                           485                      ** Note: subtracting one from Start address if not even
000014DE                           486                      **       doesn't really matter if end address is even or odd
000014DE                           487                      ** ***************************************
000014DE                           488  
000014DE  2A39 00002C56            489                      MOVE.L  adrValStart,D5
000014E4  2C39 00002C64            490                      MOVE.L  adrValEnd,D6
000014EA                           491  
000014EA  BABC 00FFFFEC            492  Fn_UI_ChkValSMax    CMP.L   #$00FFFFEC,D5            * Start should be <= (max - 1)
000014F0  6200 0006                493                      BHI     Fn_UI_ChkValSBig         * Start is > (max - 1); Set start to (max - 1)
000014F4  6000 0008                494                      BRA     Fn_UI_ChkValEMax         * Start is <= (max - 1); Check if End < 0
000014F8                           495  
000014F8  2A3C 00FFFFEC            496  Fn_UI_ChkValSBig    MOVE.L  #$00FFFFEC,D5            * Set Start to (max - 1)
000014FE                           497  
000014FE  BCBC 00FFFFED            498  Fn_UI_ChkValEMax    CMP.L   #$00FFFFED,D6            * End should be <= max
00001504  6200 0006                499                      BHI     Fn_UI_ChkValEBig         * End is > max; Set End to max
00001508  6000 0008                500                      BRA     Fn_UI_ChkValCmp          * End is <= max; Check if Start > End
0000150C                           501  
0000150C  2C3C 00FFFFED            502  Fn_UI_ChkValEBig    MOVE.L  #$00FFFFED,D6            * Set End to max
00001512                           503  
00001512  BA86                     504  Fn_UI_ChkValCmp     CMP.L   D6,D5                    * Start should be <= End
00001514  6200 0006                505                      BHI     Fn_UI_ChkValSwp          * Start < End; Swap start and end
00001518  6000 0008                506                      BRA     FN_UI_ChkValSWrd         * Start >= End; Check Start word boundry
0000151C                           507  
0000151C  2805                     508  Fn_UI_ChkValSwp     MOVE.L  D5,D4
0000151E  2A06                     509                      MOVE.L  D6,D5
00001520  2C04                     510                      MOVE.L  D4,D6
00001522                           511  
00001522                           512  FN_UI_ChkValSWrd    ** Check start for word boundry
00001522  1605                     513                      MOVE.B  D5,D3                    * Move low order byte to D3 for division
00001524  183C 0002                514                      MOVE.B  #2,D4                    * Setup even/odd comparison
00001528  86C4                     515                      DIVU.W  D4,D3                    * Divide unsigned D3/D4
0000152A  4843                     516                      SWAP    D3                       * Swap for remainder (the modulo part)
0000152C  B63C 0000                517                      CMP.B   #0,D3                    * If zero, then even
00001530  6600 0006                518                      BNE     Fn_UI_ChkValSOne         * Start is not even; Subtract one from address
00001534  6000 0004                519                      BRA     Fn_UI_Done               * Start is even; finally, we're done
00001538                           520  
00001538  5385                     521  Fn_UI_ChkValSOne    SUBI.L  #1,D5
0000153A                           522  
0000153A                           523  Fn_UI_Done          ** All done with input, time to go
0000153A                           524                      ** ***************************************
0000153A                           525  
0000153A  23C5 00002C56            526                      MOVE.L  D5,adrValStart          * Move final address to Start
00001540  23C6 00002C64            527                      MOVE.L  D6,adrValEnd            * Move final address to End
00001546                           528  
00001546                           529                      ** Clear screen
00001546  103C 000B                530                      MOVE.B  #11,D0                  * Trap task 2 does the following:
0000154A  323C FF00                531                      MOVE.W  #$FF00,D1               * Clear the screen
0000154E  4E4F                     532                      TRAP    #15
00001550                           533  
00001550  4E75                     534                      RTS
00001552                           535  
00001552                           536  ** -----------------------------------------------------------
00001552                           537  ** UI: Display Header
00001552                           538  ** -----------------------------------------------------------
00001552                           539  SR_DSP_HEADER
00001552                           540  
00001552                           541                      ** Header line 03
00001552  43F9 000030AB            542                      LEA     msgLine,A1              * Loads MESSAGE into A1
00001558  103C 000E                543                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000155C  4E4F                     544                      TRAP    #15                     * Display to screen
0000155E                           545  
0000155E                           546                      ** Header line 01
0000155E  43F9 00002DD4            547                      LEA     msgHdr01,A1             * Loads MESSAGE into A1
00001564  103C 000E                548                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001568  4E4F                     549                      TRAP    #15                     * Display to screen
0000156A                           550  
0000156A                           551                      ** Header line 02
0000156A  43F9 00002DEB            552                      LEA     msgHdr02a,A1            * Loads MESSAGE into A1
00001570  103C 000E                553                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001574  4E4F                     554                      TRAP    #15                     * Display to screen
00001576                           555  
00001576  43F9 00002C5A            556                      LEA     adrStrStart,A1          * Loads MESSAGE into A1
0000157C  103C 000E                557                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001580  4E4F                     558                      TRAP    #15                     * Display to screen
00001582                           559  
00001582  43F9 00002DF9            560                      LEA     msgHdr02b,A1            * Loads MESSAGE into A1
00001588  103C 000E                561                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
0000158C  4E4F                     562                      TRAP    #15
0000158E                           563  
0000158E  43F9 00002C68            564                      LEA     adrStrEnd,A1          * Loads MESSAGE into A1
00001594  103C 000E                565                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
00001598  4E4F                     566                      TRAP    #15                     * Display to screen
0000159A                           567  
0000159A  43F9 000030E0            568                      LEA     msgNewLine,A1           * Loads MESSAGE into A1
000015A0  103C 000E                569                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015A4  4E4F                     570                      TRAP    #15                     * Display to screen
000015A6                           571  
000015A6                           572                      ** Header line 03
000015A6  43F9 000030AB            573                      LEA     msgLine,A1              * Loads MESSAGE into A1
000015AC  103C 000E                574                      MOVE.B  #14,D0                  * Use (A1) no CR/LF
000015B0  4E4F                     575                      TRAP    #15                     * Display to screen
000015B2                           576  
000015B2  4E75                     577                      RTS
000015B4                           578  
000015B4                           579  ** -----------------------------------------------------------
000015B4                           580  ** UI: Display item
000015B4                           581  ** -----------------------------------------------------------
000015B4                           582  SR_DSP_DISPLAY
000015B4                           583                      ** Output buffer
000015B4                           584                      **   Need buffer for spacing issues
000015B4                           585                      **
000015B4  47F9 00002C88            586                      LEA     opOutBuf,A3             * Reset pointer to output buffer
000015BA  16BC 0000                587                      MOVE.B  #$00,(A3)               * Insert NULL
000015BE                           588  
000015BE                           589                      ** Push opValAdr to opStrAdr
000015BE  49F9 00002C76            590                      LEA     opValAdr,A4             * input hex
000015C4  4BF9 00002C7A            591                      LEA     opStrAdr,A5             * output string
000015CA  4EB9 000019D4            592                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000015D0  49F9 00002C7A            593                      LEA     opStrAdr,A4
000015D6  4EB9 00001A06            594                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015DC                           595  
000015DC                           596                      ** Instruction or DATA redirector
000015DC                           597                      **
000015DC  0C39 0001 00002C75       598                      CMP.B   #1, opErr               * Check instruction type
000015E4  6700 0006                599                      BEQ     Fn_Dsp_Data             * Error flag - must be data
000015E8  6000 001E                600                      BRA     Fn_Dsp_Instr            * No error flag - must be instruction
000015EC                           601  
000015EC                           602  Fn_Dsp_Data         ** Process invalid instruction (DATA)
000015EC                           603                      **
000015EC                           604  
000015EC                           605                      ** Space
000015EC  49F9 000030E7            606                      LEA     opSpace,A4
000015F2  4EB9 00001A06            607                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000015F8                           608  
000015F8                           609                      ** Instruction name
000015F8  49F9 00002D03            610                      LEA     opNam_DATA,A4
000015FE  4EB9 00001A06            611                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001604                           612  
00001604  6000 037E                613                      BRA     Fn_Dsp_Done
00001608                           614  
00001608                           615  Fn_Dsp_Instr        ** Process instruction
00001608                           616                      **
00001608                           617  
00001608                           618                      ** Space
00001608  49F9 000030E7            619                      LEA     opSpace,A4
0000160E  4EB9 00001A06            620                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001614                           621  
00001614                           622                      ** Instruction name
00001614  2879 00002CD8            623                      MOVE.L  opPtrNam,A4
0000161A  4EB9 00001A06            624                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001620                           625  
00001620                           626                      ** Instruciton size
00001620                           627                      **
00001620  0C39 0000 00002CDC       628                      CMP.B   #0,opValSiz
00001628  6700 001E                629                      BEQ     Fn_DSP_SizB             * Size is Byte
0000162C  0C39 0001 00002CDC       630                      CMP.B   #1,opValSiz
00001634  6700 0022                631                      BEQ     Fn_DSP_SizW             * Size is Word
00001638  0C39 0002 00002CDC       632                      CMP.B   #2,opValSiz
00001640  6700 0026                633                      BEQ     Fn_DSP_SizL             * Size is Long
00001644  6000 003E                634                      BRA     Fn_DSP_DTA1             * Size not set, go to check Data 1
00001648                           635  
00001648  49F9 00002D74            636  Fn_DSP_SizB         LEA     opSizB,A4               * '.B' string
0000164E  4EB9 00001A06            637                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001654  6000 0022                638                      BRA     Fn_DSP_OPR1
00001658                           639  
00001658  49F9 00002D77            640  Fn_DSP_SizW         LEA     opSizW,A4               * '.W' string
0000165E  4EB9 00001A06            641                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001664  6000 0012                642                      BRA     Fn_DSP_OPR1
00001668                           643  
00001668  49F9 00002D7A            644  Fn_DSP_SizL         LEA     opSizL,A4              * '.L' string
0000166E  4EB9 00001A06            645                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001674  6000 0002                646                      BRA     Fn_DSP_OPR1
00001678                           647  
00001678                           648  Fn_DSP_OPR1         ** Display First Operand
00001678  49F9 000030EA            649                      LEA     opTab,A4                * Tab (or calculated spaces)
0000167E  4EB9 00001A06            650                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001684                           651  
00001684                           652  Fn_DSP_DTA1         ** Data 1 (source)
00001684                           653                      ** **************************************************
00001684                           654                      **
00001684                           655  
00001684                           656                      ** Check if source mode set (may not have a source)
00001684  0C39 00FF 00002CE2       657                      CMP.B   #$FF,opDta1
0000168C  6700 017C                658                      BEQ     Fn_DSP_DTA2             * No source data, goto check Dta2
00001690                           659  
00001690                           660                      ** Check source mode
00001690                           661                      **
00001690  0C39 0000 00002CE0       662                      CMP.B   #0,opSrcMod
00001698  6700 0042                663                      BEQ     Fn_DSP_DTA1_00          * Handle Reg Mode 0 Dn
0000169C  0C39 0001 00002CE0       664                      CMP.B   #1,opSrcMod
000016A4  6700 004A                665                      BEQ     Fn_DSP_DTA1_01          * Handle Reg Mode 1 An
000016A8  0C39 0002 00002CE0       666                      CMP.B   #2,opSrcMod
000016B0  6700 0052                667                      BEQ     Fn_DSP_DTA1_02          * Handle Reg Mode 2 (An)
000016B4  0C39 0003 00002CE0       668                      CMP.B   #3,opSrcMod
000016BC  6700 0062                669                      BEQ     Fn_DSP_DTA1_03          * Handle Reg Mode 3 (An)+
000016C0  0C39 0004 00002CE0       670                      CMP.B   #4,opSrcMod
000016C8  6700 0076                671                      BEQ     Fn_DSP_DTA1_04          * Handle Reg Mode 4 -(An)
000016CC  0C39 0007 00002CE0       672                      CMP.B   #7,opSrcMod
000016D4  6700 008A                673                      BEQ     Fn_DSP_DTA1_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
000016D8                           674  
000016D8  6000 0114                675                      BRA     Fn_DSP_DTA1_ERR         * Mode not 1 to 7 - display error
000016DC                           676  
000016DC                           677  Fn_DSP_DTA1_00      ** Handling data mode 0
000016DC  16FC 0044                678                      MOVE.B  #$44,(A3)+              * Insert 'D' character
000016E0  1639 00002CDF            679                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016E6  0603 0030                680                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016EA  16C3                     681                      MOVE.B  D3,(A3)+                * Insert Register value
000016EC  6000 0110                682                      BRA     Fn_DSP_OPR2             * Display data 2
000016F0                           683  
000016F0                           684  Fn_DSP_DTA1_01      ** Handling data mode 1
000016F0  16FC 0041                685                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000016F4  1639 00002CDF            686                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000016FA  0603 0030                687                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000016FE  16C3                     688                      MOVE.B  D3,(A3)+                * Insert Register value
00001700  6000 00FC                689                      BRA     Fn_DSP_OPR2             * Display data 2
00001704                           690  
00001704                           691  Fn_DSP_DTA1_02      ** Handling data mode 2
00001704  16FC 0028                692                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001708  16FC 0041                693                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000170C  1639 00002CDF            694                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001712  0603 0030                695                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001716  16C3                     696                      MOVE.B  D3,(A3)+                * Insert Register value
00001718  16FC 0029                697                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000171C  6000 00E0                698                      BRA     Fn_DSP_OPR2             * Display data 2
00001720                           699  
00001720                           700  Fn_DSP_DTA1_03      ** Handling data mode 3
00001720  16FC 0028                701                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001724  16FC 0041                702                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001728  1639 00002CDF            703                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
0000172E  0603 0030                704                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001732  16C3                     705                      MOVE.B  D3,(A3)+                * Insert Register value
00001734  16FC 0029                706                      MOVE.B  #$29,(A3)+              * Insert ')' character
00001738  16FC 002B                707                      MOVE.B  #$2B,(A3)+              * Insert '+' character
0000173C  6000 00C0                708                      BRA     Fn_DSP_OPR2             * Display data 2
00001740                           709  
00001740                           710  Fn_DSP_DTA1_04      ** Handling data mode 4
00001740  16FC 002D                711                      MOVE.B  #$2D,(A3)+              * Insert '-' character
00001744  16FC 0028                712                      MOVE.B  #$28,(A3)+              * Insert '(' character
00001748  16FC 0041                713                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000174C  1639 00002CDF            714                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
00001752  0603 0030                715                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001756  16C3                     716                      MOVE.B  D3,(A3)+                * Insert Register value
00001758  16FC 0029                717                      MOVE.B  #$29,(A3)+              * Insert ')' character
0000175C  6000 00A0                718                      BRA     Fn_DSP_OPR2             * Display data 2
00001760                           719  
00001760                           720  Fn_DSP_DTA1_07      ** Handling data mode 7
00001760  0C39 0000 00002CE6       721                      CMP.B   #0,opDta1T
00001768  6700 001E                722                      BEQ     Fn_DSP_DTA1_BYT         * Display data as byte
0000176C  0C39 0001 00002CE6       723                      CMP.B   #1,opDta1T
00001774  6700 0034                724                      BEQ     Fn_DSP_DTA1_WRD         * Display data as word
00001778  0C39 0002 00002CE6       725                      CMP.B   #2,opDta1T
00001780  6700 004A                726                      BEQ     Fn_DSP_DTA1_LNG         * Display data as long
00001784                           727  
00001784  6000 0068                728                      BRA     Fn_DSP_DTA1_ERR         * Data type not 0 to 2 - display error
00001788                           729  
00001788                           730  Fn_DSP_DTA1_BYT     ** Display data Byte (it's really a word with 00 tacked on)
00001788  49F9 00002CE2            731                      LEA     opDta1,A4               * input hex
0000178E  4BF9 00002CED            732                      LEA     opStrDtaWrd,A5          * output string
00001794  4EB9 000019D4            733                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
0000179A  49F9 00002CED            734                      LEA     opStrDtaWrd,A4
000017A0  4EB9 00001A06            735                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017A6  6000 0056                736                      BRA     Fn_DSP_OPR2             * Display data 2
000017AA                           737  
000017AA                           738  Fn_DSP_DTA1_WRD     ** Display data Word
000017AA  49F9 00002CE2            739                      LEA     opDta1,A4               * input hex
000017B0  4BF9 00002CED            740                      LEA     opStrDtaWrd,A5          * output string
000017B6  4EB9 000019D4            741                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017BC  49F9 00002CED            742                      LEA     opStrDtaWrd,A4
000017C2  4EB9 00001A06            743                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017C8  6000 0034                744                      BRA     Fn_DSP_OPR2             * Display data 2
000017CC                           745  
000017CC                           746  Fn_DSP_DTA1_LNG     ** Display data Long
000017CC  49F9 00002CE2            747                      LEA     opDta1,A4               * input hex
000017D2  4BF9 00002CF2            748                      LEA     opStrDtaLng,A5          * output string
000017D8  4EB9 000019D4            749                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
000017DE  49F9 00002CF2            750                      LEA     opStrDtaLng,A4
000017E4  4EB9 00001A06            751                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017EA  6000 0012                752                      BRA     Fn_DSP_OPR2             * Display data 2
000017EE                           753  
000017EE                           754  Fn_DSP_DTA1_ERR     ** Something is messed up
000017EE  49F9 00002DCE            755                      LEA     msgErr,A4
000017F4  4EB9 00001A06            756                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
000017FA  6000 0002                757                      BRA     Fn_DSP_OPR2             * Display data 2
000017FE                           758  
000017FE                           759  Fn_DSP_OPR2         ** Display Second Operand
000017FE  49F9 000030E3            760                      LEA     opComma,A4              * Comma
00001804  4EB9 00001A06            761                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000180A                           762  
0000180A                           763  Fn_DSP_DTA2         ** Data 2 (destination)
0000180A                           764                      ** **************************************************
0000180A                           765                      **
0000180A                           766  
0000180A                           767                      ** Check if destination mode set (may not have a destination)
0000180A  0C39 00FF 00002CDE       768                      CMP.B   #$FF,opDstMod
00001812  6700 0170                769                      BEQ     Fn_DSP_DONE             * No source data, goto check Dta2
00001816                           770  
00001816  0C39 0000 00002CDE       771                      CMP.B   #0,opDstMod
0000181E  6700 0042                772                      BEQ     Fn_DSP_DTA2_00          * Handle Reg mode 0 (Dn)
00001822  0C39 0001 00002CDE       773                      CMP.B   #1,opDstMod
0000182A  6700 004A                774                      BEQ     Fn_DSP_DTA2_01          * Handle Reg Mode 1 An
0000182E  0C39 0002 00002CDE       775                      CMP.B   #2,opDstMod
00001836  6700 0052                776                      BEQ     Fn_DSP_DTA2_02          * Handle Reg Mode 2 (An)
0000183A  0C39 0003 00002CDE       777                      CMP.B   #3,opDstMod
00001842  6700 0062                778                      BEQ     Fn_DSP_DTA2_03          * Handle Reg Mode 3 (An)+
00001846  0C39 0004 00002CDE       779                      CMP.B   #4,opDstMod
0000184E  6700 0076                780                      BEQ     Fn_DSP_DTA2_04          * Handle Reg Mode 4 -(An)
00001852  0C39 0007 00002CDE       781                      CMP.B   #7,opDstMod
0000185A  6700 008A                782                      BEQ     Fn_DSP_DTA2_07          * Handle Reg Mode 7 (xxx).W, (xxx).L, #<data>
0000185E                           783  
0000185E  6000 0114                784                      BRA     Fn_DSP_DTA2_ERR         * Mode not 1 to 7 - display error
00001862                           785  
00001862                           786  Fn_DSP_DTA2_00      ** Handling mode 0
00001862  16FC 0044                787                      MOVE.B  #$44,(A3)+              * Insert 'D' character
00001866  1639 00002CDD            788                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
0000186C  0603 0030                789                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001870  16C3                     790                      MOVE.B  D3,(A3)+                * Insert Register value
00001872  6000 0110                791                      BRA     Fn_DSP_DONE             * Done with display
00001876                           792  
00001876                           793  Fn_DSP_DTA2_01      ** Handling mode 1
00001876  16FC 0041                794                      MOVE.B  #$41,(A3)+              * Insert 'A' character
0000187A  1639 00002CDD            795                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
00001880  0603 0030                796                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
00001884  16C3                     797                      MOVE.B  D3,(A3)+                * Insert Register value
00001886  6000 00FC                798                      BRA     Fn_DSP_DONE             * Done with display
0000188A                           799  
0000188A                           800  Fn_DSP_DTA2_02      ** Handling mode 2
0000188A  16FC 0028                801                      MOVE.B  #$28,(A3)+              * Insert '(' character
0000188E  16FC 0041                802                      MOVE.B  #$41,(A3)+              * Insert 'A' character
00001892  1639 00002CDD            803                      MOVE.B  opDSTReg,D3             * Move Register value to D3 for ASCII conversion
00001898  0603 0030                804                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
0000189C  16C3                     805                      MOVE.B  D3,(A3)+                * Insert Register value
0000189E  16FC 0029                806                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018A2  6000 00E0                807                      BRA     Fn_DSP_DONE             * Done with display
000018A6                           808  
000018A6                           809  Fn_DSP_DTA2_03      ** Handling mode 3
000018A6  16FC 0028                810                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018AA  16FC 0041                811                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018AE  1639 00002CDD            812                      MOVE.B  opDstReg,D3             * Move Register value to D3 for ASCII conversion
000018B4  0603 0030                813                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018B8  16C3                     814                      MOVE.B  D3,(A3)+                * Insert Register value
000018BA  16FC 0029                815                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018BE  16FC 002B                816                      MOVE.B  #$2B,(A3)+              * Insert '+' character
000018C2  6000 00C0                817                      BRA     Fn_DSP_DONE             * Done with display
000018C6                           818  
000018C6                           819  Fn_DSP_DTA2_04      ** Handling mode 4
000018C6  16FC 002D                820                      MOVE.B  #$2D,(A3)+              * Insert '-' character
000018CA  16FC 0028                821                      MOVE.B  #$28,(A3)+              * Insert '(' character
000018CE  16FC 0041                822                      MOVE.B  #$41,(A3)+              * Insert 'A' character
000018D2  1639 00002CDF            823                      MOVE.B  opSrcReg,D3             * Move Register value to D3 for ASCII conversion
000018D8  0603 0030                824                      ADDI.B  #$30,D3                 * Add 30 to convert number to ASCII
000018DC  16C3                     825                      MOVE.B  D3,(A3)+                * Insert Register value
000018DE  16FC 0029                826                      MOVE.B  #$29,(A3)+              * Insert ')' character
000018E2  6000 00A0                827                      BRA     Fn_DSP_DONE             * Done with display
000018E6                           828  
000018E6                           829  Fn_DSP_DTA2_07      ** Handling mode 8
000018E6  0C39 0000 00002CEC       830                      CMP.B   #0,opDta2T
000018EE  6700 001E                831                      BEQ     Fn_DSP_DTA2_BYT         * Display data as byte
000018F2  0C39 0001 00002CEC       832                      CMP.B   #1,opDta2T
000018FA  6700 0034                833                      BEQ     Fn_DSP_DTA2_WRD         * Display data as word
000018FE  0C39 0002 00002CEC       834                      CMP.B   #2,opDta2T
00001906  6700 004A                835                      BEQ     Fn_DSP_DTA2_LNG         * Display data as long
0000190A                           836  
0000190A  6000 0068                837                      BRA     Fn_DSP_DTA2_ERR         * Data type not 0 to 2 - display error
0000190E                           838  
0000190E                           839  Fn_DSP_DTA2_BYT     ** Display data Byte (it's really a word with 00 tacked on)
0000190E  49F9 00002CE8            840                      LEA     opDta2,A4               * input hex
00001914  4BF9 00002CED            841                      LEA     opStrDtaWrd,A5          * output string
0000191A  4EB9 000019D4            842                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001920  49F9 00002CED            843                      LEA     opStrDtaWrd,A4
00001926  4EB9 00001A06            844                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000192C  6000 0056                845                      BRA     Fn_DSP_DONE             * Display data 2
00001930                           846  
00001930                           847  Fn_DSP_DTA2_WRD     ** Display data Word
00001930  49F9 00002CE8            848                      LEA     opDta2,A4               * input hex
00001936  4BF9 00002CED            849                      LEA     opStrDtaWrd,A5          * output string
0000193C  4EB9 000019D4            850                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001942  49F9 00002CED            851                      LEA     opStrDtaWrd,A4
00001948  4EB9 00001A06            852                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
0000194E  6000 0034                853                      BRA     Fn_DSP_DONE             * Display data 2
00001952                           854  
00001952                           855  Fn_DSP_DTA2_LNG     ** Display data Long
00001952  49F9 00002CE8            856                      LEA     opDta2,A4               * input hex
00001958  4BF9 00002CF2            857                      LEA     opStrDtaLng,A5          * output string
0000195E  4EB9 000019D4            858                      JSR     SR_HEX_STR              * Hex to ASCII input @A4, output @A5
00001964  49F9 00002CF2            859                      LEA     opStrDtaLng,A4
0000196A  4EB9 00001A06            860                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001970  6000 0012                861                      BRA     Fn_DSP_DONE             * Display data 2
00001974                           862  
00001974                           863  Fn_DSP_DTA2_ERR     ** Something is messed up
00001974  49F9 00002DCE            864                      LEA     msgErr,A4
0000197A  4EB9 00001A06            865                      JSR     SR_CPY_STR_BUF          * Copy string @A4 to output buffer @A3
00001980  6000 0002                866                      BRA     Fn_DSP_DONE             * Display data 2
00001984                           867  
00001984                           868  Fn_Dsp_Done         ** Done with instruction display
00001984  16BC 0000                869                      MOVE.B  #$00,(A3)               * Insert NULL to end string
00001988  43F9 00002C88            870                      LEA     opOutBuf,A1             * Loads MESSAGE into A1
0000198E  103C 000D                871                      MOVE.B  #13,D0                  * Use (A1) with CR/LF
00001992  4E4F                     872                      TRAP    #15
00001994                           873  
00001994                           874                      ** We're all done here - time to go
00001994                           875                      **
00001994  4E75                     876                      RTS                             * Return back to caller
00001996                           877  
00001996                           878  ** -----------------------------------------------------------
00001996                           879  ** Convert single ASCII value to hexadecimal
00001996                           880  **    ASCII values should be in range 0-9, A-F
00001996                           881  **
00001996                           882  ** Parameters
00001996                           883  **   D5 - Hex value to assess. Converted value returned in D5
00001996                           884  **
00001996                           885  ** Example:
00001996                           886  **   $30 -> $0
00001996                           887  **   $41 -> $A
00001996                           888  **   $61 -> $A
00001996                           889  ** -----------------------------------------------------------
00001996                           890  SR_ASCII_HEX
00001996  BA3C 0039                891                      CMP.B   #$39,D5
0000199A  6F00 000E                892                      BLE     Fn_ASCII_Num            * ASCII $0-$9
0000199E  BA3C 0046                893                      CMP.B   #$46,D5
000019A2  6F00 000C                894                      BLE     Fn_ASCII_UcLtr          * ASCII $A-$F
000019A6  6000 000E                895                      BRA     Fn_ASCII_LcLtr          * ASCII $a-$f
000019AA                           896  
000019AA  0405 0030                897  Fn_ASCII_Num        SUBI.B  #$30, D5                * If Hex is $0-$9, sub $30
000019AE  4E75                     898                      RTS
000019B0  0405 0037                899  Fn_ASCII_UcLtr      SUBI.B  #$37, D5                * If Hex is $A-$F, sub $37
000019B4  4E75                     900                      RTS
000019B6  0405 0057                901  Fn_ASCII_LcLtr      SUBI.B  #$57, D5                * If Hex is $a-$f, sub $57
000019BA  4E75                     902                      RTS
000019BC                           903  
000019BC                           904  ** -----------------------------------------------------------
000019BC                           905  ** Convert single hexadecimal value to ASCII
000019BC                           906  **    hexadecimal values should be in range 0-9, A-F
000019BC                           907  **
000019BC                           908  ** Parameters
000019BC                           909  **   D5 - Hex value to assess. Converted value returned in D5
000019BC                           910  **
000019BC                           911  ** Example:
000019BC                           912  **   $0 -> $30
000019BC                           913  **   $A -> $41
000019BC                           914  **   $a -> $41
000019BC                           915  **
000019BC                           916  ** Note: this function is case insensitive an $a = $A = $41 etc.
000019BC                           917  ** -----------------------------------------------------------
000019BC                           918  SR_HEX_ASCII
000019BC  BA3C 0009                919                      CMP.B   #$9,D5
000019C0  6F00 0006                920                      BLE     Fn_HEX_Num              * Hex $0-$9
000019C4  6000 0008                921                      BRA     Fn_HEX_Ltr              * Hex $A-$F, $a-$f
000019C8                           922  
000019C8  0605 0030                923  Fn_HEX_Num          ADDI.B  #$30, D5                * If Hex is $0-$9, add $30
000019CC  4E75                     924                      RTS
000019CE  0605 0037                925  Fn_HEX_Ltr          ADDI.B  #$37, D5                * If Hex is $A-$F, add $37
000019D2  4E75                     926                      RTS
000019D4                           927  
000019D4                           928  ** -----------------------------------------------------------
000019D4                           929  ** Copy hexadecimal value to string
000019D4                           930  **
000019D4                           931  ** Parameters
000019D4                           932  **   A4 - Pointer to value copying from
000019D4                           933  **   A5 - Pointer to defined constant
000019D4                           934  **
000019D4                           935  ** Data registers
000019D4                           936  **   D4 - Current byte      (hex value A4)
000019D4                           937  **   D5 - Temp byte         (hex value or string)
000019D4                           938  **   D6 - Number to shift
000019D4                           939  **
000019D4                           940  ** Note: input string @ A5 has to have a null terminator for loop to stop
000019D4                           941  **
000019D4                           942  ** -----------------------------------------------------------
000019D4                           943  SR_HEX_STR
000019D4                           944  
000019D4  181C                     945  Fn_Hex_Str_Loop     MOVE.B  (A4)+,D4
000019D6                           946  
000019D6  1A15                     947                      MOVE.B  (A5),D5
000019D8  BA3C 0000                948                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
000019DC  6700 0022                949                      BEQ     Fn_Hex_Str_Done          * NULL value found - exit SR
000019E0                           950  
000019E0                           951                      ** First Hex value (high order value)
000019E0  1A04                     952                      MOVE.B  D4,D5                    * Copy current value to temp byte holder
000019E2  1C3C 0004                953                      MOVE.B  #4,D6
000019E6  EC2D                     954                      LSR.B   D6,D5                    * Shift right to get high order hex value
000019E8  4EB8 19BC                955                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019EC  1AC5                     956                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019EE                           957  
000019EE                           958                      ** Second Hex value (low order value)
000019EE  1A04                     959                      MOVE.B  D4,D5                    * Copy current vaue to temp byte holder
000019F0  1C3C 0004                960                      MOVE.B  #4,D6
000019F4  ED2D                     961                      LSL.B   D6,D5
000019F6  EC2D                     962                      LSR.B   D6,D5                    * Shift left, right to get low order hex value
000019F8  4EB8 19BC                963                      JSR     SR_HEX_ASCII             * Hex to ASCII conversion
000019FC  1AC5                     964                      MOVE.B  D5,(A5)+                 * Move ASCII value to constant
000019FE                           965  
000019FE  60D4                     966                      BRA     Fn_Hex_Str_Loop
00001A00                           967  Fn_Hex_Str_Done
00001A00  1AFC 0000                968                      MOVE.B  #$00,(A5)+               * Insert NULL value (required to print string)
00001A04                           969  
00001A04  4E75                     970                      RTS
00001A06                           971  
00001A06                           972  ** -----------------------------------------------------------
00001A06                           973  ** Copy string to output buffer @ A3
00001A06                           974  **
00001A06                           975  ** Parameters
00001A06                           976  **   A4 - Pointer to string copying from
00001A06                           977  **
00001A06                           978  ** Data registers
00001A06                           979  **   D5 - Temp byte         (hex value or string)
00001A06                           980  ** -----------------------------------------------------------
00001A06                           981  SR_CPY_STR_BUF
00001A06                           982  
00001A06  1A14                     983  Fn_CPY_STR_Loop     MOVE.B  (A4),D5
00001A08  BA3C 0000                984                      CMP.B   #$00,D5                  * Looking for NULL hex value $00
00001A0C  6700 0006                985                      BEQ     Fn_CPY_STR_Done          * NULL value found - exit SR
00001A10                           986  
00001A10  16DC                     987                      MOVE.B  (A4)+,(A3)+
00001A12  60F2                     988                      BRA     Fn_CPY_STR_Loop
00001A14                           989  
00001A14  4E75                     990  Fn_CPY_STR_Done     RTS
00001A16                           991  
00001A16                           992  ** -----------------------------------------------------------
00001A16                           993  ** Length of string output buffer
00001A16                           994  ** -----------------------------------------------------------
00001A16                           995  SR_CNT_STR_BUF
00001A16                           996  
00001A16  4E75                     997                      RTS
00001A18                           998  
00001A18                           999  ** -----------------------------------------------------------
00001A18                          1000  ** Includes: Subroutines etc.
00001A18                          1001  ** -----------------------------------------------------------
00001A18                          1002                      INCLUDE 'SR_IDX.X68'
00001A18                          1003  
00001A18                          1004  
00001A18                          1005  SR_IDX
00001A18                          1006  
00001A18  4E75                    1007                RTS
00001A18  4E75                    1008  -------------------- end include --------------------
00001A1A                          1009                      INCLUDE 'SR_ID3.X68'
00001A1A                          1010  
00001A1A                          1011  
00001A1A                          1012  SR_ID3
00001A1A                          1013  
00001A1A                          1014                      *MOVEM.L    D0-D7/A0-A6,-(SP)       * Save registers
00001A1A                          1015  
00001A1A                          1016  
00001A1A                          1017                      ** ***************************************
00001A1A                          1018                      ** Read first 4 bits
00001A1A                          1019                      ** need to know if 0(byte), 1(word), 2(long) - only for MOVE, MOVEA
00001A1A                          1020                      ** Note: most instructions will be in this format 3,3,3,3
00001A1A                          1021                      **    I think there is only one instrction that is 4,8
00001A1A                          1022                      **
00001A1A                          1023                      ** ***************************************
00001A1A  3639 00002C72           1024                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A20  183C 000C               1025                      MOVE.B  #12,D4
00001A24  E86B                    1026                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001A26  13C3 00002C74           1027                      MOVE.B  D3, opID
00001A2C                          1028  
00001A2C                          1029                      ** Read next 3 bits
00001A2C                          1030                      **
00001A2C  3639 00002C72           1031                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A32  183C 0004               1032                      MOVE.B  #4, D4
00001A36  E96B                    1033                      LSL.W   D4, D3                      * Shift left 4 to get rid of first 4 bits
00001A38  183C 000D               1034                      MOVE.B  #13,D4
00001A3C  E86B                    1035                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A3E  13C3 00002CDD           1036                      MOVE.B  D3, opDstReg
00001A44                          1037  
00001A44                          1038                      ** Read next 3 bits
00001A44                          1039                      **
00001A44  3639 00002C72           1040                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A4A  183C 0007               1041                      MOVE.B  #7, D4
00001A4E  E96B                    1042                      LSL.W   D4, D3                      * Shift left 7 to get rid of first 7 bits
00001A50  183C 000D               1043                      MOVE.B  #13,D4
00001A54  E86B                    1044                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A56  13C3 00002CDE           1045                      MOVE.B  D3, opDstMod
00001A5C                          1046  
00001A5C                          1047                      ** Read next 3 bits
00001A5C                          1048                      **
00001A5C  3639 00002C72           1049                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A62  183C 000A               1050                      MOVE.B  #10, D4
00001A66  E96B                    1051                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A68  183C 000D               1052                      MOVE.B  #13,D4
00001A6C  E86B                    1053                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A6E  13C3 00002CE0           1054                      MOVE.B  D3, opSrcMod
00001A74                          1055  
00001A74                          1056                      ** Read next 3 bits
00001A74                          1057                      **
00001A74  3639 00002C72           1058                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001A7A  183C 000D               1059                      MOVE.B  #13, D4
00001A7E  E96B                    1060                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001A80  183C 000D               1061                      MOVE.B  #13,D4
00001A84  E86B                    1062                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001A86  13C3 00002CDF           1063                      MOVE.B  D3, opSrcReg
00001A8C                          1064  
00001A8C                          1065                      ** ***************************************
00001A8C                          1066                      ** Verify this is MOVE or MOVEA
00001A8C                          1067                      **
00001A8C                          1068                      ** MOVE:  If opID = 1,2,3 & DstMod = 0,2-7
00001A8C                          1069                      ** MOVEA: If opID =   2,3 & DstMod = 1
00001A8C                          1070                      **
00001A8C                          1071                      ** Size: opID = 1: Byte; opID = 2: Long; opID = 3: Word
00001A8C                          1072                      **
00001A8C                          1073                      ** ***************************************
00001A8C  0C39 0001 00002CDE      1074                      CMP.B   #1, opDstMod                * Destination mode is 1 - must be MOVEA
00001A94  6700 0016               1075                      BEQ     Fn_ID3_Ins02                * Set as instruction 0 MOVEA
00001A98  6000 0002               1076                      BRA     Fn_ID3_Ins01                * Set as instruction 1 MOVE
00001A9C                          1077  
00001A9C  47F9 00002D08           1078  Fn_ID3_Ins01        LEA     opNam_MOVE,A3
00001AA2  23CB 00002CD8           1079                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AA8  6000 001A               1080                      BRA     Fn_ID3_Verify
00001AAC                          1081  
00001AAC  0C39 0001 00002C74      1082  Fn_ID3_Ins02        CMP.B   #1, opID
00001AB4  6700 01A4               1083                      BEQ     Fn_ID3_Error               * MOVEA cannot have opID = 1 (byte)
00001AB8  47F9 00002D0D           1084                      LEA     opNam_MOVEA,A3
00001ABE  23CB 00002CD8           1085                      MOVE.L  A3,opPtrNam                 * Display name points to name
00001AC4                          1086  
00001AC4                          1087                      ** ***************************************
00001AC4                          1088                      ** Verify other instruction parameters are correct
00001AC4                          1089                      **
00001AC4                          1090                      **    DstMod = 0 to 7
00001AC4                          1091                      **    DstReg = 0 to 7
00001AC4                          1092                      **    SrcMod = 0 to 7
00001AC4                          1093                      **    SrcReg = 0 to 7
00001AC4                          1094                      **
00001AC4                          1095                      ** ***************************************
00001AC4  0C39 0000 00002CDE      1096  Fn_ID3_Verify       CMP.B   #0, opDstMod                * Destination mode is >= 0
00001ACC  6D00 018C               1097                      BLT     Fn_ID3_Error
00001AD0  0C39 0007 00002CDE      1098                      CMP.B   #7, opDstMod                * Destination mode is <= 7
00001AD8  6E00 0180               1099                      BGT     Fn_ID3_Error
00001ADC  0C39 0000 00002CDD      1100                      CMP.B   #0, opDstReg                * Destination register >= 0
00001AE4  6D00 0174               1101                      BLT     Fn_ID3_Error
00001AE8  0C39 0007 00002CDD      1102                      CMP.B   #7, opDstReg                * Destination register <= 7
00001AF0  6E00 0168               1103                      BGT     Fn_ID3_Error
00001AF4                          1104  
00001AF4  0C39 0000 00002CE0      1105                      CMP.B   #0, opSrcMod                * Destination mode is 0
00001AFC  6D00 015C               1106                      BLT     Fn_ID3_Error
00001B00  0C39 0007 00002CE0      1107                      CMP.B   #7, opSrcMod                * Destination mode is <= 7
00001B08  6E00 0150               1108                      BGT     Fn_ID3_Error
00001B0C  0C39 0000 00002CDF      1109                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001B14  6D00 0144               1110                      BLT     Fn_ID3_Error
00001B18  0C39 0007 00002CDF      1111                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001B20  6E00 0138               1112                      BGT     Fn_ID3_Error
00001B24                          1113  
00001B24                          1114                      ** ***************************************
00001B24                          1115                      ** Set instruction size - the .B,.W,.L part
00001B24                          1116                      ** Note: size set by opID only for MOVE, MOVEA
00001B24                          1117                      **       other instructions use 3 bits for size
00001B24                          1118                      ** ***************************************
00001B24  0C39 0001 00002C74      1119                      CMP.B   #1, opID                    * Instruction size is Byte
00001B2C  6700 001A               1120                      BEQ     Fn_ID3_SizB
00001B30  0C39 0003 00002C74      1121                      CMP.B   #3, opID                    * Instruction size is Word (Note sizes reversed for MOVE)
00001B38  6700 001A               1122                      BEQ     Fn_ID3_SizW
00001B3C  0C39 0002 00002C74      1123                      CMP.B   #2, opID                    * Instruction size is Long
00001B44  6700 001A               1124                      BEQ     Fn_ID3_SizL
00001B48  13FC 0000 00002CDC      1125  Fn_ID3_SizB         MOVE.B  #0,opValSiz                 * Set size to 0=Byte
00001B50  6000 001A               1126                      BRA     Fn_ID3_SrcMod
00001B54  13FC 0001 00002CDC      1127  Fn_ID3_SizW         MOVE.B  #1,opValSiz                 * Set size to 1=Word
00001B5C  6000 000E               1128                      BRA     Fn_ID3_SrcMod
00001B60  13FC 0002 00002CDC      1129  Fn_ID3_SizL         MOVE.B  #2,opValSiz                 * Set size to 2=Long
00001B68  6000 0002               1130                      BRA     Fn_ID3_SrcMod
00001B6C                          1131  
00001B6C                          1132                      ** ***************************************
00001B6C                          1133                      ** Grab extra DATA if needed
00001B6C                          1134                      **
00001B6C                          1135                      **    If DstMod = 7
00001B6C                          1136                      **       DstReg = 0 (get Word)
00001B6C                          1137                      **       DstReg = 1 (get Long)
00001B6C                          1138                      **
00001B6C                          1139                      **    If SrcMod = 7
00001B6C                          1140                      **       SrcReg = 0 (get Word)
00001B6C                          1141                      **       SrcReg = 1 (get Long)
00001B6C                          1142                      **       SrcReg = 4
00001B6C                          1143                      **          MOVE.B, MOVE.W (get Word)
00001B6C                          1144                      **          MOVE.L         (get Long)
00001B6C                          1145                      **
00001B6C                          1146                      ** SOURCE
00001B6C                          1147                      **
00001B6C                          1148                      ** ***************************************
00001B6C  0C39 0007 00002CE0      1149  Fn_ID3_SrcMod       CMP.B   #7, opSrcMod                * Check if source mode is 7
00001B74  6700 0006               1150                      BEQ     Fn_ID3_ChkSrcReg            * Check source register
00001B78  6000 0088               1151                      BRA     Fn_ID3_ChkDstMod           * Source not 7, now check destination Mod
00001B7C  0C39 0000 00002CDF      1152  Fn_ID3_ChkSrcReg    CMP.B   #0, opSrcReg                 * Check is source register is 0
00001B84  6700 0058               1153                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001B88  0C39 0001 00002CDF      1154                      CMP.B   #1, opSrcReg                * Check if source register is 1
00001B90  6700 005E               1155                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001B94  0C39 0004 00002CDF      1156                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00001B9C  6700 0006               1157                      BEQ     Fn_ID3_DtaSrcImd            * Load first word into word one
00001BA0  6000 00B8               1158                      BRA     FN_ID3_Error                * Invalid register value
00001BA4                          1159  
00001BA4                          1160                      ** Note: Checking immediate value
00001BA4                          1161                      **       opID as size is specific to MOVE, MOVEA
00001BA4                          1162                      **       other instructions will use 3 bits to set size, not part of ID
00001BA4                          1163                      **
00001BA4  0C39 0001 00002C74      1164  Fn_ID3_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00001BAC  6700 001E               1165                      BEQ     Fn_ID3_DtaSrcByt            * Load next byte
00001BB0  0C39 0003 00002C74      1166                      CMP.B   #3, opID                    * opID = 3 - size is word
00001BB8  6700 0024               1167                      BEQ     Fn_ID3_DtaSrcWrd            * Load next word
00001BBC  0C39 0002 00002C74      1168                      CMP.B   #2, opID                    * opID = 0 - size is long
00001BC4  6700 002A               1169                      BEQ     Fn_ID3_DtaSrcLng            * Load next long
00001BC8  6000 0090               1170                      BRA     Fn_ID3_Error                * Invalid opID (this should never happen)
00001BCC                          1171  
00001BCC  33DA 00002CE2           1172  Fn_ID3_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00001BD2  13FC 0000 00002CE6      1173                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00001BDA  6000 0026               1174                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BDE  33DA 00002CE2           1175  Fn_ID3_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00001BE4  13FC 0001 00002CE6      1176                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00001BEC  6000 0014               1177                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001BF0  23DA 00002CE2           1178  Fn_ID3_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00001BF6  13FC 0002 00002CE6      1179                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00001BFE  6000 0002               1180                      BRA     Fn_ID3_ChkDstMod            * Check destination mode
00001C02                          1181  
00001C02                          1182                      ** DESTINATION
00001C02                          1183                      **
00001C02  0C39 0007 00002CDE      1184  Fn_ID3_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00001C0A  6700 0006               1185                      BEQ     Fn_ID3_ChkDstReg            * Check destination register
00001C0E  6000 0042               1186                      BRA     Fn_ID3_Done                 * Destination not 7, done with data
00001C12  0C39 0000 00002CDD      1187  Fn_ID3_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00001C1A  6700 0012               1188                      BEQ     Fn_ID3_DtaDstWrd            * Load next word
00001C1E  0C39 0001 00002CDD      1189                      CMP.B   #1, opDstReg                * Check if destination register is 1
00001C26  6700 0018               1190                      BEQ     Fn_ID3_DtaDstLng            * Load next long
00001C2A  6000 002E               1191                      BRA     fn_ID3_Error                * Invalid registration Mode
00001C2E                          1192  
00001C2E  33DA 00002CE8           1193  Fn_ID3_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00001C34  13FC 0001 00002CEC      1194                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
00001C3C  6000 0014               1195                      BRA     Fn_ID3_Done
00001C40  23DA 00002CE8           1196  Fn_ID3_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00001C46  13FC 0002 00002CEC      1197                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
00001C4E  6000 0002               1198                      BRA     Fn_ID3_Done
00001C52                          1199  
00001C52  13FC 0000 00002C75      1200  Fn_ID3_Done         MOVE.B  #0, opErr                   * Clear error flag so this will display instruction info
00001C5A                          1201  
00001C5A                          1202  Fn_ID3_Error                                           * Exit out if error - main subroutine will handle DATA
00001C5A                          1203                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00001C5A  4E75                    1204                      RTS                                 * Return to main
00001C5A  4E75                    1205  -------------------- end include --------------------
00001C5C                          1206                      INCLUDE 'SR_ID4.X68'
00001C5C                          1207  
00001C5C                          1208  SR_ID4              * This is to grab the first four that are already set, ID4
00001C5C  3639 00002C72           1209                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C62  183C 000C               1210                      MOVE.B  #12,D4
00001C66  E86B                    1211                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00001C68  13C3 00002C74           1212                      MOVE.B  D3, opID        
00001C6E                          1213                      
00001C6E                          1214                      * Read next 3 bits into D3
00001C6E  3639 00002C72           1215                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C74  183C 0004               1216                      MOVE.B  #4, D4
00001C78  E96B                    1217                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00001C7A  183C 000D               1218                      MOVE.B  #13,D4
00001C7E  E86B                    1219                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C80  13C3 00002CDD           1220                      MOVE.B  D3, opDstReg
00001C86                          1221                      
00001C86                          1222                      * Read next 3 bits into D3
00001C86  3639 00002C72           1223                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001C8C  183C 0007               1224                      MOVE.B  #7, D4
00001C90  E96B                    1225                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00001C92  183C 000D               1226                      MOVE.B  #13,D4
00001C96  E86B                    1227                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001C98  13C3 00002CDE           1228                      MOVE.B  D3, opDstMod
00001C9E                          1229  
00001C9E                          1230                      ** Read next 3 bits
00001C9E                          1231                      **
00001C9E  3639 00002C72           1232                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CA4  183C 000A               1233                      MOVE.B  #10, D4
00001CA8  E96B                    1234                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CAA  183C 000D               1235                      MOVE.B  #13,D4
00001CAE  E86B                    1236                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CB0  13C3 00002CE0           1237                      MOVE.B  D3, opSrcMod
00001CB6                          1238  
00001CB6                          1239                      ** Read next 3 bits
00001CB6                          1240                      **
00001CB6  3639 00002C72           1241                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00001CBC  183C 000D               1242                      MOVE.B  #13, D4
00001CC0  E96B                    1243                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00001CC2  183C 000D               1244                      MOVE.B  #13,D4
00001CC6  E86B                    1245                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00001CC8  13C3 00002CDF           1246                      MOVE.B  D3, opSrcReg
00001CCE                          1247                      
00001CCE                          1248                      ** ***************************************
00001CCE                          1249                      ** Verify instruction
00001CCE                          1250                      **
00001CCE                          1251                      ** JSR: If DstReg=7, DstMod=2 
00001CCE                          1252                      ** LEA: If DstReg=0-7, DstMod=7
00001CCE                          1253                      ** MOVEM:
00001CCE                          1254                      **    RegToMem: DestReg=4, DestMod=2,3
00001CCE                          1255                      **    MemToReg: DestReg=6, DestMod=2,3
00001CCE                          1256                      ** NOP: If DestReg=7, DstMod=1, SrcMod=6, SrcReg=1
00001CCE                          1257                      ** NOT: If DstReg=3, DstMod=0-2
00001CCE                          1258                      ** RTS: If DstReg=7, DstMod=1, SrcMod=6, SrcReg=5
00001CCE                          1259                      **
00001CCE                          1260                      ** ***************************************
00001CCE  0C39 0000 00002CDE      1261                      CMP.B   #0, opDstMod
00001CD6  6700 02EA               1262                      BEQ     Fn_ID4_NOT
00001CDA  0C39 0001 00002CDE      1263                      CMP.B   #1, opDstMod
00001CE2  6700 002A               1264                      BEQ     Fn_ID4_CheckD1
00001CE6  0C39 0002 00002CDE      1265                      CMP.B   #2, opDstMod
00001CEE  6700 0042               1266                      BEQ     Fn_ID4_CheckD2
00001CF2  0C39 0003 00002CDE      1267                      CMP.B   #3, opDstMod
00001CFA  6700 0066               1268                      BEQ     Fn_ID4_CheckD3
00001CFE  0C39 0007 00002CDE      1269                      CMP.B   #7, opDstMod
00001D06  6700 011E               1270                      BEQ     Fn_ID4_LEA
00001D0A  6000 03D2               1271                      BRA     Fn_ID4_Error
00001D0E                          1272                      
00001D0E                          1273  Fn_ID4_CheckD1
00001D0E  0C39 0003 00002CDD      1274                      CMP.B   #3, opDstReg
00001D16  6700 02AA               1275                      BEQ     Fn_ID4_NOT
00001D1A  0C39 0001 00002CDF      1276                      CMP.B   #1, opSrcReg
00001D22  6700 025E               1277                      BEQ     Fn_ID4_NOP
00001D26  0C39 0005 00002CDF      1278                      CMP.B   #5, opSrcReg
00001D2E  6700 02E8               1279                      BEQ     Fn_ID4_RTS
00001D32                          1280                      
00001D32                          1281  Fn_ID4_CheckD2
00001D32  0C39 0003 00002CDD      1282                      CMP.B   #3, opDstReg
00001D3A  6700 0286               1283                      BEQ     Fn_ID4_NOT
00001D3E  0C39 0004 00002CDD      1284                      CMP.B   #4, opDstReg
00001D46  6700 014E               1285                      BEQ     Fn_ID4_MOVEMRTOM
00001D4A  0C39 0006 00002CDD      1286                      CMP.B   #6, opDstReg
00001D52  6700 01B2               1287                      BEQ     Fn_ID4_MOVEMMTOR
00001D56  0C39 0007 00002CDD      1288                      CMP.B   #7, opDstReg
00001D5E  6700 001A               1289                      BEQ     Fn_ID4_JSR
00001D62                          1290  Fn_ID4_CheckD3
00001D62  0C39 0004 00002CDD      1291                      CMP.B   #4, opDstReg
00001D6A  6700 012A               1292                      BEQ     Fn_ID4_MOVEMRTOM
00001D6E  0C39 0006 00002CDD      1293                      CMP.B   #6, opDstReg
00001D76  6700 018E               1294                      BEQ     Fn_ID4_MOVEMMTOR
00001D7A                          1295  
00001D7A  47F9 00002D29           1296  Fn_ID4_JSR          LEA     opNam_JSR,A3
00001D80  23CB 00002CD8           1297                      MOVE.L  A3, opPtrNam
00001D86                          1298                      
00001D86  0C39 0007 00002CDD      1299  Fn_ID4_VERIFY_JSR   CMP.B   #7, opDstReg
00001D8E  6600 034E               1300                      BNE     Fn_ID4_Error
00001D92  0C39 0002 00002CDE      1301                      CMP.B   #2, opDstMod
00001D9A  6600 0342               1302                      BNE     Fn_ID4_Error
00001D9E                          1303                      
00001D9E                          1304                      * Make sure dst reg is only 2,5,6,7 (not 0,1,3,4)
00001D9E  0C39 0000 00002CDD      1305                      CMP.B   #0, opDstReg
00001DA6  6700 0336               1306                      BEQ     Fn_ID4_Error
00001DAA  0C39 0001 00002CDD      1307                      CMP.B   #1, opDstReg
00001DB2  6700 032A               1308                      BEQ     Fn_ID4_Error
00001DB6  0C39 0003 00002CDD      1309                      CMP.B   #3, opDstReg
00001DBE  6700 031E               1310                      BEQ     Fn_ID4_Error
00001DC2  0C39 0004 00002CDD      1311                      CMP.B   #4, opDstReg
00001DCA  6700 0312               1312                      BEQ     Fn_ID4_Error
00001DCE                          1313                      
00001DCE                          1314                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001DCE  0C39 0000 00002CE0      1315                      CMP.B   #0, opSrcMod
00001DD6  6700 0306               1316                      BEQ     Fn_ID4_Error
00001DDA  0C39 0001 00002CE0      1317                      CMP.B   #1, opSrcMod
00001DE2  6700 02FA               1318                      BEQ     Fn_ID4_Error
00001DE6  0C39 0003 00002CE0      1319                      CMP.B   #3, opSrcMod
00001DEE  6700 02EE               1320                      BEQ     Fn_ID4_Error
00001DF2  0C39 0004 00002CE0      1321                      CMP.B   #4, opSrcMod
00001DFA  6700 02E2               1322                      BEQ     Fn_ID4_Error
00001DFE                          1323                      
00001DFE                          1324                      * Make sure src reg is between 0-7
00001DFE  0C39 0000 00002CDF      1325                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E06  6D00 02D6               1326                      BLT     Fn_ID4_Error
00001E0A  0C39 0007 00002CDF      1327                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E12  6E00 02CA               1328                      BGT     Fn_ID4_Error
00001E16                          1329                      
00001E16  0C39 0007 00002CE0      1330  Fn_ID4_JSR_Src      CMP.B   #7, opSrcMod
00001E1E  6700 0238               1331                      BEQ     Fn_ID4_Data
00001E22  6000 02BC               1332                      BRA     Fn_ID4_Done
00001E26                          1333  
00001E26  47F9 00002D13           1334  Fn_ID4_LEA          LEA     opNam_LEA,A3
00001E2C  23CB 00002CD8           1335                      MOVE.L  A3, opPtrNam
00001E32                          1336                      
00001E32  0C39 0007 00002CDE      1337  Fn_ID4_VERIFY_LEA   CMP.B   #7, opDstMod
00001E3A  6600 02A2               1338                      BNE     Fn_ID4_Error
00001E3E                          1339                      
00001E3E                          1340                      * Make sure src mode is only 2,5,6,7 (not 0,1,3,4)
00001E3E  0C39 0000 00002CE0      1341                      CMP.B   #0, opSrcMod
00001E46  6700 0296               1342                      BEQ     Fn_ID4_Error
00001E4A  0C39 0001 00002CE0      1343                      CMP.B   #1, opSrcMod
00001E52  6700 028A               1344                      BEQ     Fn_ID4_Error
00001E56  0C39 0003 00002CE0      1345                      CMP.B   #3, opSrcMod
00001E5E  6700 027E               1346                      BEQ     Fn_ID4_Error
00001E62  0C39 0004 00002CE0      1347                      CMP.B   #4, opSrcMod
00001E6A  6700 0272               1348                      BEQ     Fn_ID4_Error
00001E6E                          1349                      
00001E6E                          1350                      * Make sure src reg is between 0-7
00001E6E  0C39 0000 00002CDF      1351                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001E76  6D00 0266               1352                      BLT     Fn_ID4_Error
00001E7A  0C39 0007 00002CDF      1353                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001E82  6E00 025A               1354                      BGT     Fn_ID4_Error
00001E86                          1355                      
00001E86  0C39 0007 00002CE0      1356  Fn_ID4_LEA_Src      CMP.B   #7, opSrcMod
00001E8E  6700 01C8               1357                      BEQ     Fn_ID4_Data
00001E92  6000 024C               1358                      BRA     Fn_ID4_Done
00001E96                          1359  
00001E96  47F9 00002D1B           1360  Fn_ID4_MOVEMRtoM    LEA     opNam_MOVEM,A3
00001E9C  23CB 00002CD8           1361                      MOVE.L  A3, opPtrNam
00001EA2                          1362                      
00001EA2  0C39 0004 00002CDD      1363  Fn_ID4_VERIFY_MRM   CMP.B   #4, opDstReg
00001EAA  6600 0232               1364                      BNE     Fn_ID4_Error
00001EAE                          1365                      
00001EAE                          1366                      * Make sure dest mode is only 2 or 3
00001EAE  0C39 0003 00002CDF      1367                      CMP.B   #3, opSrcReg                * Destination register > 2
00001EB6  6D00 0226               1368                      BLT     Fn_ID4_Error
00001EBA  0C39 0003 00002CDF      1369                      CMP.B   #3, opSrcReg                * Destination register < 3
00001EC2  6E00 021A               1370                      BGT     Fn_ID4_Error
00001EC6                          1371                      
00001EC6                          1372                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001EC6  0C39 0000 00002CE0      1373                      CMP.B   #0, opSrcMod
00001ECE  6700 020E               1374                      BEQ     Fn_ID4_Error
00001ED2  0C39 0001 00002CE0      1375                      CMP.B   #1, opSrcMod
00001EDA  6700 0202               1376                      BEQ     Fn_ID4_Error
00001EDE  0C39 0003 00002CE0      1377                      CMP.B   #3, opSrcMod
00001EE6  6700 01F6               1378                      BEQ     Fn_ID4_Error
00001EEA                          1379                      
00001EEA                          1380                      * Make sure src reg is between 0-7
00001EEA  0C39 0000 00002CDF      1381                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001EF2  6D00 01EA               1382                      BLT     Fn_ID4_Error
00001EF6  0C39 0007 00002CDF      1383                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001EFE  6E00 01DE               1384                      BGT     Fn_ID4_Error
00001F02  6000 006E               1385                      BRA Fn_ID4_MOVEM_Src
00001F06                          1386  
00001F06  47F9 00002D1B           1387  FN_ID4_MOVEMMtoR    LEA     opNam_MOVEM,A3
00001F0C  23CB 00002CD8           1388                      MOVE.L  A3, opPtrNam
00001F12                          1389                      
00001F12  0C39 0006 00002CDD      1390  Fn_ID4_VERIFY_MMR   CMP.B   #6, opDstReg
00001F1A  6600 01C2               1391                      BNE     Fn_ID4_Error
00001F1E                          1392                      
00001F1E                          1393                      * Make sure dest mode is only 2 or 3
00001F1E  0C39 0003 00002CDF      1394                      CMP.B   #3, opSrcReg                * Destination register > 2
00001F26  6D00 01B6               1395                      BLT     Fn_ID4_Error
00001F2A  0C39 0003 00002CDF      1396                      CMP.B   #3, opSrcReg                * Destination register < 3
00001F32  6E00 01AA               1397                      BGT     Fn_ID4_Error
00001F36                          1398                      
00001F36                          1399                      * Make sure src mode is only 2,4,5,6,7 (not 0,1,3)
00001F36  0C39 0000 00002CE0      1400                      CMP.B   #0, opSrcMod
00001F3E  6700 019E               1401                      BEQ     Fn_ID4_Error
00001F42  0C39 0001 00002CE0      1402                      CMP.B   #1, opSrcMod
00001F4A  6700 0192               1403                      BEQ     Fn_ID4_Error
00001F4E  0C39 0003 00002CE0      1404                      CMP.B   #3, opSrcMod
00001F56  6700 0186               1405                      BEQ     Fn_ID4_Error
00001F5A                          1406                      
00001F5A                          1407                      * Make sure src reg is between 0-7
00001F5A  0C39 0000 00002CDF      1408                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001F62  6D00 017A               1409                      BLT     Fn_ID4_Error
00001F66  0C39 0007 00002CDF      1410                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001F6E  6E00 016E               1411                      BGT     Fn_ID4_Error
00001F72                          1412                      
00001F72  0C39 0007 00002CE0      1413  Fn_ID4_MOVEM_Src    CMP.B   #7, opSrcMod
00001F7A  6700 00DC               1414                      BEQ     Fn_ID4_Data
00001F7E  6000 0160               1415                      BRA     Fn_ID4_Done
00001F82                          1416  
00001F82  47F9 00002D21           1417  Fn_ID4_NOP          LEA     opNam_NOP,A3
00001F88  23CB 00002CD8           1418                      MOVE.L  A3, opPtrNam
00001F8E                          1419  
00001F8E  0C39 0007 00002CDD      1420  Fn_ID4_VERIFY_NOP   CMP.B   #7,opDstReg
00001F96  6600 0146               1421                      BNE     Fn_ID4_Error
00001F9A  0C39 0001 00002CDE      1422                      CMP.B   #1, opDstMod
00001FA2  6600 013A               1423                      BNE     Fn_ID4_Error
00001FA6  0C39 0006 00002CE0      1424                      CMP.B   #6, opSrcMod
00001FAE  6600 012E               1425                      BNE     Fn_ID4_Error
00001FB2  0C39 0001 00002CDF      1426                      CMP.B   #1, opSrcReg
00001FBA  6600 0122               1427                      BNE     Fn_ID4_Error
00001FBE  6000 0120               1428                      BRA     Fn_ID4_Done
00001FC2                          1429  
00001FC2                          1430  
00001FC2  47F9 00002D17           1431  Fn_ID4_NOT          LEA     opNam_NOT,A3
00001FC8  23CB 00002CD8           1432                      MOVE.L  A3, opPtrNam
00001FCE                          1433                      
00001FCE  0C39 0003 00002CDD      1434  Fn_ID4_VERIFY_NOT   CMP.B   #3, opDstReg
00001FD6  6600 0106               1435                      BNE     Fn_ID4_Error
00001FDA                          1436                      
00001FDA                          1437                      * Make sure src mode is not 1
00001FDA  0C39 0001 00002CE0      1438                      CMP.B   #1, opSrcMod
00001FE2  6700 00FA               1439                      BEQ     Fn_ID4_Error
00001FE6                          1440                      
00001FE6                          1441                      * Make sure src reg is between 0-7
00001FE6  0C39 0000 00002CDF      1442                      CMP.B   #0, opSrcReg                * Destination register >= 0
00001FEE  6D00 00EE               1443                      BLT     Fn_ID4_Error
00001FF2  0C39 0007 00002CDF      1444                      CMP.B   #7, opSrcReg                * Destination register <= 7
00001FFA  6E00 00E2               1445                      BGT     Fn_ID4_Error
00001FFE                          1446                      
00001FFE  33F9 00002CDE 00002C74  1447  Fn_ID4_NOT_Src      MOVE.W  opDstMod,opID              * Dest mod holds the size (move it)
00002008  0C39 0007 00002CE0      1448                      CMP.B   #7, opSrcMod
00002010  6700 0046               1449                      BEQ     Fn_ID4_Data
00002014  6000 00CA               1450                      BRA     Fn_ID4_Done
00002018                          1451  
00002018  47F9 00002D25           1452  Fn_ID4_RTS          LEA    opNam_RTS,A3
0000201E  23CB 00002CD8           1453                      MOVE.L A3, opPtrNam
00002024                          1454                      
00002024  0C39 0007 00002CDD      1455  Fn_ID4_VERIFY_RTS   CMP.B   #7,opDstReg
0000202C  6600 00B0               1456                      BNE     Fn_ID4_Error
00002030  0C39 0001 00002CDE      1457                      CMP.B   #1, opDstMod
00002038  6600 00A4               1458                      BNE     Fn_ID4_Error
0000203C  0C39 0006 00002CE0      1459                      CMP.B   #6, opSrcMod
00002044  6600 0098               1460                      BNE     Fn_ID4_Error
00002048  0C39 0005 00002CDF      1461                      CMP.B   #5, opSrcReg
00002050  6600 008C               1462                      BNE     Fn_ID4_Error
00002054  6000 008A               1463                      BRA     Fn_ID4_Done
00002058                          1464  
00002058  0C39 0000 00002CDF      1465  Fn_ID4_Data         CMP.B   #0, opSrcReg                * Check is source register is 0
00002060  6700 0058               1466                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002064  0C39 0001 00002CDF      1467                      CMP.B   #1, opSrcReg                * Check if source register is 1
0000206C  6700 005E               1468                      BEQ     Fn_ID4_DtaLng               * Load next long
00002070  0C39 0004 00002CDF      1469                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002078  6700 0006               1470                      BEQ     Fn_ID4_DtaImd               * Load first word into word one
0000207C  6000 0060               1471                      BRA     FN_ID4_Error                * Invalid register value
00002080                          1472                      
00002080  0C39 0001 00002C74      1473  Fn_ID4_DtaImd       CMP.B   #1, opID                    * opID = 0 - size is byte
00002088  6700 001E               1474                      BEQ     Fn_ID4_DtaByt               * Load next byte
0000208C  0C39 0003 00002C74      1475                      CMP.B   #3, opID                    * opID = 3 - size is word
00002094  6700 0024               1476                      BEQ     Fn_ID4_DtaWrd               * Load next word
00002098  0C39 0002 00002C74      1477                      CMP.B   #2, opID                    * opID = 0 - size is long
000020A0  6700 002A               1478                      BEQ     Fn_ID4_DtaLng               * Load next
000020A4  6000 0038               1479                      BRA     Fn_ID4_Error                * Invalid opID (this should never happen) long
000020A8                          1480  
000020A8  33DA 00002CE8           1481  Fn_ID4_DtaByt       MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000020AE  13FC 0000 00002CEC      1482                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000020B6  6000 0028               1483                      BRA     Fn_ID4_Done
000020BA  33DA 00002CE8           1484  Fn_ID4_DtaWrd       MOVE.W  (A2)+, opDta2               * Load word and increment address count
000020C0  13FC 0001 00002CEC      1485                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000020C8  6000 0016               1486                      BRA     Fn_ID4_Done
000020CC  23DA 00002CE8           1487  Fn_ID4_DtaLng       MOVE.L  (A2)+, opDta2               * Load long and increment address count
000020D2  13FC 0002 00002CEC      1488                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000020DA  6000 0004               1489                      BRA     Fn_ID4_Done
000020DE                          1490  
000020DE                          1491  Fn_ID4_Error                                             * Exit out if error - main subroutine will handle DATA
000020DE                          1492                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000020DE  4E75                    1493                      RTS                                  * Return to main
000020E0                          1494  
000020E0  13FC 0000 00002C75      1495  Fn_ID4_Done         MOVE.B  #0, opErr                    * Clear error flag so this will display instruction info
000020E8  4E75                    1496              RTS
000020EA                          1497  
000020EA                          1498  
000020EA                          1499  
000020EA                          1500  -------------------- end include --------------------
000020EA                          1501                      INCLUDE 'SR_ID5.X68'
000020EA                          1502  
000020EA                          1503  
000020EA                          1504  SR_ID5              * This is to grab the first four that are already set, ID5
000020EA  3639 00002C72           1505                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000020F0  183C 000C               1506                      MOVE.B  #12,D4
000020F4  E86B                    1507                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000020F6  13C3 00002C74           1508                      MOVE.B  D3, opID        
000020FC                          1509                      
000020FC                          1510                      * Read next 3 bits into D3
000020FC  3639 00002C72           1511                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002102  183C 0004               1512                      MOVE.B  #4, D4
00002106  E96B                    1513                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002108  183C 000D               1514                      MOVE.B  #13,D4
0000210C  E86B                    1515                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000210E  13C3 00002CE0           1516                      MOVE.B  D3, opSrcMod
00002114                          1517                      
00002114                          1518                      * Read next 3 bits into D3
00002114  3639 00002C72           1519                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000211A  183C 0007               1520                      MOVE.B  #7, D4
0000211E  E96B                    1521                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002120  183C 000D               1522                      MOVE.B  #13,D4
00002124  E86B                    1523                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002126  13C3 00002C74           1524                      MOVE.B  D3, opID
0000212C                          1525  
0000212C                          1526                      ** Read next 3 bits
0000212C                          1527                      **
0000212C  3639 00002C72           1528                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002132  183C 000A               1529                      MOVE.B  #10, D4
00002136  E96B                    1530                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002138  183C 000D               1531                      MOVE.B  #13,D4
0000213C  E86B                    1532                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000213E  13C3 00002CDE           1533                      MOVE.B  D3, opDstMod
00002144                          1534  
00002144                          1535                      ** Read next 3 bits
00002144                          1536                      **
00002144  3639 00002C72           1537                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000214A  183C 000D               1538                      MOVE.B  #13, D4
0000214E  E96B                    1539                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002150  183C 000D               1540                      MOVE.B  #13,D4
00002154  E86B                    1541                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002156  13C3 00002CDD           1542                      MOVE.B  D3, opDstReg
0000215C                          1543              
0000215C                          1544              ** Set name
0000215C  47F9 00002D2D           1545              LEA     opNam_ADDQ,A3
00002162                          1546              
00002162                          1547  Fn_ID5_VERIFY       * Make sure src mod is between 0-7
00002162  0C39 0000 00002CE0      1548                      CMP.B   #0, opSrcMod                * Destination register >= 0
0000216A  6D00 00E4               1549                      BLT     Fn_ID5_Error
0000216E  0C39 0007 00002CDD      1550                      CMP.B   #7, opDstReg                * Destination register <= 7
00002176  6E00 00D8               1551                      BGT     Fn_ID5_Error
0000217A                          1552              
0000217A                          1553              * Make sure opId  is between 0-2
0000217A  0C39 0000 00002C74      1554                      CMP.B   #0, opID                    * Destination register >= 0
00002182  6D00 00CC               1555                      BLT     Fn_ID5_Error
00002186  0C39 0002 00002C74      1556                      CMP.B   #2, opID                    * Destination register <= 2
0000218E  6E00 00C0               1557                      BGT     Fn_ID5_Error
00002192                          1558              
00002192                          1559              * Move data to  appropriate places for printing
00002192  13FC 0007 00002CE0      1560              MOVE.B  #7,opSrcMod
0000219A  13FC 0004 00002CDF      1561              MOVE.B  #4,opSrcReg
000021A2                          1562  
000021A2                          1563                      ** Note: Checking immediate value
000021A2                          1564                      **       opID as size is specific to MOVE, MOVEA
000021A2                          1565                      **       other instructions will use 3 bits to set size, not part of ID
000021A2                          1566                      **
000021A2  0C39 0001 00002C74      1567  Fn_ID5_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000021AA  6700 001E               1568                      BEQ     Fn_ID5_DtaSrcByt           * Load next byte
000021AE  0C39 0003 00002C74      1569                      CMP.B   #3, opID                    * opID = 3 - size is word
000021B6  6700 0024               1570                      BEQ     Fn_ID5_DtaSrcWrd           * Load next word
000021BA  0C39 0002 00002C74      1571                      CMP.B   #2, opID                    * opID = 0 - size is long
000021C2  6700 002A               1572                      BEQ     Fn_ID5_DtaSrcLng           * Load next long
000021C6  6000 0088               1573                      BRA     Fn_ID5_Error               * Invalid opID (this should never happen)
000021CA                          1574  
000021CA  33DA 00002CE2           1575  Fn_ID5_DtaSrcByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
000021D0  13FC 0000 00002CE6      1576                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
000021D8  6000 0026               1577                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021DC  33DA 00002CE2           1578  Fn_ID5_DtaSrcWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
000021E2  13FC 0001 00002CE6      1579                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
000021EA  6000 0014               1580                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
000021EE  23DA 00002CE2           1581  Fn_ID5_DtaSrcLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
000021F4  13FC 0002 00002CE6      1582                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
000021FC  6000 0002               1583                      BRA     Fn_ID5_ChkDstMod            * Check destination mode
00002200                          1584              
00002200  0C39 0007 00002CDE      1585  Fn_ID5_ChkDstMod    CMP.B   #7, opDstMod                * Check if destination mode is 7
00002208  6700 0006               1586                      BEQ     Fn_ID5_ChkDstReg            * Check destination register
0000220C  6000 0044               1587                      BRA     Fn_ID5_Done                 * Destination not 7, done with data
00002210  0C39 0000 00002CDD      1588  Fn_ID5_ChkDstReg    CMP.B   #0, opDstReg                * Check if destination register is 0
00002218  6700 0012               1589                      BEQ     Fn_ID5_DtaDstWrd            * Load next word
0000221C  0C39 0001 00002CDD      1590                      CMP.B   #1, opDstReg                * Check if destination register is 1
00002224  6700 0018               1591                      BEQ     Fn_ID5_DtaDstLng            * Load next long
00002228  6000 0026               1592                      BRA     Fn_ID5_Error                * Invalid registration Mode
0000222C                          1593  
0000222C  33DA 00002CE8           1594  Fn_ID5_DtaDstWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002232  13FC 0001 00002CEC      1595                      MOVE.B  #1, opDta2T                 * Set Data2 type as 1=Word
0000223A  6000 0016               1596                      BRA     Fn_ID5_Done
0000223E  23DA 00002CE8           1597  Fn_ID5_DtaDstLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002244  13FC 0002 00002CEC      1598                      MOVE.B  #2, opDta2T                 * Set Data2 type as 2=Long
0000224C  6000 0004               1599                      BRA     Fn_ID5_Done
00002250                          1600  
00002250                          1601  Fn_ID5_Error                                             * Exit out if error - main subroutine will handle DATA
00002250                          1602                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002250  4E75                    1603                      RTS   
00002252                          1604              
00002252  4E75                    1605  Fn_ID5_Done        RTS
00002252  4E75                    1606  -------------------- end include --------------------
00002254                          1607                      INCLUDE 'SR_ID6.X68'
00002254                          1608  
00002254                          1609  
00002254                          1610  SR_ID6              * This is to grab the first four that are already set, ID6
00002254  3639 00002C72           1611                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000225A  183C 000C               1612                      MOVE.B  #12,D4
0000225E  E86B                    1613                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002260  13C3 00002C74           1614                      MOVE.B  D3, opID        
00002266                          1615                      
00002266                          1616                      * Read next 4 bits into D3
00002266  3639 00002C72           1617                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000226C  183C 0004               1618                      MOVE.B  #4, D4
00002270  E96B                    1619                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002272  183C 000C               1620                      MOVE.B  #12,D4
00002276  E86B                    1621                      LSR.W   D4,D3                       * Shift right 12 to get next 4 bits
00002278  13C3 00002C74           1622                      MOVE.B  D3, opID
0000227E                          1623                      
0000227E                          1624                      * Read next 8 bits into D3
0000227E  3639 00002C72           1625                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002284  183C 0007               1626                      MOVE.B  #7, D4
00002288  E96B                    1627                      LSL.W   D4,D3                       * Shift left 8 to get rid of first 8 bits
0000228A  183C 0008               1628                      MOVE.B  #8,D4
0000228E  E86B                    1629                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
00002290  13C3 00002CDE           1630                      MOVE.B  D3, opDstMod
00002296                          1631              
00002296                          1632              ** Condition is stored in opID - displacement is in DstMod
00002296                          1633              ** All thats leftis to branch per condition and output name, check reg if needed more
00002296                          1634              ** BRA - opID=0
00002296                          1635              ** BEQ - opID=7
00002296                          1636              ** BGT - opID=14
00002296                          1637              ** BLE - opID=15
00002296  0C39 0000 00002C74      1638              CMP.B   #0,opID
0000229E  6700 002A               1639              BEQ     Fn_ID6_BRA
000022A2  0C39 0007 00002C74      1640              CMP.B   #7,opID
000022AA  6700 0028               1641              BEQ     Fn_ID6_BEQ
000022AE  0C39 000E 00002C74      1642              CMP.B   #14,opID
000022B6  6700 0026               1643              BEQ     Fn_ID6_BGT
000022BA  0C39 000F 00002C74      1644              CMP.B   #15,opID
000022C2  6700 0024               1645              BEQ     Fn_ID6_BLE
000022C6  6000 0078               1646              BRA     Fn_ID6_ERROR
000022CA                          1647  
000022CA  47F9 00002D32           1648  Fn_ID6_BRA  LEA     opNam_BRA,A3
000022D0  6000 001C               1649              BRA     Fn_ID6_Displacement
000022D4                          1650              
000022D4  47F9 00002D36           1651  Fn_ID6_BEQ  LEA     opNam_BEQ,A3
000022DA  6000 0012               1652              BRA     Fn_ID6_Displacement
000022DE                          1653              
000022DE  47F9 00002D3A           1654  Fn_ID6_BGT  LEA     opNam_BGT,A3
000022E4  6000 0008               1655              BRA     Fn_ID6_Displacement
000022E8                          1656              
000022E8  47F9 00002D3E           1657  Fn_ID6_BLE  LEA     opNam_BLE,A3
000022EE                          1658              
000022EE  0C39 0000 00002CDE      1659  Fn_ID6_Displacement CMP.B                   #$00,opDstMod
000022F6  6700 0024               1660              BEQ     Fn_ID6_Dsplcmnt16
000022FA  0C39 00FF 00002CDE      1661              CMP.B   #$FF,opDstMod
00002302  6700 002A               1662              BEQ     Fn_ID6_Dsplcmnt32
00002306                          1663              ** 8 bit is good
00002306  33F9 00002CDE 00002CE8  1664              MOVE.W  opDstMod,opDta2
00002310  13FC 0000 00002CEC      1665              MOVE.B  #0,opDta2T
00002318  6000 0028               1666              BRA     Fn_ID6_Done
0000231C                          1667              
0000231C  33DA 00002CE8           1668  Fn_ID6_Dsplcmnt16   MOVE.W  (A2)+,opDta2
00002322  13FC 0001 00002CEC      1669              MOVE.B  #1,opDta2T
0000232A  6000 0016               1670              BRA     Fn_ID6_Done
0000232E                          1671  
0000232E  23DA 00002CE8           1672  Fn_ID6_Dsplcmnt32   MOVE.L  (A2)+,opDta2
00002334  13FC 0002 00002CEC      1673              MOVE.B  #2,opDta2T
0000233C  6000 0004               1674              BRA     Fn_ID6_Done 
00002340                          1675  
00002340                          1676  Fn_ID6_Error                                             * Exit out if error - main subroutine will handle DATA
00002340                          1677                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002340  4E75                    1678                      RTS 
00002342                          1679  
00002342  4E75                    1680  Fn_ID6_Done        RTS
00002342  4E75                    1681  -------------------- end include --------------------
00002344                          1682                      INCLUDE 'SR_ID7.X68'
00002344                          1683  
00002344                          1684  
00002344                          1685  SR_ID7              * This is to grab the first four that are already set, ID7
00002344  3639 00002C72           1686                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000234A  183C 000C               1687                      MOVE.B  #12,D4
0000234E  E86B                    1688                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002350  13C3 00002C74           1689                      MOVE.B  D3, opID        
00002356                          1690                      
00002356                          1691                      * Read next 3 bits into D3
00002356  3639 00002C72           1692                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000235C  183C 0004               1693                      MOVE.B  #4, D4
00002360  E96B                    1694                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002362  183C 000D               1695                      MOVE.B  #13,D4
00002366  E86B                    1696                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002368  13C3 00002CE2           1697                      MOVE.B  D3, opDta1      
0000236E                          1698              
0000236E                          1699              * Read next 1 bits into D3
0000236E  3639 00002C72           1700                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002374  183C 0007               1701                      MOVE.B  #7, D4
00002378  E96B                    1702                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000237A  183C 000F               1703                      MOVE.B  #15,D4
0000237E  E86B                    1704                      LSR.W   D4,D3                       * Shift right 15 to get next 1 bits
00002380  13C3 00002CDE           1705                      MOVE.B  D3, opDstMod    
00002386  0C39 0000 00002CDE      1706              CMP.B   #0,opDstMod
0000238E  6600 0038               1707              BNE     Fn_ID7_Error
00002392                          1708              
00002392                          1709              * Read next 8 bits into D3
00002392  3639 00002C72           1710                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002398  183C 0008               1711                      MOVE.B  #8, D4
0000239C  E96B                    1712                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
0000239E  183C 0008               1713                      MOVE.B  #8,D4
000023A2  E86B                    1714                      LSR.W   D4,D3                       * Shift right 8 to get next 8 bits
000023A4  13C3 00002CE8           1715                      MOVE.B  D3, opDta2
000023AA                          1716  
000023AA  47F9 00002D42           1717              LEA     opNam_MOVEQ,A3
000023B0                          1718              * Set appropriate data
000023B0  13FC 0001 00002CEC      1719              MOVE.B  #1, opDta2T
000023B8  13FC 0007 00002CE0      1720              MOVE.B  #7, opSrcMod
000023C0  13FC 0000 00002CDF      1721              MOVE.B  #0, opSrcReg
000023C8                          1722  
000023C8                          1723  Fn_ID7_Error                                             * Exit out if error - main subroutine will handle DATA
000023C8                          1724                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000023C8  4E75                    1725                      RTS                                  * Return to main
000023CA                          1726              
000023CA  4E75                    1727  Fn_ID7_Done        RTS
000023CA  4E75                    1728  -------------------- end include --------------------
000023CC                          1729                      INCLUDE 'SR_ID8.X68'
000023CC                          1730  
000023CC                          1731  
000023CC                          1732  SR_ID8              * This is to grab the first four that are already set, ID4
000023CC  3639 00002C72           1733                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023D2  183C 000C               1734                      MOVE.B  #12,D4
000023D6  E86B                    1735                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000023D8  13C3 00002C74           1736                      MOVE.B  D3, opID        
000023DE                          1737                      
000023DE                          1738                      * Read next 3 bits into D3
000023DE  3639 00002C72           1739                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023E4  183C 0004               1740                      MOVE.B  #4, D4
000023E8  E96B                    1741                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000023EA  183C 000D               1742                      MOVE.B  #13,D4
000023EE  E86B                    1743                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000023F0  13C3 00002CDD           1744                      MOVE.B  D3, opDstReg
000023F6                          1745                      
000023F6                          1746                      * Read next 3 bits into D3
000023F6  3639 00002C72           1747                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000023FC  183C 0007               1748                      MOVE.B  #7, D4
00002400  E96B                    1749                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002402  183C 000D               1750                      MOVE.B  #13,D4
00002406  E86B                    1751                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002408  13C3 00002CDE           1752                      MOVE.B  D3, opDstMod
0000240E                          1753  
0000240E                          1754                      ** Read next 3 bits
0000240E                          1755                      **
0000240E  3639 00002C72           1756                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002414  183C 000A               1757                      MOVE.B  #10, D4
00002418  E96B                    1758                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000241A  183C 000D               1759                      MOVE.B  #13,D4
0000241E  E86B                    1760                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002420  13C3 00002CE0           1761                      MOVE.B  D3, opSrcMod
00002426                          1762  
00002426                          1763                      ** Read next 3 bits
00002426                          1764                      **
00002426  3639 00002C72           1765                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000242C  183C 000D               1766                      MOVE.B  #13, D4
00002430  E96B                    1767                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002432  183C 000D               1768                      MOVE.B  #13,D4
00002436  E86B                    1769                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002438  13C3 00002CDF           1770                      MOVE.B  D3, opSrcReg
0000243E                          1771              
0000243E                          1772              ** Find out if its Dn, ea or ea, Dn
0000243E                          1773              ** ea, Dn - 0,1,2
0000243E                          1774              ** Dn, ea - 4,5,6
0000243E  47F9 00002D48           1775              LEA     opNam_OR,A3
00002444  0C39 0003 00002CDE      1776              CMP.B   #3,opDstMod
0000244C  6D00 0012               1777              BLT     Fn_ID8_Case1
00002450  0C39 0007 00002CDE      1778              CMP.B   #7,opDstMod
00002458  6D00 0048               1779              BLT     Fn_ID8_Case2
0000245C  6000 0178               1780              BRA     Fn_ID8_Error
00002460                          1781  
00002460  13F9 00002CDE 00002C74  1782  Fn_ID8_Case1MOVE.B  opDstMod,opID
0000246A  13F9 00002CE0 00002CDE  1783              MOVE.B  opSrcMod,opDstMod
00002474  1C39 00002CDD           1784              MOVE.B  opDstReg,D6
0000247A  13F9 00002CDF 00002CDD  1785              MOVE.B  opSrcReg,opDstReg
00002484  13C6 00002CDF           1786              MOVE.B  D6,opSrcReg
0000248A  13FC 0000 00002CE0      1787              MOVE.B  #0,opSrcMod
00002492                          1788              ** Immediate data?
00002492  0C39 0007 00002CDE      1789              CMP.B   #7, opDstMod
0000249A  6700 002E               1790                      BEQ     Fn_ID8_DataDst
0000249E  6000 0138               1791                      BRA     Fn_ID8_Done
000024A2                          1792  
000024A2  13F9 00002CDE 00002C74  1793  Fn_ID8_Case2MOVE.B  opDstMod,opID
000024AC  5939 00002C74           1794              SUB.B   #4,opID
000024B2  13FC 0000 00002CDE      1795              MOVE.B  #0,opDstMod
000024BA                          1796              ** Immediate data?
000024BA  0C39 0007 00002CE0      1797              CMP.B   #7, opSrcMod
000024C2  6700 008C               1798                      BEQ     Fn_ID8_DataSrc
000024C6  6000 0110               1799                      BRA     Fn_ID8_Done
000024CA                          1800              
000024CA  0C39 0000 00002CDD      1801  Fn_ID8_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000024D2  6700 0058               1802                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
000024D6  0C39 0001 00002CDD      1803                      CMP.B   #1, opDstReg                * Check if source register is 1
000024DE  6700 005E               1804                      BEQ     Fn_ID8_DtaDstLng            * Load next long
000024E2  0C39 0004 00002CDD      1805                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000024EA  6700 0006               1806                      BEQ     Fn_ID8_DtaDstImd            * Load first word into word one
000024EE  6000 00E6               1807                      BRA     FN_ID8_Error                * Invalid register value
000024F2                          1808                      
000024F2  0C39 0001 00002C74      1809  Fn_ID8_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000024FA  6700 001E               1810                      BEQ     Fn_ID8_DtaDstByt            * Load next byte
000024FE  0C39 0003 00002C74      1811                      CMP.B   #3, opID                    * opID = 3 - size is word
00002506  6700 0024               1812                      BEQ     Fn_ID8_DtaDstWrd            * Load next word
0000250A  0C39 0002 00002C74      1813                      CMP.B   #2, opID                    * opID = 0 - size is long
00002512  6700 002A               1814                      BEQ     Fn_ID8_DtaDstLng            * Load next
00002516  6000 00BE               1815                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
0000251A                          1816  
0000251A  33DA 00002CE2           1817  Fn_ID8_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002520  13FC 0000 00002CE6      1818                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002528  6000 00AE               1819                      BRA     Fn_ID8_Done
0000252C  33DA 00002CE2           1820  Fn_ID8_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002532  13FC 0001 00002CE6      1821                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000253A  6000 009C               1822                      BRA     Fn_ID8_Done
0000253E  23DA 00002CE2           1823  Fn_ID8_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002544  13FC 0002 00002CE6      1824                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000254C  6000 008A               1825                      BRA     Fn_ID8_Done
00002550                          1826              
00002550  0C39 0000 00002CDF      1827  Fn_ID8_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002558  6700 0058               1828                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
0000255C  0C39 0001 00002CDF      1829                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002564  6700 005E               1830                      BEQ     Fn_ID8_DtaSrcLng            * Load next long
00002568  0C39 0004 00002CDF      1831                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002570  6700 0006               1832                      BEQ     Fn_ID8_DtaSrcImd            * Load first word into word one
00002574  6000 0060               1833                      BRA     FN_ID8_Error                * Invalid register value
00002578                          1834                      
00002578  0C39 0001 00002C74      1835  Fn_ID8_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002580  6700 001E               1836                      BEQ     Fn_ID8_DtaSrcByt            * Load next byte
00002584  0C39 0003 00002C74      1837                      CMP.B   #3, opID                    * opID = 3 - size is word
0000258C  6700 0024               1838                      BEQ     Fn_ID8_DtaSrcWrd            * Load next word
00002590  0C39 0002 00002C74      1839                      CMP.B   #2, opID                    * opID = 0 - size is long
00002598  6700 002A               1840                      BEQ     Fn_ID8_DtaSrcLng            * Load next
0000259C  6000 0038               1841                      BRA     Fn_ID8_Error                * Invalid opID (this should never happen) long
000025A0                          1842  
000025A0  33DA 00002CE8           1843  Fn_ID8_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000025A6  13FC 0000 00002CEC      1844                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000025AE  6000 0028               1845                      BRA     Fn_ID8_Done
000025B2  33DA 00002CE8           1846  Fn_ID8_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000025B8  13FC 0001 00002CEC      1847                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000025C0  6000 0016               1848                      BRA     Fn_ID8_Done
000025C4  23DA 00002CE8           1849  Fn_ID8_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000025CA  13FC 0002 00002CEC      1850                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000025D2  6000 0004               1851                      BRA     Fn_ID8_Done
000025D6                          1852  
000025D6                          1853  Fn_ID8_Error                                             * Exit out if error - main subroutine will handle DATA
000025D6                          1854                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000025D6  4E75                    1855                      RTS   
000025D8                          1856              
000025D8  4E75                    1857  Fn_ID8_Done        RTS
000025D8  4E75                    1858  -------------------- end include --------------------
000025DA                          1859                      INCLUDE 'SR_ID9.X68'
000025DA                          1860  
000025DA                          1861  
000025DA                          1862  SR_ID9      * This is to grab the first four that are already set, ID4
000025DA  3639 00002C72           1863                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025E0  183C 000C               1864                      MOVE.B  #12,D4
000025E4  E86B                    1865                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000025E6  13C3 00002C74           1866                      MOVE.B  D3, opID        
000025EC                          1867                      
000025EC                          1868                      * Read next 3 bits into D3
000025EC  3639 00002C72           1869                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000025F2  183C 0004               1870                      MOVE.B  #4, D4
000025F6  E96B                    1871                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
000025F8  183C 000D               1872                      MOVE.B  #13,D4
000025FC  E86B                    1873                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
000025FE  13C3 00002CDD           1874                      MOVE.B  D3, opDstReg
00002604                          1875                      
00002604                          1876                      * Read next 3 bits into D3
00002604  3639 00002C72           1877                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000260A  183C 0007               1878                      MOVE.B  #7, D4
0000260E  E96B                    1879                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002610  183C 000D               1880                      MOVE.B  #13,D4
00002614  E86B                    1881                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002616  13C3 00002CDE           1882                      MOVE.B  D3, opDstMod
0000261C                          1883  
0000261C                          1884                      ** Read next 3 bits
0000261C                          1885                      **
0000261C  3639 00002C72           1886                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002622  183C 000A               1887                      MOVE.B  #10, D4
00002626  E96B                    1888                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002628  183C 000D               1889                      MOVE.B  #13,D4
0000262C  E86B                    1890                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
0000262E  13C3 00002CE0           1891                      MOVE.B  D3, opSrcMod
00002634                          1892  
00002634                          1893                      ** Read next 3 bits
00002634                          1894                      **
00002634  3639 00002C72           1895                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000263A  183C 000D               1896                      MOVE.B  #13, D4
0000263E  E96B                    1897                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002640  183C 000D               1898                      MOVE.B  #13,D4
00002644  E86B                    1899                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002646  13C3 00002CDF           1900                      MOVE.B  D3, opSrcReg
0000264C                          1901              
0000264C                          1902              ** Find out if its Dn, ea or ea, Dn
0000264C                          1903              ** ea, Dn - 0,1,2
0000264C                          1904              ** Dn, ea - 4,5,6
0000264C  47F9 00002D4B           1905              LEA     opNam_SUB,A3
00002652  0C39 0003 00002CDE      1906              CMP.B   #3,opDstMod
0000265A  6D00 0012               1907              BLT     Fn_ID9_Case1
0000265E  0C39 0007 00002CDE      1908              CMP.B   #7,opDstMod
00002666  6D00 0048               1909              BLT     Fn_ID9_Case2
0000266A  6000 0178               1910              BRA     Fn_ID9_Error
0000266E                          1911  
0000266E  13F9 00002CDE 00002C74  1912  Fn_ID9_Case1MOVE.B  opDstMod,opID
00002678  13F9 00002CE0 00002CDE  1913              MOVE.B  opSrcMod,opDstMod
00002682  1C39 00002CDD           1914              MOVE.B  opDstReg,D6
00002688  13F9 00002CDF 00002CDD  1915              MOVE.B  opSrcReg,opDstReg
00002692  13C6 00002CDF           1916              MOVE.B  D6,opSrcReg
00002698  13FC 0000 00002CE0      1917              MOVE.B  #0,opSrcMod
000026A0                          1918              ** Immediate data?
000026A0  0C39 0007 00002CDE      1919              CMP.B   #7, opDstMod
000026A8  6700 002E               1920                      BEQ     Fn_ID9_DataDst
000026AC  6000 0138               1921                      BRA     Fn_ID9_Done
000026B0                          1922  
000026B0  13F9 00002CDE 00002C74  1923  Fn_ID9_Case2MOVE.B  opDstMod,opID
000026BA  5939 00002C74           1924              SUB.B   #4,opID
000026C0  13FC 0000 00002CDE      1925              MOVE.B  #0,opDstMod
000026C8                          1926              ** Immediate data?
000026C8  0C39 0007 00002CE0      1927              CMP.B   #7, opSrcMod
000026D0  6700 008C               1928                      BEQ     Fn_ID9_DataSrc
000026D4  6000 0110               1929                      BRA     Fn_ID9_Done
000026D8                          1930              
000026D8  0C39 0000 00002CDD      1931  Fn_ID9_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000026E0  6700 0058               1932                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
000026E4  0C39 0001 00002CDD      1933                      CMP.B   #1, opDstReg                * Check if source register is 1
000026EC  6700 005E               1934                      BEQ     Fn_ID9_DtaDstLng            * Load next long
000026F0  0C39 0004 00002CDD      1935                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
000026F8  6700 0006               1936                      BEQ     Fn_ID9_DtaDstImd            * Load first word into word one
000026FC  6000 00E6               1937                      BRA     FN_ID9_Error                * Invalid register value
00002700                          1938                      
00002700  0C39 0001 00002C74      1939  Fn_ID9_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002708  6700 001E               1940                      BEQ     Fn_ID9_DtaDstByt            * Load next byte
0000270C  0C39 0003 00002C74      1941                      CMP.B   #3, opID                    * opID = 3 - size is word
00002714  6700 0024               1942                      BEQ     Fn_ID9_DtaDstWrd            * Load next word
00002718  0C39 0002 00002C74      1943                      CMP.B   #2, opID                    * opID = 0 - size is long
00002720  6700 002A               1944                      BEQ     Fn_ID9_DtaDstLng            * Load next
00002724  6000 00BE               1945                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
00002728                          1946  
00002728  33DA 00002CE2           1947  Fn_ID9_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
0000272E  13FC 0000 00002CE6      1948                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002736  6000 00AE               1949                      BRA     Fn_ID9_Done
0000273A  33DA 00002CE2           1950  Fn_ID9_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002740  13FC 0001 00002CE6      1951                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002748  6000 009C               1952                      BRA     Fn_ID9_Done
0000274C  23DA 00002CE2           1953  Fn_ID9_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002752  13FC 0002 00002CE6      1954                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000275A  6000 008A               1955                      BRA     Fn_ID9_Done
0000275E                          1956              
0000275E  0C39 0000 00002CDF      1957  Fn_ID9_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002766  6700 0058               1958                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000276A  0C39 0001 00002CDF      1959                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002772  6700 005E               1960                      BEQ     Fn_ID9_DtaSrcLng            * Load next long
00002776  0C39 0004 00002CDF      1961                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
0000277E  6700 0006               1962                      BEQ     Fn_ID9_DtaSrcImd            * Load first word into word one
00002782  6000 0060               1963                      BRA     FN_ID9_Error                * Invalid register value
00002786                          1964                      
00002786  0C39 0001 00002C74      1965  Fn_ID9_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000278E  6700 001E               1966                      BEQ     Fn_ID9_DtaSrcByt            * Load next byte
00002792  0C39 0003 00002C74      1967                      CMP.B   #3, opID                    * opID = 3 - size is word
0000279A  6700 0024               1968                      BEQ     Fn_ID9_DtaSrcWrd            * Load next word
0000279E  0C39 0002 00002C74      1969                      CMP.B   #2, opID                    * opID = 0 - size is long
000027A6  6700 002A               1970                      BEQ     Fn_ID9_DtaSrcLng            * Load next
000027AA  6000 0038               1971                      BRA     Fn_ID9_Error                * Invalid opID (this should never happen) long
000027AE                          1972  
000027AE  33DA 00002CE8           1973  Fn_ID9_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000027B4  13FC 0000 00002CEC      1974                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000027BC  6000 0028               1975                      BRA     Fn_ID9_Done
000027C0  33DA 00002CE8           1976  Fn_ID9_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000027C6  13FC 0001 00002CEC      1977                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000027CE  6000 0016               1978                      BRA     Fn_ID9_Done
000027D2  23DA 00002CE8           1979  Fn_ID9_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000027D8  13FC 0002 00002CEC      1980                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000027E0  6000 0004               1981                      BRA     Fn_ID9_Done
000027E4                          1982  
000027E4                          1983  Fn_ID9_Error                                             * Exit out if error - main subroutine will handle DATA
000027E4                          1984                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000027E4  4E75                    1985                      RTS   
000027E6                          1986  
000027E6  4E75                    1987  Fn_ID9_Done        RTS
000027E6  4E75                    1988  -------------------- end include --------------------
000027E8                          1989                      INCLUDE 'SR_IDA.X68'
000027E8                          1990  
000027E8                          1991  
000027E8                          1992  SR_IDA
000027E8                          1993  
000027E8                          1994  
000027E8  4E75                    1995  Fn_IDA_Done        RTS
000027E8  4E75                    1996  -------------------- end include --------------------
000027EA                          1997                      INCLUDE 'SR_IDB.X68'
000027EA                          1998  
000027EA                          1999  
000027EA                          2000  SR_IDB
000027EA                          2001  
000027EA                          2002  
000027EA  4E75                    2003  Fn_IDB_Done        RTS
000027EA  4E75                    2004  -------------------- end include --------------------
000027EC                          2005                      INCLUDE 'SR_IDC.X68'
000027EC                          2006  
000027EC                          2007  
000027EC                          2008  SR_IDC      * This is to grab the first four that are already set, ID4
000027EC  3639 00002C72           2009                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
000027F2  183C 000C               2010                      MOVE.B  #12,D4
000027F6  E86B                    2011                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
000027F8  13C3 00002C74           2012                      MOVE.B  D3, opID        
000027FE                          2013                      
000027FE                          2014                      * Read next 3 bits into D3
000027FE  3639 00002C72           2015                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002804  183C 0004               2016                      MOVE.B  #4, D4
00002808  E96B                    2017                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
0000280A  183C 000D               2018                      MOVE.B  #13,D4
0000280E  E86B                    2019                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002810  13C3 00002CDD           2020                      MOVE.B  D3, opDstReg
00002816                          2021                      
00002816                          2022                      * Read next 3 bits into D3
00002816  3639 00002C72           2023                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000281C  183C 0007               2024                      MOVE.B  #7, D4
00002820  E96B                    2025                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002822  183C 000D               2026                      MOVE.B  #13,D4
00002826  E86B                    2027                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002828  13C3 00002CDE           2028                      MOVE.B  D3, opDstMod
0000282E                          2029  
0000282E                          2030                      ** Read next 3 bits
0000282E                          2031                      **
0000282E  3639 00002C72           2032                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002834  183C 000A               2033                      MOVE.B  #10, D4
00002838  E96B                    2034                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
0000283A  183C 000D               2035                      MOVE.B  #13,D4
0000283E  E86B                    2036                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002840  13C3 00002CE0           2037                      MOVE.B  D3, opSrcMod
00002846                          2038  
00002846                          2039                      ** Read next 3 bits
00002846                          2040                      **
00002846  3639 00002C72           2041                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
0000284C  183C 000D               2042                      MOVE.B  #13, D4
00002850  E96B                    2043                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002852  183C 000D               2044                      MOVE.B  #13,D4
00002856  E86B                    2045                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002858  13C3 00002CDF           2046                      MOVE.B  D3, opSrcReg
0000285E                          2047              
0000285E                          2048              ** Find out if its Dn, ea or ea, Dn
0000285E                          2049              ** ea, Dn - 0,1,2
0000285E                          2050              ** Dn, ea - 4,5,6
0000285E  47F9 00002D4F           2051              LEA     opNam_AND,A3
00002864  0C39 0003 00002CDE      2052              CMP.B   #3,opDstMod
0000286C  6D00 0012               2053              BLT     Fn_IDC_Case1
00002870  0C39 0007 00002CDE      2054              CMP.B   #7,opDstMod
00002878  6D00 0048               2055              BLT     Fn_IDC_Case2
0000287C  6000 0178               2056              BRA     Fn_IDC_Error
00002880                          2057  
00002880  13F9 00002CDE 00002C74  2058  Fn_IDC_Case1MOVE.B  opDstMod,opID
0000288A  13F9 00002CE0 00002CDE  2059              MOVE.B  opSrcMod,opDstMod
00002894  1C39 00002CDD           2060              MOVE.B  opDstReg,D6
0000289A  13F9 00002CDF 00002CDD  2061              MOVE.B  opSrcReg,opDstReg
000028A4  13C6 00002CDF           2062              MOVE.B  D6,opSrcReg
000028AA  13FC 0000 00002CE0      2063              MOVE.B  #0,opSrcMod
000028B2                          2064              ** Immediate data?
000028B2  0C39 0007 00002CDE      2065              CMP.B   #7, opDstMod
000028BA  6700 002E               2066                      BEQ     Fn_IDC_DataDst
000028BE  6000 0138               2067                      BRA     Fn_IDC_Done
000028C2                          2068  
000028C2  13F9 00002CDE 00002C74  2069  Fn_IDC_Case2MOVE.B  opDstMod,opID
000028CC  5939 00002C74           2070              SUB.B   #4,opID
000028D2  13FC 0000 00002CDE      2071              MOVE.B  #0,opDstMod
000028DA                          2072              ** Immediate data?
000028DA  0C39 0007 00002CE0      2073              CMP.B   #7, opSrcMod
000028E2  6700 008C               2074                      BEQ     Fn_IDC_DataSrc
000028E6  6000 0110               2075                      BRA     Fn_IDC_Done
000028EA                          2076              
000028EA  0C39 0000 00002CDD      2077  Fn_IDC_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
000028F2  6700 0058               2078                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
000028F6  0C39 0001 00002CDD      2079                      CMP.B   #1, opDstReg                * Check if source register is 1
000028FE  6700 005E               2080                      BEQ     Fn_IDC_DtaDstLng            * Load next long
00002902  0C39 0004 00002CDD      2081                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
0000290A  6700 0006               2082                      BEQ     Fn_IDC_DtaDstImd            * Load first word into word one
0000290E  6000 00E6               2083                      BRA     FN_IDC_Error                * Invalid register value
00002912                          2084                      
00002912  0C39 0001 00002C74      2085  Fn_IDC_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
0000291A  6700 001E               2086                      BEQ     Fn_IDC_DtaDstByt            * Load next byte
0000291E  0C39 0003 00002C74      2087                      CMP.B   #3, opID                    * opID = 3 - size is word
00002926  6700 0024               2088                      BEQ     Fn_IDC_DtaDstWrd            * Load next word
0000292A  0C39 0002 00002C74      2089                      CMP.B   #2, opID                    * opID = 0 - size is long
00002932  6700 002A               2090                      BEQ     Fn_IDC_DtaDstLng            * Load next
00002936  6000 00BE               2091                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
0000293A                          2092  
0000293A  33DA 00002CE2           2093  Fn_IDC_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002940  13FC 0000 00002CE6      2094                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002948  6000 00AE               2095                      BRA     Fn_IDC_Done
0000294C  33DA 00002CE2           2096  Fn_IDC_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002952  13FC 0001 00002CE6      2097                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
0000295A  6000 009C               2098                      BRA     Fn_IDC_Done
0000295E  23DA 00002CE2           2099  Fn_IDC_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002964  13FC 0002 00002CE6      2100                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
0000296C  6000 008A               2101                      BRA     Fn_IDC_Done
00002970                          2102              
00002970  0C39 0000 00002CDF      2103  Fn_IDC_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002978  6700 0058               2104                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
0000297C  0C39 0001 00002CDF      2105                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002984  6700 005E               2106                      BEQ     Fn_IDC_DtaSrcLng            * Load next long
00002988  0C39 0004 00002CDF      2107                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002990  6700 0006               2108                      BEQ     Fn_IDC_DtaSrcImd            * Load first word into word one
00002994  6000 0060               2109                      BRA     FN_IDC_Error                * Invalid register value
00002998                          2110                      
00002998  0C39 0001 00002C74      2111  Fn_IDC_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
000029A0  6700 001E               2112                      BEQ     Fn_IDC_DtaSrcByt            * Load next byte
000029A4  0C39 0003 00002C74      2113                      CMP.B   #3, opID                    * opID = 3 - size is word
000029AC  6700 0024               2114                      BEQ     Fn_IDC_DtaSrcWrd            * Load next word
000029B0  0C39 0002 00002C74      2115                      CMP.B   #2, opID                    * opID = 0 - size is long
000029B8  6700 002A               2116                      BEQ     Fn_IDC_DtaSrcLng            * Load next
000029BC  6000 0038               2117                      BRA     Fn_IDC_Error                * Invalid opID (this should never happen) long
000029C0                          2118  
000029C0  33DA 00002CE8           2119  Fn_IDC_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
000029C6  13FC 0000 00002CEC      2120                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
000029CE  6000 0028               2121                      BRA     Fn_IDC_Done
000029D2  33DA 00002CE8           2122  Fn_IDC_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
000029D8  13FC 0001 00002CEC      2123                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
000029E0  6000 0016               2124                      BRA     Fn_IDC_Done
000029E4  23DA 00002CE8           2125  Fn_IDC_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
000029EA  13FC 0002 00002CEC      2126                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
000029F2  6000 0004               2127                      BRA     Fn_IDC_Done
000029F6                          2128  
000029F6                          2129  Fn_IDC_Error                                             * Exit out if error - main subroutine will handle DATA
000029F6                          2130                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
000029F6  4E75                    2131                      RTS   
000029F8                          2132  
000029F8  4E75                    2133  Fn_IDC_Done        RTS
000029F8  4E75                    2134  -------------------- end include --------------------
000029FA                          2135                      INCLUDE 'SR_IDD.X68'
000029FA                          2136  
000029FA                          2137  
000029FA                          2138  SR_IDD      * This is to grab the first four that are already set, ID4
000029FA  3639 00002C72           2139                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A00  183C 000C               2140                      MOVE.B  #12,D4
00002A04  E86B                    2141                      LSR.W   D4,D3                       * Shift right 12 to get first 4 bits
00002A06  13C3 00002C74           2142                      MOVE.B  D3, opID        
00002A0C                          2143                      
00002A0C                          2144                      * Read next 3 bits into D3
00002A0C  3639 00002C72           2145                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A12  183C 0004               2146                      MOVE.B  #4, D4
00002A16  E96B                    2147                      LSL.W   D4,D3                       * Shift left 4 to get rid of first 4 bits
00002A18  183C 000D               2148                      MOVE.B  #13,D4
00002A1C  E86B                    2149                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A1E  13C3 00002CDD           2150                      MOVE.B  D3, opDstReg
00002A24                          2151                      
00002A24                          2152                      * Read next 3 bits into D3
00002A24  3639 00002C72           2153                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A2A  183C 0007               2154                      MOVE.B  #7, D4
00002A2E  E96B                    2155                      LSL.W   D4,D3                       * Shift left 7 to get rid of first 7 bits
00002A30  183C 000D               2156                      MOVE.B  #13,D4
00002A34  E86B                    2157                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A36  13C3 00002CDE           2158                      MOVE.B  D3, opDstMod
00002A3C                          2159  
00002A3C                          2160                      ** Read next 3 bits
00002A3C                          2161                      **
00002A3C  3639 00002C72           2162                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A42  183C 000A               2163                      MOVE.B  #10, D4
00002A46  E96B                    2164                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A48  183C 000D               2165                      MOVE.B  #13,D4
00002A4C  E86B                    2166                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A4E  13C3 00002CE0           2167                      MOVE.B  D3, opSrcMod
00002A54                          2168  
00002A54                          2169                      ** Read next 3 bits
00002A54                          2170                      **
00002A54  3639 00002C72           2171                      MOVE.W  opWord, D3                  * store opWord in D3 so it doesn't get modified
00002A5A  183C 000D               2172                      MOVE.B  #13, D4
00002A5E  E96B                    2173                      LSL.W   D4, D3                      * Shift left 10 to get rid of first 10 bits
00002A60  183C 000D               2174                      MOVE.B  #13,D4
00002A64  E86B                    2175                      LSR.W   D4,D3                       * Shift right 13 to get next 3 bits
00002A66  13C3 00002CDF           2176                      MOVE.B  D3, opSrcReg
00002A6C                          2177              
00002A6C                          2178              ** Find out if its Dn, ea or ea, Dn
00002A6C                          2179              ** ea, Dn - 0,1,2
00002A6C                          2180              ** Dn, ea - 4,5,6
00002A6C  0C39 0003 00002CDE      2181              CMP.B   #3,opDstMod
00002A74  6D00 002A               2182              BLT     Fn_IDD_Case1
00002A78  0C39 0003 00002CDE      2183              CMP.B   #3,opDstMod
00002A80  6700 0094               2184              BEQ     Fn_IDD_Case3
00002A84  0C39 0007 00002CDE      2185              CMP.B   #7,opDstMod
00002A8C  6D00 005A               2186              BLT     Fn_IDD_Case2
00002A90  0C39 0007 00002CDE      2187              CMP.B   #7,opDstMod
00002A98  6700 007C               2188              BEQ     Fn_IDD_Case3
00002A9C  6000 01B2               2189              BRA     Fn_IDD_Error
00002AA0                          2190  
00002AA0  47F9 00002D53           2191  Fn_IDD_Case1LEA     opNam_ADD,A3
00002AA6  13F9 00002CDE 00002C74  2192              MOVE.B  opDstMod,opID
00002AB0  13F9 00002CE0 00002CDE  2193              MOVE.B  opSrcMod,opDstMod
00002ABA  1C39 00002CDD           2194              MOVE.B  opDstReg,D6
00002AC0  13F9 00002CDF 00002CDD  2195              MOVE.B  opSrcReg,opDstReg
00002ACA  13C6 00002CDF           2196              MOVE.B  D6,opSrcReg
00002AD0  13FC 0000 00002CE0      2197              MOVE.B  #0,opSrcMod
00002AD8                          2198              ** Immediate data?
00002AD8  0C39 0007 00002CDE      2199              CMP.B   #7, opDstMod
00002AE0  6700 0062               2200                      BEQ     Fn_IDD_DataDst
00002AE4  6000 016C               2201                      BRA     Fn_IDD_Done
00002AE8                          2202  
00002AE8  47F9 00002D53           2203  Fn_IDD_Case2LEA     opNam_ADD,A3
00002AEE  13F9 00002CDE 00002C74  2204              MOVE.B  opDstMod,opID
00002AF8  5939 00002C74           2205              SUB.B   #4,opID
00002AFE  13FC 0000 00002CDE      2206              MOVE.B  #0,opDstMod
00002B06                          2207              ** Immediate data?
00002B06  0C39 0007 00002CE0      2208              CMP.B   #7, opSrcMod
00002B0E  6700 00BA               2209                      BEQ     Fn_IDD_DataSrc
00002B12  6000 013E               2210                      BRA     Fn_IDD_Done
00002B16                          2211              
00002B16  47F9 00002D57           2212  Fn_IDD_Case3LEA     opNam_ADDA,A3
00002B1C  13F9 00002CDE 00002C74  2213              MOVE.B  opDstMod,opID
00002B26  5939 00002C74           2214              SUB.B   #4,opID
00002B2C  13FC 0000 00002CDE      2215              MOVE.B  #0,opDstMod
00002B34                          2216              ** Immediate data?
00002B34  0C39 0007 00002CE0      2217              CMP.B   #7, opSrcMod
00002B3C  6700 008C               2218                      BEQ     Fn_IDD_DataSrc
00002B40  6000 0110               2219                      BRA     Fn_IDD_Done
00002B44                          2220              
00002B44  0C39 0000 00002CDD      2221  Fn_IDD_DataDst      CMP.B   #0, opDstReg                * Check is source register is 0
00002B4C  6700 0058               2222                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002B50  0C39 0001 00002CDD      2223                      CMP.B   #1, opDstReg                * Check if source register is 1
00002B58  6700 005E               2224                      BEQ     Fn_IDD_DtaDstLng            * Load next long
00002B5C  0C39 0004 00002CDD      2225                      CMP.B   #4, opDstReg                * Check if source register is 4 (immediate value)
00002B64  6700 0006               2226                      BEQ     Fn_IDD_DtaDstImd            * Load first word into word one
00002B68  6000 00E6               2227                      BRA     FN_IDD_Error                * Invalid register value
00002B6C                          2228                      
00002B6C  0C39 0001 00002C74      2229  Fn_IDD_DtaDstImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002B74  6700 001E               2230                      BEQ     Fn_IDD_DtaDstByt            * Load next byte
00002B78  0C39 0003 00002C74      2231                      CMP.B   #3, opID                    * opID = 3 - size is word
00002B80  6700 0024               2232                      BEQ     Fn_IDD_DtaDstWrd            * Load next word
00002B84  0C39 0002 00002C74      2233                      CMP.B   #2, opID                    * opID = 0 - size is long
00002B8C  6700 002A               2234                      BEQ     Fn_IDD_DtaDstLng            * Load next
00002B90  6000 00BE               2235                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002B94                          2236  
00002B94  33DA 00002CE2           2237  Fn_IDD_DtaDstByt    MOVE.W  (A2)+, opDta1               * Load byte and increment address count (note .W for byte)
00002B9A  13FC 0000 00002CE6      2238                      MOVE.B  #0, opDta1T                 * Set Data 1 type as 0=Byte
00002BA2  6000 00AE               2239                      BRA     Fn_IDD_Done
00002BA6  33DA 00002CE2           2240  Fn_IDD_DtaDstWrd    MOVE.W  (A2)+, opDta1               * Load word and increment address count
00002BAC  13FC 0001 00002CE6      2241                      MOVE.B  #1, opDta1T                 * Set Data 1 type as 1=Word
00002BB4  6000 009C               2242                      BRA     Fn_IDD_Done
00002BB8  23DA 00002CE2           2243  Fn_IDD_DtaDstLng    MOVE.L  (A2)+, opDta1               * Load long and increment address count
00002BBE  13FC 0002 00002CE6      2244                      MOVE.B  #2, opDta1T                 * Set Data 1 type as 2=Long
00002BC6  6000 008A               2245                      BRA     Fn_IDD_Done
00002BCA                          2246              
00002BCA  0C39 0000 00002CDF      2247  Fn_IDD_DataSrc      CMP.B   #0, opSrcReg                * Check is source register is 0
00002BD2  6700 0058               2248                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002BD6  0C39 0001 00002CDF      2249                      CMP.B   #1, opSrcReg                * Check if source register is 1
00002BDE  6700 005E               2250                      BEQ     Fn_IDD_DtaSrcLng            * Load next long
00002BE2  0C39 0004 00002CDF      2251                      CMP.B   #4, opSrcReg                * Check if source register is 4 (immediate value)
00002BEA  6700 0006               2252                      BEQ     Fn_IDD_DtaSrcImd            * Load first word into word one
00002BEE  6000 0060               2253                      BRA     FN_IDD_Error                * Invalid register value
00002BF2                          2254                      
00002BF2  0C39 0001 00002C74      2255  Fn_IDD_DtaSrcImd    CMP.B   #1, opID                    * opID = 0 - size is byte
00002BFA  6700 001E               2256                      BEQ     Fn_IDD_DtaSrcByt            * Load next byte
00002BFE  0C39 0003 00002C74      2257                      CMP.B   #3, opID                    * opID = 3 - size is word
00002C06  6700 0024               2258                      BEQ     Fn_IDD_DtaSrcWrd            * Load next word
00002C0A  0C39 0002 00002C74      2259                      CMP.B   #2, opID                    * opID = 0 - size is long
00002C12  6700 002A               2260                      BEQ     Fn_IDD_DtaSrcLng            * Load next
00002C16  6000 0038               2261                      BRA     Fn_IDD_Error                * Invalid opID (this should never happen) long
00002C1A                          2262  
00002C1A  33DA 00002CE8           2263  Fn_IDD_DtaSrcByt    MOVE.W  (A2)+, opDta2               * Load byte and increment address count (note .W for byte)
00002C20  13FC 0000 00002CEC      2264                      MOVE.B  #0, opDta2T                 * Set Data 1 type as 0=Byte
00002C28  6000 0028               2265                      BRA     Fn_IDD_Done
00002C2C  33DA 00002CE8           2266  Fn_IDD_DtaSrcWrd    MOVE.W  (A2)+, opDta2               * Load word and increment address count
00002C32  13FC 0001 00002CEC      2267                      MOVE.B  #1, opDta2T                 * Set Data 1 type as 1=Word
00002C3A  6000 0016               2268                      BRA     Fn_IDD_Done
00002C3E  23DA 00002CE8           2269  Fn_IDD_DtaSrcLng    MOVE.L  (A2)+, opDta2               * Load long and increment address count
00002C44  13FC 0002 00002CEC      2270                      MOVE.B  #2, opDta2T                 * Set Data 1 type as 2=Long
00002C4C  6000 0004               2271                      BRA     Fn_IDD_Done
00002C50                          2272  
00002C50                          2273  Fn_IDD_Error                                             * Exit out if error - main subroutine will handle DATA
00002C50                          2274                      *MOVEM.L (SP)+,D0-D7/A0-A6           * Restore registers
00002C50  4E75                    2275                      RTS   
00002C52                          2276  
00002C52  4E75                    2277  Fn_IDD_Done        RTS
00002C52  4E75                    2278  -------------------- end include --------------------
00002C54                          2279                      INCLUDE 'SR_IDE.X68'
00002C54                          2280  
00002C54                          2281  SR_IDE
00002C54                          2282  
00002C54  4E75                    2283                RTS
00002C54  4E75                    2284  -------------------- end include --------------------
00002C56                          2285  
00002C56                          2286  ** -----------------------------------------------------------
00002C56                          2287  ** Variables and constants
00002C56                          2288  ** -----------------------------------------------------------
00002C56                          2289  
00002C56  =0000001A               2290  maxLines            EQU      26                      * Max lines to display
00002C56                          2291  
00002C56= 00000000                2292  adrValStart         DC.L     $00000000               * Value of starting address - set by user
00002C5A= 38 39 41 42 43 44 ...   2293  adrStrStart         DC.B     '89ABCDEF',0            * String hex value display for start address
00002C63= FF                      2294  adrStsStart         DC.B     $FF                     * Status of starting address
00002C64                          2295                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002C64= 00000000                2296  adrValEnd           DC.L     $00000000               * Value of ending address - set by user
00002C68= 38 39 41 42 43 44 ...   2297  adrStrEnd           DC.B     '89ABCDEF',0            * String hex value display for end address
00002C71= FF                      2298  adrStsEnd           DC.B     $FF                     * Status of ending address
00002C72                          2299                                                       *   FF not set, 00 set, 01 length error, 02 hex error
00002C72                          2300  
00002C72= 0000                    2301  opWord              DC.W     $0000                   * 16 bit instruction Word
00002C74= 00                      2302  opID                DC.B     $00                     * First 4 bit value ID
00002C75= 01                      2303  opErr               DC.B     $01                     * Error byte: If set to 1 then is DATA. default is error
00002C76                          2304  
00002C76= 00000000                2305  opValAdr            DC.L     $00000000               * Instruction address - used for calculation
00002C7A= 38 39 41 42 43 44 ...   2306  opStrAdr            DC.B     '89ABCDEF',0            * String address
00002C84= 00000000                2307  opNxtAdr            DC.L     $00000000               * Store next valid word in case instruction returns error
00002C88                          2308  
00002C88= 50 6C 61 63 65 68 ...   2309  opOutBuf            DC.B     'Placeholder 80 cols wide output buffer                                          '
00002CD8= 00000000                2310  opPtrNam            DC.L     $00000000               * Pointer to full text name e.g. 'MOVE'
00002CDC                          2311  
00002CDC= FF                      2312  opValSiz            DC.B     $FF                     * Instruction size value $FF=Not set, 1=Byte, 2=Word, 3=Long
00002CDD                          2313  
00002CDD= FF                      2314  opDstReg            DC.B     $FF                     * Destination Register Value
00002CDE= FF                      2315  opDstMod            DC.B     $FF                     * Destination Mode Value
00002CDF= FF                      2316  opSrcReg            DC.B     $FF                     * Source Register Value
00002CE0= FF                      2317  opSrcMod            DC.B     $FF                     * Source Register Mode
00002CE1                          2318  
00002CE2= 00000000                2319  opDta1              DC.L     $00000000               * Data value one (most likely source)
00002CE6= FF                      2320  opDta1T             DC.B     $FF                     * Data value one type ($FF not set, 0=byte, 1=word, 2=long)
00002CE8= 00000000                2321  opDta2              DC.L     $00000000               * Data value two (most likely destination)
00002CEC= FF                      2322  opDta2T             DC.B     $FF                     * Data value two type ($FF not set, 0=byte, 1=word, 2=long)
00002CED= 30 30 30 30 00          2323  opStrDtaWrd         DC.B     '0000',0                * Data value string placeholder - dynamically built
00002CF2= 30 30 30 30 30 30 ...   2324  opStrDtaLng         DC.B     '00000000',0            * Data value string placeholder - dynamically built
00002CFB                          2325  
00002CFC= 00000000                2326  opMask              DC.L     $00000000               * Mask for MOVEM
00002D00= 00                      2327  opRotate            DC.B     $00                     * Rotation for IDE(14)
00002D01= 00                      2328  opSizDir            DC.B     $00                     * Size/Direction for IDE(14)
00002D02= 00                      2329  opIR                DC.B     $00                     * Immediate/Rotate for IDE(14)
00002D03                          2330  
00002D03= 44 41 54 41 00          2331  opNam_DATA          DC.B     'DATA',0
00002D08= 4D 4F 56 45 00          2332  opNam_MOVE          DC.B     'MOVE',0                * String value for instruction
00002D0D= 4D 4F 56 45 41 00       2333  opNam_MOVEA         DC.B     'MOVEA',0               * String value for instruction
00002D13= 4C 45 41 00             2334  opNam_LEA           DC.B     'LEA',0                 * String value for instruction
00002D17= 4E 4F 54 00             2335  opNam_NOT           DC.B     'NOT',0                 * String value for instruction
00002D1B= 4D 4F 56 45 4D 00       2336  opNam_MOVEM         DC.B     'MOVEM',0               * String value for instruction
00002D21= 4E 4F 50 00             2337  opNam_NOP           DC.B     'NOP',0                 * String value for instruction
00002D25= 52 54 53 00             2338  opNam_RTS           DC.B     'RTS',0                 * String value for instruction
00002D29= 4A 53 52 00             2339  opNam_JSR           DC.B     'JSR',0                 * String value for instruction
00002D2D= 41 44 44 51 00          2340  opNam_ADDQ          DC.B     'ADDQ',0                * String value for instruction
00002D32= 42 52 41 00             2341  opNam_BRA           DC.B     'BRA',0                 * String value for instruction
00002D36= 42 45 51 00             2342  opNam_BEQ           DC.B     'BEQ',0                 * String value for instruction
00002D3A= 42 47 54 00             2343  opNam_BGT           DC.B     'BGT',0                 * String value for instruction
00002D3E= 42 4C 45 00             2344  opNam_BLE           DC.B     'BLE',0                 * String value for instruction
00002D42= 4D 4F 56 45 51 00       2345  opNam_MOVEQ         DC.B     'MOVEQ',0               * String value for instruction
00002D48= 4F 52 00                2346  opNam_OR            DC.B     'OR',0                  * String value for instruction
00002D4B= 53 55 42 00             2347  opNam_SUB           DC.B     'SUB',0                 * String value for instruction
00002D4F= 41 4E 44 00             2348  opNam_AND           DC.B     'AND',0                 * String value for instruction
00002D53= 41 44 44 00             2349  opNam_ADD           DC.B     'ADD',0                 * String value for instruction
00002D57= 41 44 44 41 00          2350  opNam_ADDA          DC.B     'ADDA',0                * String value for instruction
00002D5C= 41 53 4C 00             2351  opNam_ASL           DC.B     'ASL',0                 * String value for instruction
00002D60= 41 53 52 00             2352  opNam_ASR           DC.B     'ASR',0                 * String value for instruction
00002D64= 4C 53 4C 00             2353  opNam_LSL           DC.B     'LSL',0                 * String value for instruction
00002D68= 4C 53 52 00             2354  opNam_LSR           DC.B     'LSR',0                 * String value for instruction
00002D6C= 52 4F 4C 00             2355  opNam_ROL           DC.B     'ROL',0                 * String value for instruction
00002D70= 52 4F 52 00             2356  opNam_ROR           DC.B     'ROR',0                 * String value for instruction
00002D74                          2357  
00002D74= 2E 42 00                2358  opSizB              DC.B     '.B',0                  * String value for instruction size 'B'
00002D77= 2E 57 00                2359  opSizW              DC.B     '.W',0                  * String value for instruction size 'W'
00002D7A= 2E 4C 00                2360  opSizL              DC.B     '.L',0                  * String value for instruction size 'L'
00002D7D                          2361  
00002D7D= 50 6C 61 63 65 68 ...   2362  msgInTemp           DC.B     'Placeholder for user input. 80 characters long is the max input limit...........',0
00002DCE= 45 72 72 6F 72 00       2363  msgErr              DC.B     'Error',0               * Debug message
00002DD4                          2364  
00002DD4= 33 20 43 6F 72 65 ...   2365  msgHdr01            DC.B     '3 Cores disassembler',CR,LF,0
00002DEB= 4D 65 6D 6F 72 79 ...   2366  msgHdr02a           DC.B     'Memory range:',0
00002DF9= 20 74 6F 20 00          2367  msgHdr02b           DC.B     ' to ',0
00002DFE                          2368  
00002DFE= 20 2D 20 41 6C 6C ...   2369  msgStrIntro         DC.B     ' - All addresses must be 32 bit hexadecimal.',CR,LF,0
00002E2D= 20 2D 20 56 61 6C ...   2370  msgStrRange         DC.B     ' - Valid address range is 00000000 to 00FFFFED.',CR,LF,0
00002E5F= 20 2D 20 53 74 61 ...   2371  msgStrSize          DC.B     ' - Starting address should start on a word boundry',CR,LF,0
00002E94= 20 20 20 40 20 58 ...   2372  msgStrSizeExmpl     DC.B     '   @ XXXXXXX(0,2,4,8,A,C,E).',CR,LF,0
00002EB3= 20 2D 20 41 64 64 ...   2373  msgStrNote          DC.B     ' - Addresses will be adjusted if out of order or out of range.',CR,LF,0
00002EF4= 20 20 20 28 61 75 ...   2374  msgStrNoteMore      DC.B     '   (automagically)',CR,LF,0
00002F09= 50 6C 65 61 73 65 ...   2375  msgStrAdr1          DC.B     'Please enter a starting address: ',0
00002F2B= 49 6E 76 61 6C 69 ...   2376  msgStrAdr1Err1      DC.B     'Invalid starting address length',CR,LF,0
00002F4D= 49 6E 76 61 6C 69 ...   2377  msgStrAdr1Err2      DC.B     'Invalid starting address hexadecimal value',CR,LF,0
00002F7A= 53 74 61 72 74 69 ...   2378  msgStrAdr1Scc       DC.B     'Starting address: ',0
00002F8D= 50 6C 65 61 73 65 ...   2379  msgStrAdr2          DC.B     'Please enter an ending address: ',0
00002FAE= 49 6E 76 61 6C 69 ...   2380  msgStrAdr2Err1      DC.B     'Invalid ending address length',CR,LF,0
00002FCE= 49 6E 76 61 6C 69 ...   2381  msgStrAdr2Err2      DC.B     'Invalid ending address hexadecimal value',CR,LF,0
00002FF9                          2382  
00002FF9= 48 69 74 20 45 6E ...   2383  msgPage             DC.B     'Hit Enter to go to the next page',CR,LF,0
0000301C= 59 6F 75 20 68 61 ...   2384  msgEndMem01         DC.B     'You have reached the end of the memory sequence.',CR,LF,0
0000304F= 20 20 20 20 20 20 ...   2385  msgEndMem02         DC.B     '         Y to continue or any other key to quit: ',0
00003081= 54 68 61 6E 6B 20 ...   2386  msgDone             DC.B     'Thank you for using 3 Cores disassembler!',0
000030AB                          2387  
000030AB= 2A 2A 2A 2A 2A 2A ...   2388  msgLine             DC.B     '**************************************************',CR,LF,0
000030E0= 0D 0A 00                2389  msgNewLine          DC.B     CR,LF,0
000030E3= 2C 00                   2390  opComma             DC.B     ',',0
000030E5= 2E 00                   2391  opPeriod            DC.B     '.',0
000030E7= 20 00                   2392  opSpace             DC.B     ' ',0
000030EA= 0900                    2393  opTab               DC.W     $0900                  * Tab - doesn't work as expected
000030EC= 00                      2394  opBlank             DC.B     '',0
000030ED  =0000000D               2395  CR                  EQU      $0D                     * ASCII code for Carriage Return
000030ED  =0000000A               2396  LF                  EQU      $0A                     * ASCII code for Line Feed
000030ED                          2397  
000030ED                          2398                      END      $1000

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADRSTREND           2C68
ADRSTRSTART         2C5A
ADRSTSEND           2C71
ADRSTSSTART         2C63
ADRVALEND           2C64
ADRVALSTART         2C56
CR                  D
FN_ASCII_LCLTR      19B6
FN_ASCII_NUM        19AA
FN_ASCII_UCLTR      19B0
FN_CPY_STR_DONE     1A14
FN_CPY_STR_LOOP     1A06
FN_DSP_DATA         15EC
FN_DSP_DONE         1984
FN_DSP_DTA1         1684
FN_DSP_DTA1_00      16DC
FN_DSP_DTA1_01      16F0
FN_DSP_DTA1_02      1704
FN_DSP_DTA1_03      1720
FN_DSP_DTA1_04      1740
FN_DSP_DTA1_07      1760
FN_DSP_DTA1_BYT     1788
FN_DSP_DTA1_ERR     17EE
FN_DSP_DTA1_LNG     17CC
FN_DSP_DTA1_WRD     17AA
FN_DSP_DTA2         180A
FN_DSP_DTA2_00      1862
FN_DSP_DTA2_01      1876
FN_DSP_DTA2_02      188A
FN_DSP_DTA2_03      18A6
FN_DSP_DTA2_04      18C6
FN_DSP_DTA2_07      18E6
FN_DSP_DTA2_BYT     190E
FN_DSP_DTA2_ERR     1974
FN_DSP_DTA2_LNG     1952
FN_DSP_DTA2_WRD     1930
FN_DSP_INSTR        1608
FN_DSP_OPR1         1678
FN_DSP_OPR2         17FE
FN_DSP_SIZB         1648
FN_DSP_SIZL         1668
FN_DSP_SIZW         1658
FN_HEX_LTR          19CE
FN_HEX_NUM          19C8
FN_HEX_STR_DONE     1A00
FN_HEX_STR_LOOP     19D4
FN_ID3_CHKDSTMOD    1C02
FN_ID3_CHKDSTREG    1C12
FN_ID3_CHKSRCREG    1B7C
FN_ID3_DONE         1C52
FN_ID3_DTADSTLNG    1C40
FN_ID3_DTADSTWRD    1C2E
FN_ID3_DTASRCBYT    1BCC
FN_ID3_DTASRCIMD    1BA4
FN_ID3_DTASRCLNG    1BF0
FN_ID3_DTASRCWRD    1BDE
FN_ID3_ERROR        1C5A
FN_ID3_INS01        1A9C
FN_ID3_INS02        1AAC
FN_ID3_SIZB         1B48
FN_ID3_SIZL         1B60
FN_ID3_SIZW         1B54
FN_ID3_SRCMOD       1B6C
FN_ID3_VERIFY       1AC4
FN_ID4_CHECKD1      1D0E
FN_ID4_CHECKD2      1D32
FN_ID4_CHECKD3      1D62
FN_ID4_DATA         2058
FN_ID4_DONE         20E0
FN_ID4_DTABYT       20A8
FN_ID4_DTAIMD       2080
FN_ID4_DTALNG       20CC
FN_ID4_DTAWRD       20BA
FN_ID4_ERROR        20DE
FN_ID4_JSR          1D7A
FN_ID4_JSR_SRC      1E16
FN_ID4_LEA          1E26
FN_ID4_LEA_SRC      1E86
FN_ID4_MOVEMMTOR    1F06
FN_ID4_MOVEMRTOM    1E96
FN_ID4_MOVEM_SRC    1F72
FN_ID4_NOP          1F82
FN_ID4_NOT          1FC2
FN_ID4_NOT_SRC      1FFE
FN_ID4_RTS          2018
FN_ID4_VERIFY_JSR   1D86
FN_ID4_VERIFY_LEA   1E32
FN_ID4_VERIFY_MMR   1F12
FN_ID4_VERIFY_MRM   1EA2
FN_ID4_VERIFY_NOP   1F8E
FN_ID4_VERIFY_NOT   1FCE
FN_ID4_VERIFY_RTS   2024
FN_ID5_CHKDSTMOD    2200
FN_ID5_CHKDSTREG    2210
FN_ID5_DONE         2252
FN_ID5_DTADSTLNG    223E
FN_ID5_DTADSTWRD    222C
FN_ID5_DTASRCBYT    21CA
FN_ID5_DTASRCIMD    21A2
FN_ID5_DTASRCLNG    21EE
FN_ID5_DTASRCWRD    21DC
FN_ID5_ERROR        2250
FN_ID5_VERIFY       2162
FN_ID6_BEQ          22D4
FN_ID6_BGT          22DE
FN_ID6_BLE          22E8
FN_ID6_BRA          22CA
FN_ID6_DISPLACEMENT  22EE
FN_ID6_DONE         2342
FN_ID6_DSPLCMNT16   231C
FN_ID6_DSPLCMNT32   232E
FN_ID6_ERROR        2340
FN_ID7_DONE         23CA
FN_ID7_ERROR        23C8
FN_ID8_CASE1        2460
FN_ID8_CASE2        24A2
FN_ID8_DATADST      24CA
FN_ID8_DATASRC      2550
FN_ID8_DONE         25D8
FN_ID8_DTADSTBYT    251A
FN_ID8_DTADSTIMD    24F2
FN_ID8_DTADSTLNG    253E
FN_ID8_DTADSTWRD    252C
FN_ID8_DTASRCBYT    25A0
FN_ID8_DTASRCIMD    2578
FN_ID8_DTASRCLNG    25C4
FN_ID8_DTASRCWRD    25B2
FN_ID8_ERROR        25D6
FN_ID9_CASE1        266E
FN_ID9_CASE2        26B0
FN_ID9_DATADST      26D8
FN_ID9_DATASRC      275E
FN_ID9_DONE         27E6
FN_ID9_DTADSTBYT    2728
FN_ID9_DTADSTIMD    2700
FN_ID9_DTADSTLNG    274C
FN_ID9_DTADSTWRD    273A
FN_ID9_DTASRCBYT    27AE
FN_ID9_DTASRCIMD    2786
FN_ID9_DTASRCLNG    27D2
FN_ID9_DTASRCWRD    27C0
FN_ID9_ERROR        27E4
FN_IDA_DONE         27E8
FN_IDB_DONE         27EA
FN_IDC_CASE1        2880
FN_IDC_CASE2        28C2
FN_IDC_DATADST      28EA
FN_IDC_DATASRC      2970
FN_IDC_DONE         29F8
FN_IDC_DTADSTBYT    293A
FN_IDC_DTADSTIMD    2912
FN_IDC_DTADSTLNG    295E
FN_IDC_DTADSTWRD    294C
FN_IDC_DTASRCBYT    29C0
FN_IDC_DTASRCIMD    2998
FN_IDC_DTASRCLNG    29E4
FN_IDC_DTASRCWRD    29D2
FN_IDC_ERROR        29F6
FN_IDD_CASE1        2AA0
FN_IDD_CASE2        2AE8
FN_IDD_CASE3        2B16
FN_IDD_DATADST      2B44
FN_IDD_DATASRC      2BCA
FN_IDD_DONE         2C52
FN_IDD_DTADSTBYT    2B94
FN_IDD_DTADSTIMD    2B6C
FN_IDD_DTADSTLNG    2BB8
FN_IDD_DTADSTWRD    2BA6
FN_IDD_DTASRCBYT    2C1A
FN_IDD_DTASRCIMD    2BF2
FN_IDD_DTASRCLNG    2C3E
FN_IDD_DTASRCWRD    2C2C
FN_IDD_ERROR        2C50
FN_MAIN_CHKAGN      1162
FN_MAIN_CHKEND      1154
FN_MAIN_CHKLIN      111C
FN_MAIN_CHKPAG      1132
FN_MAIN_CONTINUE    119A
FN_MAIN_DONE        119E
FN_MAIN_DSP         1116
FN_MAIN_ERRINS      1110
FN_MAIN_LOOP        105C
FN_MAIN_START       1006
FN_UI_CHKHEX        13FE
FN_UI_CHKHEXASL     1452
FN_UI_CHKHEXDONE    143A
FN_UI_CHKHEXLOOP    1404
FN_UI_CHKHEXRDR     1454
FN_UI_CHKLEN        13CA
FN_UI_CHKVAL        14DE
FN_UI_CHKVALCMP     1512
FN_UI_CHKVALEBIG    150C
FN_UI_CHKVALEMAX    14FE
FN_UI_CHKVALSBIG    14F8
FN_UI_CHKVALSMAX    14EA
FN_UI_CHKVALSONE    1538
FN_UI_CHKVALSWP     151C
FN_UI_CHKVALSWRD    1522
FN_UI_DONE          153A
FN_UI_DSPSTART      127A
FN_UI_END           1372
FN_UI_ENDE1         138E
FN_UI_ENDE2         139E
FN_UI_END_IN        13AE
FN_UI_HDRNEXT       129E
FN_UI_LOOP          1248
FN_UI_SETEHEX       14B6
FN_UI_SETEHEXI1     14C6
FN_UI_SETEHEXI2     14D2
FN_UI_SETELEN       13D6
FN_UI_SETELENI1     13E6
FN_UI_SETELENI2     13F2
FN_UI_SETVHEX       145E
FN_UI_SETVHEXI1     146E
FN_UI_SETVHEXI2     1492
FN_UI_START         131A
FN_UI_STARTE1       1336
FN_UI_STARTE2       1346
FN_UI_START_IN      1356
LF                  A
MAIN                1000
MAXLINES            1A
MSGDONE             3081
MSGENDMEM01         301C
MSGENDMEM02         304F
MSGERR              2DCE
MSGHDR01            2DD4
MSGHDR02A           2DEB
MSGHDR02B           2DF9
MSGINTEMP           2D7D
MSGLINE             30AB
MSGNEWLINE          30E0
MSGPAGE             2FF9
MSGSTRADR1          2F09
MSGSTRADR1ERR1      2F2B
MSGSTRADR1ERR2      2F4D
MSGSTRADR1SCC       2F7A
MSGSTRADR2          2F8D
MSGSTRADR2ERR1      2FAE
MSGSTRADR2ERR2      2FCE
MSGSTRINTRO         2DFE
MSGSTRNOTE          2EB3
MSGSTRNOTEMORE      2EF4
MSGSTRRANGE         2E2D
MSGSTRSIZE          2E5F
MSGSTRSIZEEXMPL     2E94
OPBLANK             30EC
OPCOMMA             30E3
OPDSTMOD            2CDE
OPDSTREG            2CDD
OPDTA1              2CE2
OPDTA1T             2CE6
OPDTA2              2CE8
OPDTA2T             2CEC
OPERR               2C75
OPID                2C74
OPIR                2D02
OPMASK              2CFC
OPNAM_ADD           2D53
OPNAM_ADDA          2D57
OPNAM_ADDQ          2D2D
OPNAM_AND           2D4F
OPNAM_ASL           2D5C
OPNAM_ASR           2D60
OPNAM_BEQ           2D36
OPNAM_BGT           2D3A
OPNAM_BLE           2D3E
OPNAM_BRA           2D32
OPNAM_DATA          2D03
OPNAM_JSR           2D29
OPNAM_LEA           2D13
OPNAM_LSL           2D64
OPNAM_LSR           2D68
OPNAM_MOVE          2D08
OPNAM_MOVEA         2D0D
OPNAM_MOVEM         2D1B
OPNAM_MOVEQ         2D42
OPNAM_NOP           2D21
OPNAM_NOT           2D17
OPNAM_OR            2D48
OPNAM_ROL           2D6C
OPNAM_ROR           2D70
OPNAM_RTS           2D25
OPNAM_SUB           2D4B
OPNXTADR            2C84
OPOUTBUF            2C88
OPPERIOD            30E5
OPPTRNAM            2CD8
OPROTATE            2D00
OPSIZB              2D74
OPSIZDIR            2D01
OPSIZL              2D7A
OPSIZW              2D77
OPSPACE             30E7
OPSRCMOD            2CE0
OPSRCREG            2CDF
OPSTRADR            2C7A
OPSTRDTALNG         2CF2
OPSTRDTAWRD         2CED
OPTAB               30EA
OPVALADR            2C76
OPVALSIZ            2CDC
OPWORD              2C72
SR_ASCII_HEX        1996
SR_CNT_STR_BUF      1A16
SR_CPY_STR_BUF      1A06
SR_DSP_DISPLAY      15B4
SR_DSP_HEADER       1552
SR_HEX_ASCII        19BC
SR_HEX_STR          19D4
SR_ID3              1A1A
SR_ID4              1C5C
SR_ID5              20EA
SR_ID6              2254
SR_ID7              2344
SR_ID8              23CC
SR_ID9              25DA
SR_IDA              27E8
SR_IDB              27EA
SR_IDC              27EC
SR_IDD              29FA
SR_IDE              2C54
SR_IDX              1A18
SR_JUMP             11B8
SR_UI_INPUT         1238
